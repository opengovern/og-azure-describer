// Code is generated by go generate. DO NOT EDIT.
package keibi

import (
	"context"
	azure "github.com/kaytu-io/kaytu-azure-describer/azure/model"
	essdk "github.com/kaytu-io/kaytu-util/pkg/keibi-es-sdk"
	"github.com/turbot/steampipe-plugin-sdk/v4/plugin"
)

type Client struct {
	essdk.Client
}

// ==========================  START: APIManagement =============================

type APIManagement struct {
	Description   azure.APIManagementDescription `json:"description"`
	Metadata      azure.Metadata                 `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type APIManagementHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  APIManagement `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type APIManagementHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []APIManagementHit `json:"hits"`
}

type APIManagementSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  APIManagementHits `json:"hits"`
}

type APIManagementPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAPIManagementPaginator(filters []essdk.BoolFilter, limit *int64) (APIManagementPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_apimanagement_service", filters, limit)
	if err != nil {
		return APIManagementPaginator{}, err
	}

	p := APIManagementPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p APIManagementPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p APIManagementPaginator) NextPage(ctx context.Context) ([]APIManagement, error) {
	var response APIManagementSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []APIManagement
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAPIManagementFilters = map[string]string{
	"additional_locations":              "description.APIManagement.ServiceProperties.AdditionalLocations",
	"akas":                              "description.APIManagement.ID",
	"api_version_constraint":            "description.APIManagement.ServiceProperties.APIVersionConstraint",
	"certificates":                      "description.APIManagement.ServiceProperties.Certificates",
	"created_at_utc":                    "description.APIManagement.ServiceProperties.CreatedAtUtc",
	"custom_properties":                 "description.APIManagement.ServiceProperties.CustomProperties",
	"developer_portal_url":              "description.APIManagement.ServiceProperties.DeveloperPortalURL",
	"diagnostic_settings":               "description.DiagnosticSettingsResources",
	"disable_gateway":                   "description.APIManagement.ServiceProperties.DisableGateway",
	"enable_client_certificate":         "description.APIManagement.ServiceProperties.EnableClientCertificate",
	"etag":                              "description.APIManagement.Etag",
	"gateway_regional_url":              "description.APIManagement.ServiceProperties.GatewayRegionalURL",
	"gateway_url":                       "description.APIManagement.ServiceProperties.GatewayURL",
	"host_name_configurations":          "description.APIManagement.ServiceProperties.HostnameConfigurations",
	"id":                                "description.APIManagement.ID",
	"identity_principal_id":             "description.APIManagement.Identity.PrincipalID",
	"identity_tenant_id":                "description.APIManagement.Identity.TenantID",
	"identity_type":                     "description.APIManagement.Identity.Type",
	"identity_user_assigned_identities": "description.APIManagement.Identity.UserAssignedIdentities",
	"kaytu_account_id":                  "metadata.SourceID",
	"management_api_url":                "description.APIManagement.ServiceProperties.ManagementAPIURL",
	"name":                              "description.APIManagement.Name",
	"notification_sender_email":         "description.APIManagement.ServiceProperties.NotificationSenderEmail",
	"portal_url":                        "description.APIManagement.ServiceProperties.PortalURL",
	"private_ip_addresses":              "description.APIManagement.ServiceProperties.PrivateIPAddresses",
	"provisioning_state":                "description.APIManagement.ServiceProperties.ProvisioningState",
	"public_ip_addresses":               "description.APIManagement.ServiceProperties.PublicIPAddresses",
	"publisher_email":                   "description.APIManagement.ServiceProperties.PublisherEmail",
	"publisher_name":                    "description.APIManagement.ServiceProperties.PublisherName",
	"region":                            "description.APIManagement.Location",
	"resource_group":                    "description.ResourceGroup",
	"restore":                           "description.APIManagement.ServiceProperties.Restore",
	"scm_url":                           "description.APIManagement.ServiceProperties.ScmURL",
	"sku_capacity":                      "description.APIManagement.Sku.Capacity",
	"sku_name":                          "description.APIManagement.Sku.Name",
	"tags":                              "description.APIManagement.Tags",
	"target_provisioning_state":         "description.APIManagement.ServiceProperties.TargetProvisioningState",
	"title":                             "description.APIManagement.Name",
	"type":                              "description.APIManagement.Type",
	"virtual_network_configuration_id":  "description.APIManagement.ServiceProperties.VirtualNetworkConfiguration.Vnetid",
	"virtual_network_configuration_subnet_name":        "description.APIManagement.ServiceProperties.VirtualNetworkConfiguration.Subnetname",
	"virtual_network_configuration_subnet_resource_id": "description.APIManagement.ServiceProperties.VirtualNetworkConfiguration.SubnetResourceID",
	"virtual_network_type":                             "description.APIManagement.ServiceProperties.VirtualNetworkType",
	"zones":                                            "description.APIManagement.Zones",
}

func ListAPIManagement(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAPIManagement")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAPIManagementPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAPIManagementFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAPIManagementFilters = map[string]string{
	"additional_locations":              "description.APIManagement.ServiceProperties.AdditionalLocations",
	"akas":                              "description.APIManagement.ID",
	"api_version_constraint":            "description.APIManagement.ServiceProperties.APIVersionConstraint",
	"certificates":                      "description.APIManagement.ServiceProperties.Certificates",
	"created_at_utc":                    "description.APIManagement.ServiceProperties.CreatedAtUtc",
	"custom_properties":                 "description.APIManagement.ServiceProperties.CustomProperties",
	"developer_portal_url":              "description.APIManagement.ServiceProperties.DeveloperPortalURL",
	"diagnostic_settings":               "description.DiagnosticSettingsResources",
	"disable_gateway":                   "description.APIManagement.ServiceProperties.DisableGateway",
	"enable_client_certificate":         "description.APIManagement.ServiceProperties.EnableClientCertificate",
	"etag":                              "description.APIManagement.Etag",
	"gateway_regional_url":              "description.APIManagement.ServiceProperties.GatewayRegionalURL",
	"gateway_url":                       "description.APIManagement.ServiceProperties.GatewayURL",
	"host_name_configurations":          "description.APIManagement.ServiceProperties.HostnameConfigurations",
	"id":                                "description.APIManagement.ID",
	"identity_principal_id":             "description.APIManagement.Identity.PrincipalID",
	"identity_tenant_id":                "description.APIManagement.Identity.TenantID",
	"identity_type":                     "description.APIManagement.Identity.Type",
	"identity_user_assigned_identities": "description.APIManagement.Identity.UserAssignedIdentities",
	"kaytu_account_id":                  "metadata.SourceID",
	"management_api_url":                "description.APIManagement.ServiceProperties.ManagementAPIURL",
	"name":                              "description.APIManagement.name",
	"notification_sender_email":         "description.APIManagement.ServiceProperties.NotificationSenderEmail",
	"portal_url":                        "description.APIManagement.ServiceProperties.PortalURL",
	"private_ip_addresses":              "description.APIManagement.ServiceProperties.PrivateIPAddresses",
	"provisioning_state":                "description.APIManagement.ServiceProperties.ProvisioningState",
	"public_ip_addresses":               "description.APIManagement.ServiceProperties.PublicIPAddresses",
	"publisher_email":                   "description.APIManagement.ServiceProperties.PublisherEmail",
	"publisher_name":                    "description.APIManagement.ServiceProperties.PublisherName",
	"region":                            "description.APIManagement.Location",
	"resource_group":                    "description.ResourceGroup",
	"restore":                           "description.APIManagement.ServiceProperties.Restore",
	"scm_url":                           "description.APIManagement.ServiceProperties.ScmURL",
	"sku_capacity":                      "description.APIManagement.Sku.Capacity",
	"sku_name":                          "description.APIManagement.Sku.Name",
	"tags":                              "description.APIManagement.Tags",
	"target_provisioning_state":         "description.APIManagement.ServiceProperties.TargetProvisioningState",
	"title":                             "description.APIManagement.Name",
	"type":                              "description.APIManagement.Type",
	"virtual_network_configuration_id":  "description.APIManagement.ServiceProperties.VirtualNetworkConfiguration.Vnetid",
	"virtual_network_configuration_subnet_name":        "description.APIManagement.ServiceProperties.VirtualNetworkConfiguration.Subnetname",
	"virtual_network_configuration_subnet_resource_id": "description.APIManagement.ServiceProperties.VirtualNetworkConfiguration.SubnetResourceID",
	"virtual_network_type":                             "description.APIManagement.ServiceProperties.VirtualNetworkType",
	"zones":                                            "description.APIManagement.Zones",
}

func GetAPIManagement(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAPIManagement")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAPIManagementPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAPIManagementFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: APIManagement =============================

// ==========================  START: AutomationAccounts =============================

type AutomationAccounts struct {
	Description   azure.AutomationAccountsDescription `json:"description"`
	Metadata      azure.Metadata                      `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type AutomationAccountsHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  AutomationAccounts `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type AutomationAccountsHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []AutomationAccountsHit `json:"hits"`
}

type AutomationAccountsSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  AutomationAccountsHits `json:"hits"`
}

type AutomationAccountsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAutomationAccountsPaginator(filters []essdk.BoolFilter, limit *int64) (AutomationAccountsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_automation_automationaccounts", filters, limit)
	if err != nil {
		return AutomationAccountsPaginator{}, err
	}

	p := AutomationAccountsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AutomationAccountsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AutomationAccountsPaginator) NextPage(ctx context.Context) ([]AutomationAccounts, error) {
	var response AutomationAccountsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AutomationAccounts
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAutomationAccountsFilters = map[string]string{
	"akas":             "description.Accounts.ID",
	"id":               "description.Accounts.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Accounts.Name",
	"tags":             "description.Accounts.Tags",
	"title":            "description.Accounts.Name",
}

func ListAutomationAccounts(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAutomationAccounts")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAutomationAccountsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAutomationAccountsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAutomationAccountsFilters = map[string]string{
	"akas":             "description.Accounts.ID",
	"id":               "description.Accounts.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Accounts.Name",
	"tags":             "description.Accounts.Tags",
	"title":            "description.Accounts.Name",
}

func GetAutomationAccounts(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAutomationAccounts")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAutomationAccountsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAutomationAccountsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AutomationAccounts =============================

// ==========================  START: AppConfiguration =============================

type AppConfiguration struct {
	Description   azure.AppConfigurationDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type AppConfigurationHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  AppConfiguration `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type AppConfigurationHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []AppConfigurationHit `json:"hits"`
}

type AppConfigurationSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  AppConfigurationHits `json:"hits"`
}

type AppConfigurationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppConfigurationPaginator(filters []essdk.BoolFilter, limit *int64) (AppConfigurationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_appconfiguration_configurationstores", filters, limit)
	if err != nil {
		return AppConfigurationPaginator{}, err
	}

	p := AppConfigurationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppConfigurationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppConfigurationPaginator) NextPage(ctx context.Context) ([]AppConfiguration, error) {
	var response AppConfigurationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppConfiguration
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppConfigurationFilters = map[string]string{
	"akas":                  "description.ConfigurationStore.ID",
	"creation_date":         "description.ConfigurationStore.ConfigurationStoreProperties.CreationDate",
	"diagnostic_settings":   "description.DiagnosticSettingsResources",
	"encryption":            "description.ConfigurationStore.ConfigurationStoreProperties.Encryption",
	"endpoint":              "description.ConfigurationStore.ConfigurationStoreProperties.Endpoint",
	"id":                    "description.ConfigurationStore.ID",
	"identity":              "description.ConfigurationStore.Identity",
	"kaytu_account_id":      "metadata.SourceID",
	"name":                  "description.ConfigurationStore.Name",
	"provisioning_state":    "description.ConfigurationStore.ConfigurationStoreProperties.ProvisioningState",
	"public_network_access": "description.ConfigurationStore.ConfigurationStoreProperties.PublicNetworkAccess",
	"region":                "description.ConfigurationStore.Location",
	"resource_group":        "description.ResourceGroup",
	"sku_name":              "description.ConfigurationStore.Sku.Name",
	"tags":                  "description.ConfigurationStore.Tags",
	"title":                 "description.ConfigurationStore.Name",
	"type":                  "description.ConfigurationStore.Type",
}

func ListAppConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppConfiguration")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAppConfigurationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAppConfigurationFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAppConfigurationFilters = map[string]string{
	"akas":                  "description.ConfigurationStore.ID",
	"creation_date":         "description.ConfigurationStore.ConfigurationStoreProperties.CreationDate",
	"diagnostic_settings":   "description.DiagnosticSettingsResources",
	"encryption":            "description.ConfigurationStore.ConfigurationStoreProperties.Encryption",
	"endpoint":              "description.ConfigurationStore.ConfigurationStoreProperties.Endpoint",
	"id":                    "description.ConfigurationStore.ID",
	"identity":              "description.ConfigurationStore.Identity",
	"kaytu_account_id":      "metadata.SourceID",
	"name":                  "description.ConfigurationStore.name",
	"provisioning_state":    "description.ConfigurationStore.ConfigurationStoreProperties.ProvisioningState",
	"public_network_access": "description.ConfigurationStore.ConfigurationStoreProperties.PublicNetworkAccess",
	"region":                "description.ConfigurationStore.Location",
	"resource_group":        "description.ResourceGroup",
	"sku_name":              "description.ConfigurationStore.Sku.Name",
	"tags":                  "description.ConfigurationStore.Tags",
	"title":                 "description.ConfigurationStore.Name",
	"type":                  "description.ConfigurationStore.Type",
}

func GetAppConfiguration(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppConfiguration")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAppConfigurationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAppConfigurationFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AppConfiguration =============================

// ==========================  START: AppServiceEnvironment =============================

type AppServiceEnvironment struct {
	Description   azure.AppServiceEnvironmentDescription `json:"description"`
	Metadata      azure.Metadata                         `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type AppServiceEnvironmentHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  AppServiceEnvironment `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type AppServiceEnvironmentHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []AppServiceEnvironmentHit `json:"hits"`
}

type AppServiceEnvironmentSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  AppServiceEnvironmentHits `json:"hits"`
}

type AppServiceEnvironmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppServiceEnvironmentPaginator(filters []essdk.BoolFilter, limit *int64) (AppServiceEnvironmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_web_hostingenvironments", filters, limit)
	if err != nil {
		return AppServiceEnvironmentPaginator{}, err
	}

	p := AppServiceEnvironmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppServiceEnvironmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppServiceEnvironmentPaginator) NextPage(ctx context.Context) ([]AppServiceEnvironment, error) {
	var response AppServiceEnvironmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppServiceEnvironment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppServiceEnvironmentFilters = map[string]string{
	"akas":                           "description.AppServiceEnvironmentResource.ID",
	"cluster_settings":               "description.AppServiceEnvironmentResource.AppServiceEnvironment.ClusterSettings",
	"default_front_end_scale_factor": "description.AppServiceEnvironmentResource.AppServiceEnvironment.DefaultFrontEndScaleFactor",
	"dynamic_cache_enabled":          "description.AppServiceEnvironmentResource.AppServiceEnvironment.DynamicCacheEnabled",
	"front_end_scale_factor":         "description.AppServiceEnvironmentResource.AppServiceEnvironment.FrontEndScaleFactor",
	"has_linux_workers":              "description.AppServiceEnvironmentResource.AppServiceEnvironment.HasLinuxWorkers",
	"id":                             "description.AppServiceEnvironmentResource.ID",
	"internal_load_balancing_mode":   "description.AppServiceEnvironmentResource.AppServiceEnvironment.InternalLoadBalancingMode",
	"is_healthy_environment":         "description.AppServiceEnvironmentResource.AppServiceEnvironment.EnvironmentIsHealthy",
	"kaytu_account_id":               "metadata.SourceID",
	"kind":                           "description.AppServiceEnvironmentResource.Kind",
	"name":                           "description.AppServiceEnvironmentResource.Name",
	"provisioning_state":             "description.AppServiceEnvironmentResource.AppServiceEnvironment.ProvisioningState",
	"region":                         "description.AppServiceEnvironmentResource.Location",
	"resource_group":                 "description.AppServiceEnvironmentResource.AppServiceEnvironment.ResourceGroup",
	"status":                         "description.AppServiceEnvironmentResource.AppServiceEnvironment.Status",
	"suspended":                      "description.AppServiceEnvironmentResource.AppServiceEnvironment.Suspended",
	"tags":                           "description.AppServiceEnvironmentResource.Tags",
	"title":                          "description.AppServiceEnvironmentResource.Name",
	"type":                           "description.AppServiceEnvironmentResource.Type",
	"vnet_name":                      "description.AppServiceEnvironmentResource.AppServiceEnvironment.VnetName",
	"vnet_resource_group_name":       "description.AppServiceEnvironmentResource.AppServiceEnvironment.VnetResourceGroupName",
	"vnet_subnet_name":               "description.AppServiceEnvironmentResource.AppServiceEnvironment.VnetSubnetName",
}

func ListAppServiceEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppServiceEnvironment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAppServiceEnvironmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAppServiceEnvironmentFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAppServiceEnvironmentFilters = map[string]string{
	"akas":                           "description.AppServiceEnvironmentResource.ID",
	"cluster_settings":               "description.AppServiceEnvironmentResource.AppServiceEnvironment.ClusterSettings",
	"default_front_end_scale_factor": "description.AppServiceEnvironmentResource.AppServiceEnvironment.DefaultFrontEndScaleFactor",
	"dynamic_cache_enabled":          "description.AppServiceEnvironmentResource.AppServiceEnvironment.DynamicCacheEnabled",
	"front_end_scale_factor":         "description.AppServiceEnvironmentResource.AppServiceEnvironment.FrontEndScaleFactor",
	"has_linux_workers":              "description.AppServiceEnvironmentResource.AppServiceEnvironment.HasLinuxWorkers",
	"id":                             "description.AppServiceEnvironmentResource.ID",
	"internal_load_balancing_mode":   "description.AppServiceEnvironmentResource.AppServiceEnvironment.InternalLoadBalancingMode",
	"is_healthy_environment":         "description.AppServiceEnvironmentResource.AppServiceEnvironment.EnvironmentIsHealthy",
	"kaytu_account_id":               "metadata.SourceID",
	"kind":                           "description.AppServiceEnvironmentResource.Kind",
	"name":                           "description.AppServiceEnvironmentResource.name",
	"provisioning_state":             "description.AppServiceEnvironmentResource.AppServiceEnvironment.ProvisioningState",
	"region":                         "description.AppServiceEnvironmentResource.Location",
	"resource_group":                 "description.ResourceGroup",
	"status":                         "description.AppServiceEnvironmentResource.AppServiceEnvironment.Status",
	"suspended":                      "description.AppServiceEnvironmentResource.AppServiceEnvironment.Suspended",
	"tags":                           "description.AppServiceEnvironmentResource.Tags",
	"title":                          "description.AppServiceEnvironmentResource.Name",
	"type":                           "description.AppServiceEnvironmentResource.Type",
	"vnet_name":                      "description.AppServiceEnvironmentResource.AppServiceEnvironment.VnetName",
	"vnet_resource_group_name":       "description.AppServiceEnvironmentResource.AppServiceEnvironment.VnetResourceGroupName",
	"vnet_subnet_name":               "description.AppServiceEnvironmentResource.AppServiceEnvironment.VnetSubnetName",
}

func GetAppServiceEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppServiceEnvironment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAppServiceEnvironmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAppServiceEnvironmentFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AppServiceEnvironment =============================

// ==========================  START: AppServiceFunctionApp =============================

type AppServiceFunctionApp struct {
	Description   azure.AppServiceFunctionAppDescription `json:"description"`
	Metadata      azure.Metadata                         `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type AppServiceFunctionAppHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  AppServiceFunctionApp `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type AppServiceFunctionAppHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []AppServiceFunctionAppHit `json:"hits"`
}

type AppServiceFunctionAppSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  AppServiceFunctionAppHits `json:"hits"`
}

type AppServiceFunctionAppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppServiceFunctionAppPaginator(filters []essdk.BoolFilter, limit *int64) (AppServiceFunctionAppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_web_sites", filters, limit)
	if err != nil {
		return AppServiceFunctionAppPaginator{}, err
	}

	p := AppServiceFunctionAppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppServiceFunctionAppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppServiceFunctionAppPaginator) NextPage(ctx context.Context) ([]AppServiceFunctionApp, error) {
	var response AppServiceFunctionAppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppServiceFunctionApp
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppServiceFunctionAppFilters = map[string]string{
	"akas":                           "description.Site.ID",
	"auth_settings":                  "description.SiteAuthSettings",
	"client_affinity_enabled":        "description.Site.SiteProperties.ClientAffinityEnabled",
	"client_cert_enabled":            "description.Site.SiteProperties.ClientCertEnabled",
	"configuration":                  "description.SiteConfigResource",
	"default_site_hostname":          "description.Site.SiteProperties.DefaultHostName",
	"enabled":                        "description.Site.SiteProperties.Enabled",
	"host_name_disabled":             "description.Site.SiteProperties.HostNamesDisabled",
	"host_names":                     "description.Site.SiteProperties.HostNames",
	"https_only":                     "description.Site.SiteProperties.HTTPSOnly",
	"id":                             "description.Site.ID",
	"kaytu_account_id":               "metadata.SourceID",
	"kind":                           "description.Site.Kind",
	"name":                           "description.Site.Name",
	"outbound_ip_addresses":          "description.Site.SiteProperties.OutboundIPAddresses",
	"possible_outbound_ip_addresses": "description.Site.SiteProperties.PossibleOutboundIPAddresses",
	"region":                         "description.Site.Location",
	"reserved":                       "description.Site.SiteProperties.Reserved",
	"resource_group":                 "description.Site.SiteProperties.ResourceGroup",
	"site_config":                    "description.Site.SiteProperties.SiteConfig",
	"state":                          "description.Site.SiteProperties.State",
	"tags":                           "description.Site.Tags",
	"title":                          "description.Site.Name",
	"type":                           "description.Site.Type",
}

func ListAppServiceFunctionApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppServiceFunctionApp")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAppServiceFunctionAppPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAppServiceFunctionAppFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAppServiceFunctionAppFilters = map[string]string{
	"akas":                           "description.Site.ID",
	"auth_settings":                  "description.SiteAuthSettings",
	"client_affinity_enabled":        "description.Site.SiteProperties.ClientAffinityEnabled",
	"client_cert_enabled":            "description.Site.SiteProperties.ClientCertEnabled",
	"configuration":                  "description.SiteConfigResource",
	"default_site_hostname":          "description.Site.SiteProperties.DefaultHostName",
	"enabled":                        "description.Site.SiteProperties.Enabled",
	"host_name_disabled":             "description.Site.SiteProperties.HostNamesDisabled",
	"host_names":                     "description.Site.SiteProperties.HostNames",
	"https_only":                     "description.Site.SiteProperties.HTTPSOnly",
	"id":                             "description.Site.ID",
	"kaytu_account_id":               "metadata.SourceID",
	"kind":                           "description.Site.Kind",
	"name":                           "description.Site.name",
	"outbound_ip_addresses":          "description.Site.SiteProperties.OutboundIPAddresses",
	"possible_outbound_ip_addresses": "description.Site.SiteProperties.PossibleOutboundIPAddresses",
	"region":                         "description.Site.Location",
	"reserved":                       "description.Site.SiteProperties.Reserved",
	"resource_group":                 "description.ResourceGroup",
	"site_config":                    "description.Site.SiteProperties.SiteConfig",
	"state":                          "description.Site.SiteProperties.State",
	"tags":                           "description.Site.Tags",
	"title":                          "description.Site.Name",
	"type":                           "description.Site.Type",
}

func GetAppServiceFunctionApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppServiceFunctionApp")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAppServiceFunctionAppPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAppServiceFunctionAppFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AppServiceFunctionApp =============================

// ==========================  START: AppServiceWebApp =============================

type AppServiceWebApp struct {
	Description   azure.AppServiceWebAppDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type AppServiceWebAppHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  AppServiceWebApp `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type AppServiceWebAppHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []AppServiceWebAppHit `json:"hits"`
}

type AppServiceWebAppSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  AppServiceWebAppHits `json:"hits"`
}

type AppServiceWebAppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppServiceWebAppPaginator(filters []essdk.BoolFilter, limit *int64) (AppServiceWebAppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_web_staticsites", filters, limit)
	if err != nil {
		return AppServiceWebAppPaginator{}, err
	}

	p := AppServiceWebAppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppServiceWebAppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppServiceWebAppPaginator) NextPage(ctx context.Context) ([]AppServiceWebApp, error) {
	var response AppServiceWebAppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppServiceWebApp
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppServiceWebAppFilters = map[string]string{
	"akas":                           "description.Site.ID",
	"auth_settings":                  "description.SiteAuthSettings",
	"client_affinity_enabled":        "description.Site.SiteProperties.ClientAffinityEnabled",
	"client_cert_enabled":            "description.Site.SiteProperties.ClientCertEnabled",
	"configuration":                  "description.SiteConfigResource",
	"default_site_hostname":          "description.Site.SiteProperties.DefaultHostName",
	"enabled":                        "description.Site.SiteProperties.Enabled",
	"host_name_disabled":             "description.Site.SiteProperties.HostNamesDisabled",
	"host_names":                     "description.Site.SiteProperties.HostNames",
	"https_only":                     "description.Site.SiteProperties.HTTPSOnly",
	"id":                             "description.Site.ID",
	"kaytu_account_id":               "metadata.SourceID",
	"kind":                           "description.Site.Kind",
	"name":                           "description.Site.Name",
	"outbound_ip_addresses":          "description.Site.SiteProperties.OutboundIPAddresses",
	"possible_outbound_ip_addresses": "description.Site.SiteProperties.PossibleOutboundIPAddresses",
	"region":                         "description.Site.Location",
	"reserved":                       "description.Site.SiteProperties.Reserved",
	"resource_group":                 "description.Site.SiteProperties.ResourceGroup",
	"site_config":                    "description.Site.SiteProperties.SiteConfig",
	"state":                          "description.Site.SiteProperties.State",
	"tags":                           "description.Site.Tags",
	"title":                          "description.Site.Name",
	"type":                           "description.Site.Type",
	"vnet_connection":                "description.VnetInfo",
}

func ListAppServiceWebApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppServiceWebApp")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAppServiceWebAppPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAppServiceWebAppFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAppServiceWebAppFilters = map[string]string{
	"akas":                           "description.Site.ID",
	"auth_settings":                  "description.SiteAuthSettings",
	"client_affinity_enabled":        "description.Site.SiteProperties.ClientAffinityEnabled",
	"client_cert_enabled":            "description.Site.SiteProperties.ClientCertEnabled",
	"configuration":                  "description.SiteConfigResource",
	"default_site_hostname":          "description.Site.SiteProperties.DefaultHostName",
	"enabled":                        "description.Site.SiteProperties.Enabled",
	"host_name_disabled":             "description.Site.SiteProperties.HostNamesDisabled",
	"host_names":                     "description.Site.SiteProperties.HostNames",
	"https_only":                     "description.Site.SiteProperties.HTTPSOnly",
	"id":                             "description.Site.ID",
	"kaytu_account_id":               "metadata.SourceID",
	"kind":                           "description.Site.Kind",
	"name":                           "description.Site.name",
	"outbound_ip_addresses":          "description.Site.SiteProperties.OutboundIPAddresses",
	"possible_outbound_ip_addresses": "description.Site.SiteProperties.PossibleOutboundIPAddresses",
	"region":                         "description.Site.Location",
	"reserved":                       "description.Site.SiteProperties.Reserved",
	"resource_group":                 "description.ResourceGroup",
	"site_config":                    "description.Site.SiteProperties.SiteConfig",
	"state":                          "description.Site.SiteProperties.State",
	"tags":                           "description.Site.Tags",
	"title":                          "description.Site.Name",
	"type":                           "description.Site.Type",
	"vnet_connection":                "description.VnetInfo",
}

func GetAppServiceWebApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppServiceWebApp")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAppServiceWebAppPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAppServiceWebAppFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AppServiceWebApp =============================

// ==========================  START: AppServicePlan =============================

type AppServicePlan struct {
	Description   azure.AppServicePlanDescription `json:"description"`
	Metadata      azure.Metadata                  `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type AppServicePlanHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  AppServicePlan `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type AppServicePlanHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []AppServicePlanHit `json:"hits"`
}

type AppServicePlanSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  AppServicePlanHits `json:"hits"`
}

type AppServicePlanPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppServicePlanPaginator(filters []essdk.BoolFilter, limit *int64) (AppServicePlanPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_web_plan", filters, limit)
	if err != nil {
		return AppServicePlanPaginator{}, err
	}

	p := AppServicePlanPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppServicePlanPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppServicePlanPaginator) NextPage(ctx context.Context) ([]AppServicePlan, error) {
	var response AppServicePlanSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppServicePlan
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppServicePlanFilters = map[string]string{
	"akas":                         "description.Plan.ID",
	"apps":                         "description.Apps",
	"hyper_v":                      "description.Plan.AppServicePlanProperties.HyperV",
	"id":                           "description.Plan.ID",
	"is_spot":                      "description.Plan.AppServicePlanProperties.IsSpot",
	"is_xenon":                     "description.Plan.AppServicePlanProperties.IsXenon",
	"kaytu_account_id":             "metadata.SourceID",
	"kind":                         "description.Plan.Kind",
	"maximum_elastic_worker_count": "description.Plan.AppServicePlanProperties.MaximumElasticWorkerCount",
	"maximum_number_of_workers":    "description.Plan.AppServicePlanProperties.MaximumNumberOfWorkers",
	"name":                         "description.Plan.Name",
	"per_site_scaling":             "description.Plan.AppServicePlanProperties.PerSiteScaling",
	"provisioning_state":           "description.Plan.AppServicePlanProperties.ProvisioningState",
	"region":                       "description.Plan.Location",
	"reserved":                     "description.Plan.AppServicePlanProperties.Reserved",
	"resource_group":               "description.ResourceGroup",
	"sku_capacity":                 "description.Plan.Sku.Capacity",
	"sku_family":                   "description.Plan.Sku.Family",
	"sku_name":                     "description.Plan.Sku.Name",
	"sku_size":                     "description.Plan.Sku.Size",
	"sku_tier":                     "description.Plan.Sku.Tier",
	"status":                       "description.Plan.AppServicePlanProperties.Status",
	"tags":                         "description.Plan.Tags",
	"title":                        "description.Plan.Name",
	"type":                         "description.Plan.Type",
}

func ListAppServicePlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppServicePlan")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAppServicePlanPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAppServicePlanFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAppServicePlanFilters = map[string]string{
	"akas":                         "description.Plan.ID",
	"apps":                         "description.Apps",
	"hyper_v":                      "description.Plan.AppServicePlanProperties.HyperV",
	"id":                           "description.Plan.ID",
	"is_spot":                      "description.Plan.AppServicePlanProperties.IsSpot",
	"is_xenon":                     "description.Plan.AppServicePlanProperties.IsXenon",
	"kaytu_account_id":             "metadata.SourceID",
	"kind":                         "description.Plan.Kind",
	"maximum_elastic_worker_count": "description.Plan.AppServicePlanProperties.MaximumElasticWorkerCount",
	"maximum_number_of_workers":    "description.Plan.AppServicePlanProperties.MaximumNumberOfWorkers",
	"name":                         "description.Site.name",
	"per_site_scaling":             "description.Plan.AppServicePlanProperties.PerSiteScaling",
	"provisioning_state":           "description.Plan.AppServicePlanProperties.ProvisioningState",
	"region":                       "description.Plan.Location",
	"reserved":                     "description.Plan.AppServicePlanProperties.Reserved",
	"resource_group":               "description.ResourceGroup",
	"sku_capacity":                 "description.Plan.Sku.Capacity",
	"sku_family":                   "description.Plan.Sku.Family",
	"sku_name":                     "description.Plan.Sku.Name",
	"sku_size":                     "description.Plan.Sku.Size",
	"sku_tier":                     "description.Plan.Sku.Tier",
	"status":                       "description.Plan.AppServicePlanProperties.Status",
	"tags":                         "description.Plan.Tags",
	"title":                        "description.Plan.Name",
	"type":                         "description.Plan.Type",
}

func GetAppServicePlan(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppServicePlan")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAppServicePlanPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAppServicePlanFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AppServicePlan =============================

// ==========================  START: ContainerApp =============================

type ContainerApp struct {
	Description   azure.ContainerAppDescription `json:"description"`
	Metadata      azure.Metadata                `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type ContainerAppHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ContainerApp  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ContainerAppHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ContainerAppHit `json:"hits"`
}

type ContainerAppSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  ContainerAppHits `json:"hits"`
}

type ContainerAppPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewContainerAppPaginator(filters []essdk.BoolFilter, limit *int64) (ContainerAppPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_app_containerapps", filters, limit)
	if err != nil {
		return ContainerAppPaginator{}, err
	}

	p := ContainerAppPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ContainerAppPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ContainerAppPaginator) NextPage(ctx context.Context) ([]ContainerApp, error) {
	var response ContainerAppSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ContainerApp
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listContainerAppFilters = map[string]string{
	"akas":             "description.ContainerApps.ID",
	"id":               "description.ContainerApps.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ContainerApps.Name",
	"tags":             "description.ContainerApps.Tags",
	"title":            "description.ContainerApps.Name",
}

func ListContainerApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListContainerApp")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewContainerAppPaginator(essdk.BuildFilter(d.KeyColumnQuals, listContainerAppFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getContainerAppFilters = map[string]string{
	"akas":             "description.ContainerApps.ID",
	"id":               "description.ContainerApps.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ContainerApps.Name",
	"tags":             "description.ContainerApps.Tags",
	"title":            "description.ContainerApps.Name",
}

func GetContainerApp(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetContainerApp")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewContainerAppPaginator(essdk.BuildFilter(d.KeyColumnQuals, getContainerAppFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ContainerApp =============================

// ==========================  START: AppManagedEnvironment =============================

type AppManagedEnvironment struct {
	Description   azure.AppManagedEnvironmentDescription `json:"description"`
	Metadata      azure.Metadata                         `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type AppManagedEnvironmentHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  AppManagedEnvironment `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type AppManagedEnvironmentHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []AppManagedEnvironmentHit `json:"hits"`
}

type AppManagedEnvironmentSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  AppManagedEnvironmentHits `json:"hits"`
}

type AppManagedEnvironmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAppManagedEnvironmentPaginator(filters []essdk.BoolFilter, limit *int64) (AppManagedEnvironmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_app_managedenvironments", filters, limit)
	if err != nil {
		return AppManagedEnvironmentPaginator{}, err
	}

	p := AppManagedEnvironmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AppManagedEnvironmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AppManagedEnvironmentPaginator) NextPage(ctx context.Context) ([]AppManagedEnvironment, error) {
	var response AppManagedEnvironmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AppManagedEnvironment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAppManagedEnvironmentFilters = map[string]string{
	"akas":             "description.ManagedEnvironments.ID",
	"id":               "description.ManagedEnvironments.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ManagedEnvironments.Name",
	"tags":             "description.ManagedEnvironments.Tags",
	"title":            "description.ManagedEnvironments.Name",
}

func ListAppManagedEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAppManagedEnvironment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAppManagedEnvironmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAppManagedEnvironmentFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAppManagedEnvironmentFilters = map[string]string{
	"akas":             "description.ManagedEnvironments.ID",
	"id":               "description.ManagedEnvironments.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ManagedEnvironments.Name",
	"tags":             "description.ManagedEnvironments.Tags",
	"title":            "description.ManagedEnvironments.Name",
}

func GetAppManagedEnvironment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAppManagedEnvironment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAppManagedEnvironmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAppManagedEnvironmentFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AppManagedEnvironment =============================

// ==========================  START: WebServerFarms =============================

type WebServerFarms struct {
	Description   azure.WebServerFarmsDescription `json:"description"`
	Metadata      azure.Metadata                  `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type WebServerFarmsHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  WebServerFarms `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type WebServerFarmsHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []WebServerFarmsHit `json:"hits"`
}

type WebServerFarmsSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  WebServerFarmsHits `json:"hits"`
}

type WebServerFarmsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWebServerFarmsPaginator(filters []essdk.BoolFilter, limit *int64) (WebServerFarmsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_web_serverfarms", filters, limit)
	if err != nil {
		return WebServerFarmsPaginator{}, err
	}

	p := WebServerFarmsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WebServerFarmsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WebServerFarmsPaginator) NextPage(ctx context.Context) ([]WebServerFarms, error) {
	var response WebServerFarmsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WebServerFarms
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWebServerFarmsFilters = map[string]string{
	"akas":             "description.ServerFarms.ID",
	"id":               "description.ServerFarms.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ServerFarms.Name",
	"tags":             "description.ServerFarms.Tags",
	"title":            "description.ServerFarms.Name",
}

func ListWebServerFarms(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWebServerFarms")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewWebServerFarmsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listWebServerFarmsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getWebServerFarmsFilters = map[string]string{
	"akas":             "description.ServerFarms.ID",
	"id":               "description.ServerFarms.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ServerFarms.Name",
	"tags":             "description.ServerFarms.Tags",
	"title":            "description.ServerFarms.Name",
}

func GetWebServerFarms(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWebServerFarms")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewWebServerFarmsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getWebServerFarmsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: WebServerFarms =============================

// ==========================  START: Blueprint =============================

type Blueprint struct {
	Description   azure.BlueprintDescription `json:"description"`
	Metadata      azure.Metadata             `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type BlueprintHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Blueprint     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BlueprintHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BlueprintHit    `json:"hits"`
}

type BlueprintSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  BlueprintHits `json:"hits"`
}

type BlueprintPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBlueprintPaginator(filters []essdk.BoolFilter, limit *int64) (BlueprintPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_blueprint_blueprints", filters, limit)
	if err != nil {
		return BlueprintPaginator{}, err
	}

	p := BlueprintPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BlueprintPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BlueprintPaginator) NextPage(ctx context.Context) ([]Blueprint, error) {
	var response BlueprintSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Blueprint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBlueprintFilters = map[string]string{
	"akas":             "description.Blueprints.ID",
	"id":               "description.Blueprints.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Blueprints.Name",
	"tags":             "description.Blueprints.Tags",
	"title":            "description.Blueprints.Name",
}

func ListBlueprint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBlueprint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewBlueprintPaginator(essdk.BuildFilter(d.KeyColumnQuals, listBlueprintFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBlueprintFilters = map[string]string{
	"akas":             "description.Blueprints.ID",
	"id":               "description.Blueprints.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Blueprints.Name",
	"tags":             "description.Blueprints.Tags",
	"title":            "description.Blueprints.Name",
}

func GetBlueprint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBlueprint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewBlueprintPaginator(essdk.BuildFilter(d.KeyColumnQuals, getBlueprintFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Blueprint =============================

// ==========================  START: ComputeDisk =============================

type ComputeDisk struct {
	Description   azure.ComputeDiskDescription `json:"description"`
	Metadata      azure.Metadata               `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type ComputeDiskHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ComputeDisk   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ComputeDiskHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ComputeDiskHit  `json:"hits"`
}

type ComputeDiskSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  ComputeDiskHits `json:"hits"`
}

type ComputeDiskPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeDiskPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeDiskPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_disks", filters, limit)
	if err != nil {
		return ComputeDiskPaginator{}, err
	}

	p := ComputeDiskPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeDiskPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeDiskPaginator) NextPage(ctx context.Context) ([]ComputeDisk, error) {
	var response ComputeDiskSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDisk
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskFilters = map[string]string{
	"akas": "description.Disk.ID",
	"creation_data_gallery_image_reference_id":  "description.Disk.DiskProperties.CreationData.GalleryImageReference.ID",
	"creation_data_gallery_image_reference_lun": "description.Disk.DiskProperties.CreationData.GalleryImageReference.Lun",
	"creation_data_image_reference_id":          "description.Disk.DiskProperties.CreationData.ImageReference.ID",
	"creation_data_image_reference_lun":         "description.Disk.DiskProperties.CreationData.ImageReference.Lun",
	"creation_data_option":                      "description.Disk.DiskProperties.CreationData.CreateOption",
	"creation_data_source_resource_id":          "description.Disk.DiskProperties.CreationData.SourceResourceID",
	"creation_data_source_unique_id":            "description.Disk.DiskProperties.CreationData.SourceUniqueID",
	"creation_data_source_uri":                  "description.Disk.DiskProperties.CreationData.SourceURI",
	"creation_data_storage_account_id":          "description.Disk.DiskProperties.CreationData.StorageAccountID",
	"creation_data_upload_size_bytes":           "description.Disk.DiskProperties.CreationData.UploadSizeBytes",
	"disk_access_id":                            "description.Disk.DiskProperties.DiskAccessID",
	"disk_iops_mbps_read_only":                  "description.Disk.DiskProperties.DiskMBpsReadOnly",
	"disk_iops_mbps_read_write":                 "description.Disk.DiskProperties.DiskMBpsReadWrite",
	"disk_iops_read_only":                       "description.Disk.DiskProperties.DiskIOPSReadOnly",
	"disk_iops_read_write":                      "description.Disk.DiskProperties.DiskIOPSReadWrite",
	"disk_size_bytes":                           "description.Disk.DiskProperties.DiskSizeBytes",
	"disk_size_gb":                              "description.Disk.DiskProperties.DiskSizeGB",
	"disk_state":                                "description.Disk.DiskProperties.DiskState",
	"encryption_disk_encryption_set_id":         "description.Disk.DiskProperties.Encryption.DiskEncryptionSetID",
	"encryption_settings_collection_enabled":    "description.Disk.DiskProperties.EncryptionSettingsCollection.Enabled",
	"encryption_settings_collection_settings":   "description.Disk.DiskProperties.EncryptionSettingsCollection.EncryptionSettings",
	"encryption_settings_collection_version":    "description.Disk.DiskProperties.EncryptionSettingsCollection.EncryptionSettingsVersion",
	"encryption_type":                           "description.Disk.DiskProperties.Encryption.Type",
	"hyper_v_generation":                        "description.Disk.DiskProperties.HyperVGeneration",
	"id":                                        "description.Disk.ID",
	"kaytu_account_id":                          "metadata.SourceID",
	"managed_by":                                "description.Disk.ManagedBy",
	"managed_by_extended":                       "description.Disk.ManagedByExtended",
	"max_shares":                                "description.Disk.DiskProperties.MaxShares",
	"name":                                      "description.Disk.Name",
	"network_access_policy":                     "description.Disk.DiskProperties.NetworkAccessPolicy",
	"os_type":                                   "description.Disk.DiskProperties.OsType",
	"provisioning_state":                        "description.Disk.DiskProperties.ProvisioningState",
	"region":                                    "description.Disk.Location",
	"resource_group":                            "description.ResourceGroup",
	"share_info":                                "description.Disk.DiskProperties.ShareInfo",
	"sku_name":                                  "description.Disk.Sku.Name",
	"sku_tier":                                  "description.Disk.Sku.Tier",
	"tags":                                      "description.Disk.Tags",
	"time_created":                              "description.Disk.DiskProperties.TimeCreated",
	"title":                                     "description.Disk.Name",
	"type":                                      "description.Disk.Type",
	"unique_id":                                 "description.Disk.DiskProperties.UniqueID",
	"zones":                                     "description.Disk.Zones",
}

func ListComputeDisk(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDisk")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeDiskPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeDiskFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeDiskFilters = map[string]string{
	"akas": "description.Disk.ID",
	"creation_data_gallery_image_reference_id":  "description.Disk.DiskProperties.CreationData.GalleryImageReference.ID",
	"creation_data_gallery_image_reference_lun": "description.Disk.DiskProperties.CreationData.GalleryImageReference.Lun",
	"creation_data_image_reference_id":          "description.Disk.DiskProperties.CreationData.ImageReference.ID",
	"creation_data_image_reference_lun":         "description.Disk.DiskProperties.CreationData.ImageReference.Lun",
	"creation_data_option":                      "description.Disk.DiskProperties.CreationData.CreateOption",
	"creation_data_source_resource_id":          "description.Disk.DiskProperties.CreationData.SourceResourceID",
	"creation_data_source_unique_id":            "description.Disk.DiskProperties.CreationData.SourceUniqueID",
	"creation_data_source_uri":                  "description.Disk.DiskProperties.CreationData.SourceURI",
	"creation_data_storage_account_id":          "description.Disk.DiskProperties.CreationData.StorageAccountID",
	"creation_data_upload_size_bytes":           "description.Disk.DiskProperties.CreationData.UploadSizeBytes",
	"disk_access_id":                            "description.Disk.DiskProperties.DiskAccessID",
	"disk_iops_mbps_read_only":                  "description.Disk.DiskProperties.DiskMBpsReadOnly",
	"disk_iops_mbps_read_write":                 "description.Disk.DiskProperties.DiskMBpsReadWrite",
	"disk_iops_read_only":                       "description.Disk.DiskProperties.DiskIOPSReadOnly",
	"disk_iops_read_write":                      "description.Disk.DiskProperties.DiskIOPSReadWrite",
	"disk_size_bytes":                           "description.Disk.DiskProperties.DiskSizeBytes",
	"disk_size_gb":                              "description.Disk.DiskProperties.DiskSizeGB",
	"disk_state":                                "description.Disk.DiskProperties.DiskState",
	"encryption_disk_encryption_set_id":         "description.Disk.DiskProperties.Encryption.DiskEncryptionSetID",
	"encryption_settings_collection_enabled":    "description.Disk.DiskProperties.EncryptionSettingsCollection.Enabled",
	"encryption_settings_collection_settings":   "description.Disk.DiskProperties.EncryptionSettingsCollection.EncryptionSettings",
	"encryption_settings_collection_version":    "description.Disk.DiskProperties.EncryptionSettingsCollection.EncryptionSettingsVersion",
	"encryption_type":                           "description.Disk.DiskProperties.Encryption.Type",
	"hyper_v_generation":                        "description.Disk.DiskProperties.HyperVGeneration",
	"id":                                        "description.Disk.ID",
	"kaytu_account_id":                          "metadata.SourceID",
	"managed_by":                                "description.Disk.ManagedBy",
	"managed_by_extended":                       "description.Disk.ManagedByExtended",
	"max_shares":                                "description.Disk.DiskProperties.MaxShares",
	"name":                                      "description.Disk.name",
	"network_access_policy":                     "description.Disk.DiskProperties.NetworkAccessPolicy",
	"os_type":                                   "description.Disk.DiskProperties.OsType",
	"provisioning_state":                        "description.Disk.DiskProperties.ProvisioningState",
	"region":                                    "description.Disk.Location",
	"resource_group":                            "description.ResourceGroup",
	"share_info":                                "description.Disk.DiskProperties.ShareInfo",
	"sku_name":                                  "description.Disk.Sku.Name",
	"sku_tier":                                  "description.Disk.Sku.Tier",
	"tags":                                      "description.Disk.Tags",
	"time_created":                              "description.Disk.DiskProperties.TimeCreated",
	"title":                                     "description.Disk.Name",
	"type":                                      "description.Disk.Type",
	"unique_id":                                 "description.Disk.DiskProperties.UniqueID",
	"zones":                                     "description.Disk.Zones",
}

func GetComputeDisk(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDisk")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeDiskPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeDiskFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeDisk =============================

// ==========================  START: ComputeDiskReadOps =============================

type ComputeDiskReadOps struct {
	Description   azure.ComputeDiskReadOpsDescription `json:"description"`
	Metadata      azure.Metadata                      `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type ComputeDiskReadOpsHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  ComputeDiskReadOps `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type ComputeDiskReadOpsHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []ComputeDiskReadOpsHit `json:"hits"`
}

type ComputeDiskReadOpsSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  ComputeDiskReadOpsHits `json:"hits"`
}

type ComputeDiskReadOpsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeDiskReadOpsPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeDiskReadOpsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_disksreadops", filters, limit)
	if err != nil {
		return ComputeDiskReadOpsPaginator{}, err
	}

	p := ComputeDiskReadOpsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeDiskReadOpsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeDiskReadOpsPaginator) NextPage(ctx context.Context) ([]ComputeDiskReadOps, error) {
	var response ComputeDiskReadOpsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDiskReadOps
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskReadOpsFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func ListComputeDiskReadOps(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDiskReadOps")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeDiskReadOpsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeDiskReadOpsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeDiskReadOpsFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func GetComputeDiskReadOps(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDiskReadOps")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeDiskReadOpsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeDiskReadOpsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeDiskReadOps =============================

// ==========================  START: ComputeDiskReadOpsDaily =============================

type ComputeDiskReadOpsDaily struct {
	Description   azure.ComputeDiskReadOpsDailyDescription `json:"description"`
	Metadata      azure.Metadata                           `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type ComputeDiskReadOpsDailyHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  ComputeDiskReadOpsDaily `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type ComputeDiskReadOpsDailyHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []ComputeDiskReadOpsDailyHit `json:"hits"`
}

type ComputeDiskReadOpsDailySearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  ComputeDiskReadOpsDailyHits `json:"hits"`
}

type ComputeDiskReadOpsDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeDiskReadOpsDailyPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeDiskReadOpsDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_disksreadopsdaily", filters, limit)
	if err != nil {
		return ComputeDiskReadOpsDailyPaginator{}, err
	}

	p := ComputeDiskReadOpsDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeDiskReadOpsDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeDiskReadOpsDailyPaginator) NextPage(ctx context.Context) ([]ComputeDiskReadOpsDaily, error) {
	var response ComputeDiskReadOpsDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDiskReadOpsDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskReadOpsDailyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func ListComputeDiskReadOpsDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDiskReadOpsDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeDiskReadOpsDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeDiskReadOpsDailyFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeDiskReadOpsDailyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func GetComputeDiskReadOpsDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDiskReadOpsDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeDiskReadOpsDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeDiskReadOpsDailyFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeDiskReadOpsDaily =============================

// ==========================  START: ComputeDiskReadOpsHourly =============================

type ComputeDiskReadOpsHourly struct {
	Description   azure.ComputeDiskReadOpsHourlyDescription `json:"description"`
	Metadata      azure.Metadata                            `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type ComputeDiskReadOpsHourlyHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  ComputeDiskReadOpsHourly `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type ComputeDiskReadOpsHourlyHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []ComputeDiskReadOpsHourlyHit `json:"hits"`
}

type ComputeDiskReadOpsHourlySearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  ComputeDiskReadOpsHourlyHits `json:"hits"`
}

type ComputeDiskReadOpsHourlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeDiskReadOpsHourlyPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeDiskReadOpsHourlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_disksreadopshourly", filters, limit)
	if err != nil {
		return ComputeDiskReadOpsHourlyPaginator{}, err
	}

	p := ComputeDiskReadOpsHourlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeDiskReadOpsHourlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeDiskReadOpsHourlyPaginator) NextPage(ctx context.Context) ([]ComputeDiskReadOpsHourly, error) {
	var response ComputeDiskReadOpsHourlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDiskReadOpsHourly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskReadOpsHourlyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func ListComputeDiskReadOpsHourly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDiskReadOpsHourly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeDiskReadOpsHourlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeDiskReadOpsHourlyFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeDiskReadOpsHourlyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func GetComputeDiskReadOpsHourly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDiskReadOpsHourly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeDiskReadOpsHourlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeDiskReadOpsHourlyFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeDiskReadOpsHourly =============================

// ==========================  START: ComputeDiskWriteOps =============================

type ComputeDiskWriteOps struct {
	Description   azure.ComputeDiskWriteOpsDescription `json:"description"`
	Metadata      azure.Metadata                       `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type ComputeDiskWriteOpsHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ComputeDiskWriteOps `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ComputeDiskWriteOpsHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ComputeDiskWriteOpsHit `json:"hits"`
}

type ComputeDiskWriteOpsSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ComputeDiskWriteOpsHits `json:"hits"`
}

type ComputeDiskWriteOpsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeDiskWriteOpsPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeDiskWriteOpsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_diskswriteops", filters, limit)
	if err != nil {
		return ComputeDiskWriteOpsPaginator{}, err
	}

	p := ComputeDiskWriteOpsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeDiskWriteOpsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeDiskWriteOpsPaginator) NextPage(ctx context.Context) ([]ComputeDiskWriteOps, error) {
	var response ComputeDiskWriteOpsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDiskWriteOps
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskWriteOpsFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func ListComputeDiskWriteOps(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDiskWriteOps")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeDiskWriteOpsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeDiskWriteOpsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeDiskWriteOpsFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func GetComputeDiskWriteOps(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDiskWriteOps")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeDiskWriteOpsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeDiskWriteOpsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeDiskWriteOps =============================

// ==========================  START: ComputeDiskWriteOpsDaily =============================

type ComputeDiskWriteOpsDaily struct {
	Description   azure.ComputeDiskWriteOpsDailyDescription `json:"description"`
	Metadata      azure.Metadata                            `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type ComputeDiskWriteOpsDailyHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  ComputeDiskWriteOpsDaily `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type ComputeDiskWriteOpsDailyHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []ComputeDiskWriteOpsDailyHit `json:"hits"`
}

type ComputeDiskWriteOpsDailySearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  ComputeDiskWriteOpsDailyHits `json:"hits"`
}

type ComputeDiskWriteOpsDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeDiskWriteOpsDailyPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeDiskWriteOpsDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_diskswriteopsdaily", filters, limit)
	if err != nil {
		return ComputeDiskWriteOpsDailyPaginator{}, err
	}

	p := ComputeDiskWriteOpsDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeDiskWriteOpsDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeDiskWriteOpsDailyPaginator) NextPage(ctx context.Context) ([]ComputeDiskWriteOpsDaily, error) {
	var response ComputeDiskWriteOpsDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDiskWriteOpsDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskWriteOpsDailyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func ListComputeDiskWriteOpsDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDiskWriteOpsDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeDiskWriteOpsDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeDiskWriteOpsDailyFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeDiskWriteOpsDailyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func GetComputeDiskWriteOpsDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDiskWriteOpsDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeDiskWriteOpsDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeDiskWriteOpsDailyFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeDiskWriteOpsDaily =============================

// ==========================  START: ComputeDiskWriteOpsHourly =============================

type ComputeDiskWriteOpsHourly struct {
	Description   azure.ComputeDiskWriteOpsHourlyDescription `json:"description"`
	Metadata      azure.Metadata                             `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type ComputeDiskWriteOpsHourlyHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  ComputeDiskWriteOpsHourly `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type ComputeDiskWriteOpsHourlyHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []ComputeDiskWriteOpsHourlyHit `json:"hits"`
}

type ComputeDiskWriteOpsHourlySearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  ComputeDiskWriteOpsHourlyHits `json:"hits"`
}

type ComputeDiskWriteOpsHourlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeDiskWriteOpsHourlyPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeDiskWriteOpsHourlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_diskswriteopshourly", filters, limit)
	if err != nil {
		return ComputeDiskWriteOpsHourlyPaginator{}, err
	}

	p := ComputeDiskWriteOpsHourlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeDiskWriteOpsHourlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeDiskWriteOpsHourlyPaginator) NextPage(ctx context.Context) ([]ComputeDiskWriteOpsHourly, error) {
	var response ComputeDiskWriteOpsHourlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDiskWriteOpsHourly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskWriteOpsHourlyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func ListComputeDiskWriteOpsHourly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDiskWriteOpsHourly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeDiskWriteOpsHourlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeDiskWriteOpsHourlyFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeDiskWriteOpsHourlyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func GetComputeDiskWriteOpsHourly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDiskWriteOpsHourly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeDiskWriteOpsHourlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeDiskWriteOpsHourlyFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeDiskWriteOpsHourly =============================

// ==========================  START: ComputeDiskAccess =============================

type ComputeDiskAccess struct {
	Description   azure.ComputeDiskAccessDescription `json:"description"`
	Metadata      azure.Metadata                     `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type ComputeDiskAccessHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ComputeDiskAccess `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ComputeDiskAccessHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ComputeDiskAccessHit `json:"hits"`
}

type ComputeDiskAccessSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ComputeDiskAccessHits `json:"hits"`
}

type ComputeDiskAccessPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeDiskAccessPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeDiskAccessPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_diskaccesses", filters, limit)
	if err != nil {
		return ComputeDiskAccessPaginator{}, err
	}

	p := ComputeDiskAccessPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeDiskAccessPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeDiskAccessPaginator) NextPage(ctx context.Context) ([]ComputeDiskAccess, error) {
	var response ComputeDiskAccessSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDiskAccess
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskAccessFilters = map[string]string{
	"akas":               "description.DiskAccess.ID",
	"id":                 "description.DiskAccess.ID",
	"kaytu_account_id":   "metadata.SourceID",
	"name":               "description.DiskAccess.Name",
	"provisioning_state": "description.DiskAccess.DiskAccessProperties.ProvisioningState",
	"region":             "description.DiskAccess.Location",
	"resource_group":     "description.ResourceGroup",
	"tags":               "description.DiskAccess.Tags",
	"time_created":       "description.DiskAccess.DiskAccessProperties.TimeCreated",
	"title":              "description.DiskAccess.Name",
	"type":               "description.DiskAccess.Type",
}

func ListComputeDiskAccess(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDiskAccess")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeDiskAccessPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeDiskAccessFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeDiskAccessFilters = map[string]string{
	"akas":               "description.DiskAccess.ID",
	"id":                 "description.DiskAccess.ID",
	"kaytu_account_id":   "metadata.SourceID",
	"name":               "description.DiskAccess.name",
	"provisioning_state": "description.DiskAccess.DiskAccessProperties.ProvisioningState",
	"region":             "description.DiskAccess.Location",
	"resource_group":     "description.ResourceGroup",
	"tags":               "description.DiskAccess.Tags",
	"time_created":       "description.DiskAccess.DiskAccessProperties.TimeCreated",
	"title":              "description.DiskAccess.Name",
	"type":               "description.DiskAccess.Type",
}

func GetComputeDiskAccess(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDiskAccess")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeDiskAccessPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeDiskAccessFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeDiskAccess =============================

// ==========================  START: ComputeVirtualMachineScaleSet =============================

type ComputeVirtualMachineScaleSet struct {
	Description   azure.ComputeVirtualMachineScaleSetDescription `json:"description"`
	Metadata      azure.Metadata                                 `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type ComputeVirtualMachineScaleSetHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  ComputeVirtualMachineScaleSet `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type ComputeVirtualMachineScaleSetHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []ComputeVirtualMachineScaleSetHit `json:"hits"`
}

type ComputeVirtualMachineScaleSetSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  ComputeVirtualMachineScaleSetHits `json:"hits"`
}

type ComputeVirtualMachineScaleSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeVirtualMachineScaleSetPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeVirtualMachineScaleSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_virtualmachinescalesets", filters, limit)
	if err != nil {
		return ComputeVirtualMachineScaleSetPaginator{}, err
	}

	p := ComputeVirtualMachineScaleSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeVirtualMachineScaleSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeVirtualMachineScaleSetPaginator) NextPage(ctx context.Context) ([]ComputeVirtualMachineScaleSet, error) {
	var response ComputeVirtualMachineScaleSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeVirtualMachineScaleSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeVirtualMachineScaleSetFilters = map[string]string{
	"akas": "description.VirtualMachineScaleSet.ID",
	"do_not_run_extensions_on_overprovisioned_vms": "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.DoNotRunExtensionsOnOverprovisionedVMs",
	"extensions":                          "description.VirtualMachineScaleSetExtensions",
	"id":                                  "description.VirtualMachineScaleSet.ID",
	"identity":                            "description.VirtualMachineScaleSet.Identity",
	"kaytu_account_id":                    "metadata.SourceID",
	"location":                            "description.VirtualMachineScaleSet.Location",
	"name":                                "description.VirtualMachineScaleSet.Name",
	"overprovision":                       "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.Overprovision",
	"plan":                                "description.VirtualMachineScaleSet.Plan",
	"platform_fault_domain_count":         "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.PlatformFaultDomainCount",
	"provisioning_state":                  "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.ProvisioningState",
	"region":                              "description.VirtualMachineScaleSet.Location",
	"resource_group":                      "description.ResourceGroup",
	"scale_in_policy":                     "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.ScaleInPolicy",
	"single_placement_group":              "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.SinglePlacementGroup",
	"sku_capacity":                        "description.VirtualMachineScaleSet.Sku.Capacity",
	"sku_name":                            "description.VirtualMachineScaleSet.Sku.Name",
	"sku_tier":                            "description.VirtualMachineScaleSet.Sku.Tier",
	"tags":                                "description.VirtualMachineScaleSet.Tags",
	"tags_src":                            "description.VirtualMachineScaleSet.Tags",
	"title":                               "description.VirtualMachineScaleSet.Name",
	"type":                                "description.VirtualMachineScaleSet.Type",
	"unique_id":                           "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.UniqueID",
	"upgrade_policy":                      "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.UpgradePolicy",
	"virtual_machine_diagnostics_profile": "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.VirtualMachineProfile.DiagnosticsProfile",
	"virtual_machine_extension_profile":   "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.VirtualMachineProfile.ExtensionProfile",
	"virtual_machine_network_profile":     "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.VirtualMachineProfile.NetworkProfile",
	"virtual_machine_os_profile":          "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.VirtualMachineProfile.OsProfile",
	"virtual_machine_security_profile":    "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.VirtualMachineProfile.SecurityProfile",
	"virtual_machine_storage_profile":     "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.VirtualMachineProfile.StorageProfile",
	"zones":                               "description.VirtualMachineScaleSet.Zones",
}

func ListComputeVirtualMachineScaleSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeVirtualMachineScaleSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeVirtualMachineScaleSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeVirtualMachineScaleSetFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeVirtualMachineScaleSetFilters = map[string]string{
	"akas": "description.VirtualMachineScaleSet.ID",
	"do_not_run_extensions_on_overprovisioned_vms": "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.DoNotRunExtensionsOnOverprovisionedVMs",
	"extensions":                          "description.VirtualMachineScaleSetExtensions",
	"id":                                  "description.VirtualMachineScaleSet.ID",
	"identity":                            "description.VirtualMachineScaleSet.Identity",
	"kaytu_account_id":                    "metadata.SourceID",
	"location":                            "description.VirtualMachineScaleSet.Location",
	"name":                                "description.VirtualMachineScaleSet.name",
	"overprovision":                       "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.Overprovision",
	"plan":                                "description.VirtualMachineScaleSet.Plan",
	"platform_fault_domain_count":         "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.PlatformFaultDomainCount",
	"provisioning_state":                  "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.ProvisioningState",
	"region":                              "description.VirtualMachineScaleSet.Location",
	"resource_group":                      "description.ResourceGroup",
	"scale_in_policy":                     "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.ScaleInPolicy",
	"single_placement_group":              "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.SinglePlacementGroup",
	"sku_capacity":                        "description.VirtualMachineScaleSet.Sku.Capacity",
	"sku_name":                            "description.VirtualMachineScaleSet.Sku.Name",
	"sku_tier":                            "description.VirtualMachineScaleSet.Sku.Tier",
	"tags":                                "description.VirtualMachineScaleSet.Tags",
	"tags_src":                            "description.VirtualMachineScaleSet.Tags",
	"title":                               "description.VirtualMachineScaleSet.Name",
	"type":                                "description.VirtualMachineScaleSet.Type",
	"unique_id":                           "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.UniqueID",
	"upgrade_policy":                      "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.UpgradePolicy",
	"virtual_machine_diagnostics_profile": "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.VirtualMachineProfile.DiagnosticsProfile",
	"virtual_machine_extension_profile":   "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.VirtualMachineProfile.ExtensionProfile",
	"virtual_machine_network_profile":     "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.VirtualMachineProfile.NetworkProfile",
	"virtual_machine_os_profile":          "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.VirtualMachineProfile.OsProfile",
	"virtual_machine_security_profile":    "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.VirtualMachineProfile.SecurityProfile",
	"virtual_machine_storage_profile":     "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.VirtualMachineProfile.StorageProfile",
	"zones":                               "description.VirtualMachineScaleSet.Zones",
}

func GetComputeVirtualMachineScaleSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeVirtualMachineScaleSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeVirtualMachineScaleSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeVirtualMachineScaleSetFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeVirtualMachineScaleSet =============================

// ==========================  START: ComputeVirtualMachineScaleSetNetworkInterface =============================

type ComputeVirtualMachineScaleSetNetworkInterface struct {
	Description   azure.ComputeVirtualMachineScaleSetNetworkInterfaceDescription `json:"description"`
	Metadata      azure.Metadata                                                 `json:"metadata"`
	ResourceJobID int                                                            `json:"resource_job_id"`
	SourceJobID   int                                                            `json:"source_job_id"`
	ResourceType  string                                                         `json:"resource_type"`
	SourceType    string                                                         `json:"source_type"`
	ID            string                                                         `json:"id"`
	ARN           string                                                         `json:"arn"`
	SourceID      string                                                         `json:"source_id"`
}

type ComputeVirtualMachineScaleSetNetworkInterfaceHit struct {
	ID      string                                        `json:"_id"`
	Score   float64                                       `json:"_score"`
	Index   string                                        `json:"_index"`
	Type    string                                        `json:"_type"`
	Version int64                                         `json:"_version,omitempty"`
	Source  ComputeVirtualMachineScaleSetNetworkInterface `json:"_source"`
	Sort    []interface{}                                 `json:"sort"`
}

type ComputeVirtualMachineScaleSetNetworkInterfaceHits struct {
	Total essdk.SearchTotal                                  `json:"total"`
	Hits  []ComputeVirtualMachineScaleSetNetworkInterfaceHit `json:"hits"`
}

type ComputeVirtualMachineScaleSetNetworkInterfaceSearchResponse struct {
	PitID string                                            `json:"pit_id"`
	Hits  ComputeVirtualMachineScaleSetNetworkInterfaceHits `json:"hits"`
}

type ComputeVirtualMachineScaleSetNetworkInterfacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeVirtualMachineScaleSetNetworkInterfacePaginator(filters []essdk.BoolFilter, limit *int64) (ComputeVirtualMachineScaleSetNetworkInterfacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_virtualmachinescalesets_networkinterfaces", filters, limit)
	if err != nil {
		return ComputeVirtualMachineScaleSetNetworkInterfacePaginator{}, err
	}

	p := ComputeVirtualMachineScaleSetNetworkInterfacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeVirtualMachineScaleSetNetworkInterfacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeVirtualMachineScaleSetNetworkInterfacePaginator) NextPage(ctx context.Context) ([]ComputeVirtualMachineScaleSetNetworkInterface, error) {
	var response ComputeVirtualMachineScaleSetNetworkInterfaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeVirtualMachineScaleSetNetworkInterface
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeVirtualMachineScaleSetNetworkInterfaceFilters = map[string]string{
	"akas":             "description.NetworkInterface.ID",
	"id":               "description.NetworkInterface.ID",
	"kaytu_account_id": "metadata.SourceID",
	"mac_address":      "description.NetworkInterface.Location",
	"name":             "description.NetworkInterface.Name",
	"region":           "description.NetworkInterface.Location",
	"resource_group":   "description.ResourceGroup",
	"scale_set_name":   "description.VirtualMachineScaleSet.Name",
	"tags":             "description.NetworkInterface.Tags",
	"title":            "description.NetworkInterface.Name",
	"type":             "description.NetworkInterface.Type",
}

func ListComputeVirtualMachineScaleSetNetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeVirtualMachineScaleSetNetworkInterface")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeVirtualMachineScaleSetNetworkInterfacePaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeVirtualMachineScaleSetNetworkInterfaceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeVirtualMachineScaleSetNetworkInterfaceFilters = map[string]string{
	"akas":             "description.NetworkInterface.ID",
	"id":               "description.NetworkInterface.ID",
	"kaytu_account_id": "metadata.SourceID",
	"mac_address":      "description.NetworkInterface.Location",
	"name":             "description.NetworkInterface.Name",
	"region":           "description.NetworkInterface.Location",
	"resource_group":   "description.ResourceGroup",
	"scale_set_name":   "description.VirtualMachineScaleSet.Name",
	"tags":             "description.NetworkInterface.Tags",
	"title":            "description.NetworkInterface.Name",
	"type":             "description.NetworkInterface.Type",
}

func GetComputeVirtualMachineScaleSetNetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeVirtualMachineScaleSetNetworkInterface")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeVirtualMachineScaleSetNetworkInterfacePaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeVirtualMachineScaleSetNetworkInterfaceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeVirtualMachineScaleSetNetworkInterface =============================

// ==========================  START: ComputeVirtualMachineScaleSetVm =============================

type ComputeVirtualMachineScaleSetVm struct {
	Description   azure.ComputeVirtualMachineScaleSetVmDescription `json:"description"`
	Metadata      azure.Metadata                                   `json:"metadata"`
	ResourceJobID int                                              `json:"resource_job_id"`
	SourceJobID   int                                              `json:"source_job_id"`
	ResourceType  string                                           `json:"resource_type"`
	SourceType    string                                           `json:"source_type"`
	ID            string                                           `json:"id"`
	ARN           string                                           `json:"arn"`
	SourceID      string                                           `json:"source_id"`
}

type ComputeVirtualMachineScaleSetVmHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  ComputeVirtualMachineScaleSetVm `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type ComputeVirtualMachineScaleSetVmHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []ComputeVirtualMachineScaleSetVmHit `json:"hits"`
}

type ComputeVirtualMachineScaleSetVmSearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  ComputeVirtualMachineScaleSetVmHits `json:"hits"`
}

type ComputeVirtualMachineScaleSetVmPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeVirtualMachineScaleSetVmPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeVirtualMachineScaleSetVmPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_virtualmachinescalesets_virtualmachines", filters, limit)
	if err != nil {
		return ComputeVirtualMachineScaleSetVmPaginator{}, err
	}

	p := ComputeVirtualMachineScaleSetVmPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeVirtualMachineScaleSetVmPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeVirtualMachineScaleSetVmPaginator) NextPage(ctx context.Context) ([]ComputeVirtualMachineScaleSetVm, error) {
	var response ComputeVirtualMachineScaleSetVmSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeVirtualMachineScaleSetVm
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeVirtualMachineScaleSetVmFilters = map[string]string{
	"additional_capabilities":             "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.AdditionalCapabilities",
	"akas":                                "description.ScaleSetVM.ID",
	"availability_set":                    "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.AvailabilitySet",
	"id":                                  "description.NetworkInterface.ID",
	"instance_id":                         "description.ScaleSetVM.InstanceID",
	"kaytu_account_id":                    "metadata.SourceID",
	"latest_model_applied":                "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.LatestModelApplied",
	"license_type":                        "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.LicenseType",
	"location":                            "description.ScaleSetVM.Location",
	"model_definition_applied":            "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.ModelDefinitionApplied",
	"name":                                "description.ScaleSetVM.Name",
	"plan":                                "description.ScaleSetVM.Plan",
	"protection_policy":                   "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.ProtectionPolicy",
	"provisioning_state":                  "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.ProvisioningState",
	"region":                              "description.ScaleSetVM.Location",
	"resource_group":                      "description.ResourceGroup",
	"resources":                           "description.ScaleSetVM.Resources",
	"scale_set_name":                      "description.ScaleSetVM.Name",
	"sku_capacity":                        "description.ScaleSetVM.Sku.Capacity",
	"sku_name":                            "description.ScaleSetVM.Sku.Name",
	"sku_tier":                            "description.ScaleSetVM.Sku.Tier",
	"tags":                                "description.ScaleSetVM.Tags",
	"tags_src":                            "description.ScaleSetVM.Tags",
	"title":                               "description.ScaleSetVM.Name",
	"type":                                "description.ScaleSetVM.Type",
	"upgrade_policy":                      "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.UpgradePolicy",
	"virtual_machine_diagnostics_profile": "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.DiagnosticsProfile",
	"virtual_machine_hardware_profile":    "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.HardwareProfile",
	"virtual_machine_network_profile":     "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.NetworkProfile.NetworkInterfaces",
	"virtual_machine_network_profile_configuration": "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.NetworkProfileConfiguration",
	"virtual_machine_os_profile":                    "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.OsProfile",
	"virtual_machine_security_profile":              "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.SecurityProfile",
	"virtual_machine_storage_profile":               "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.StorageProfile",
	"vm_id":                                         "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.VMID",
	"zones":                                         "description.ScaleSetVM.Zones",
}

func ListComputeVirtualMachineScaleSetVm(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeVirtualMachineScaleSetVm")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeVirtualMachineScaleSetVmPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeVirtualMachineScaleSetVmFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeVirtualMachineScaleSetVmFilters = map[string]string{
	"additional_capabilities":             "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.AdditionalCapabilities",
	"akas":                                "description.ScaleSetVM.ID",
	"availability_set":                    "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.AvailabilitySet",
	"id":                                  "description.NetworkInterface.ID",
	"instance_id":                         "description.ScaleSetVM.InstanceID",
	"kaytu_account_id":                    "metadata.SourceID",
	"latest_model_applied":                "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.LatestModelApplied",
	"license_type":                        "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.LicenseType",
	"location":                            "description.ScaleSetVM.Location",
	"model_definition_applied":            "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.ModelDefinitionApplied",
	"name":                                "description.ScaleSetVM.Name",
	"plan":                                "description.ScaleSetVM.Plan",
	"protection_policy":                   "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.ProtectionPolicy",
	"provisioning_state":                  "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.ProvisioningState",
	"region":                              "description.ScaleSetVM.Location",
	"resource_group":                      "description.ResourceGroup",
	"resources":                           "description.ScaleSetVM.Resources",
	"scale_set_name":                      "description.VirtualMachineScaleSet.name",
	"sku_capacity":                        "description.ScaleSetVM.Sku.Capacity",
	"sku_name":                            "description.ScaleSetVM.Sku.Name",
	"sku_tier":                            "description.ScaleSetVM.Sku.Tier",
	"tags":                                "description.ScaleSetVM.Tags",
	"tags_src":                            "description.ScaleSetVM.Tags",
	"title":                               "description.ScaleSetVM.Name",
	"type":                                "description.ScaleSetVM.Type",
	"upgrade_policy":                      "description.VirtualMachineScaleSet.VirtualMachineScaleSetProperties.UpgradePolicy",
	"virtual_machine_diagnostics_profile": "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.DiagnosticsProfile",
	"virtual_machine_hardware_profile":    "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.HardwareProfile",
	"virtual_machine_network_profile":     "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.NetworkProfile.NetworkInterfaces",
	"virtual_machine_network_profile_configuration": "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.NetworkProfileConfiguration",
	"virtual_machine_os_profile":                    "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.OsProfile",
	"virtual_machine_security_profile":              "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.SecurityProfile",
	"virtual_machine_storage_profile":               "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.StorageProfile",
	"vm_id":                                         "description.ScaleSetVM.VirtualMachineScaleSetVMProperties.VMID",
	"zones":                                         "description.ScaleSetVM.Zones",
}

func GetComputeVirtualMachineScaleSetVm(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeVirtualMachineScaleSetVm")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeVirtualMachineScaleSetVmPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeVirtualMachineScaleSetVmFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeVirtualMachineScaleSetVm =============================

// ==========================  START: ComputeSnapshots =============================

type ComputeSnapshots struct {
	Description   azure.ComputeSnapshotsDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type ComputeSnapshotsHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  ComputeSnapshots `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type ComputeSnapshotsHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []ComputeSnapshotsHit `json:"hits"`
}

type ComputeSnapshotsSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  ComputeSnapshotsHits `json:"hits"`
}

type ComputeSnapshotsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeSnapshotsPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeSnapshotsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_snapshots", filters, limit)
	if err != nil {
		return ComputeSnapshotsPaginator{}, err
	}

	p := ComputeSnapshotsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeSnapshotsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeSnapshotsPaginator) NextPage(ctx context.Context) ([]ComputeSnapshots, error) {
	var response ComputeSnapshotsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeSnapshots
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeSnapshotsFilters = map[string]string{
	"akas":                                  "description.Snapshot.ID",
	"create_option":                         "description.Snapshot.SnapshotProperties.CreationData.CreateOption",
	"disk_access_id":                        "description.Snapshot.SnapshotProperties.DiskAccessID",
	"disk_encryption_set_id":                "description.Snapshot.SnapshotProperties.Encryption.DiskEncryptionSetID",
	"disk_size_bytes":                       "description.Snapshot.SnapshotProperties.DiskSizeBytes",
	"disk_size_gb":                          "description.Snapshot.SnapshotProperties.DiskSizeGB",
	"encryption_setting_collection_enabled": "description.Snapshot.SnapshotProperties.EncryptionSettingsCollection.Enabled",
	"encryption_setting_version":            "description.Snapshot.SnapshotProperties.EncryptionSettingsCollection.EncryptionSettingsVersion",
	"encryption_settings":                   "description.Snapshot.SnapshotProperties.EncryptionSettingsCollection.EncryptionSettings",
	"encryption_type":                       "description.Snapshot.SnapshotProperties.Encryption.Type",
	"gallery_image_reference_id":            "description.Snapshot.SnapshotProperties.CreationData.GalleryImageReference.ID",
	"gallery_reference_lun":                 "description.Snapshot.SnapshotProperties.CreationData.GalleryImageReference.Lun",
	"hyperv_generation":                     "description.Snapshot.SnapshotProperties.HyperVGeneration",
	"image_reference_id":                    "description.Snapshot.SnapshotProperties.CreationData.ImageReference.ID",
	"image_reference_lun":                   "description.Snapshot.SnapshotProperties.CreationData.ImageReference.Lun",
	"incremental":                           "description.Snapshot.SnapshotProperties.Incremental",
	"kaytu_account_id":                      "metadata.SourceID",
	"name":                                  "description.Snapshot.Name",
	"network_access_policy":                 "description.Snapshot.SnapshotProperties.NetworkAccessPolicy",
	"os_type":                               "description.Snapshot.SnapshotProperties.OsType",
	"provisioning_state":                    "description.Snapshot.SnapshotProperties.ProvisioningState",
	"region":                                "description.Snapshot.Location",
	"resource_group":                        "description.ResourceGroup",
	"sku_name":                              "description.Snapshot.Sku.Name",
	"sku_tier":                              "description.Snapshot.Sku.Tier",
	"source_resource_id":                    "description.Snapshot.SnapshotProperties.CreationData.SourceResourceID",
	"source_unique_id":                      "description.Snapshot.SnapshotProperties.CreationData.SourceUniqueID",
	"source_uri":                            "description.Snapshot.SnapshotProperties.CreationData.SourceURI",
	"storage_account_id":                    "description.Snapshot.SnapshotProperties.CreationData.StorageAccountID",
	"tags":                                  "description.Snapshot.Tags",
	"time_created":                          "description.Snapshot.SnapshotProperties.TimeCreated",
	"title":                                 "description.Snapshot.Name",
	"type":                                  "description.Snapshot.Type",
	"unique_id":                             "description.Snapshot.SnapshotProperties.UniqueID",
	"upload_size_bytes":                     "description.Snapshot.SnapshotProperties.CreationData.UploadSizeBytes",
}

func ListComputeSnapshots(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeSnapshots")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeSnapshotsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeSnapshotsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeSnapshotsFilters = map[string]string{
	"akas":                                  "description.Snapshot.ID",
	"create_option":                         "description.Snapshot.SnapshotProperties.CreationData.CreateOption",
	"disk_access_id":                        "description.Snapshot.SnapshotProperties.DiskAccessID",
	"disk_encryption_set_id":                "description.Snapshot.SnapshotProperties.Encryption.DiskEncryptionSetID",
	"disk_size_bytes":                       "description.Snapshot.SnapshotProperties.DiskSizeBytes",
	"disk_size_gb":                          "description.Snapshot.SnapshotProperties.DiskSizeGB",
	"encryption_setting_collection_enabled": "description.Snapshot.SnapshotProperties.EncryptionSettingsCollection.Enabled",
	"encryption_setting_version":            "description.Snapshot.SnapshotProperties.EncryptionSettingsCollection.EncryptionSettingsVersion",
	"encryption_settings":                   "description.Snapshot.SnapshotProperties.EncryptionSettingsCollection.EncryptionSettings",
	"encryption_type":                       "description.Snapshot.SnapshotProperties.Encryption.Type",
	"gallery_image_reference_id":            "description.Snapshot.SnapshotProperties.CreationData.GalleryImageReference.ID",
	"gallery_reference_lun":                 "description.Snapshot.SnapshotProperties.CreationData.GalleryImageReference.Lun",
	"hyperv_generation":                     "description.Snapshot.SnapshotProperties.HyperVGeneration",
	"image_reference_id":                    "description.Snapshot.SnapshotProperties.CreationData.ImageReference.ID",
	"image_reference_lun":                   "description.Snapshot.SnapshotProperties.CreationData.ImageReference.Lun",
	"incremental":                           "description.Snapshot.SnapshotProperties.Incremental",
	"kaytu_account_id":                      "metadata.SourceID",
	"name":                                  "description.Snapshot.Name",
	"network_access_policy":                 "description.Snapshot.SnapshotProperties.NetworkAccessPolicy",
	"os_type":                               "description.Snapshot.SnapshotProperties.OsType",
	"provisioning_state":                    "description.Snapshot.SnapshotProperties.ProvisioningState",
	"region":                                "description.Snapshot.Location",
	"resource_group":                        "description.ResourceGroup",
	"sku_name":                              "description.Snapshot.Sku.Name",
	"sku_tier":                              "description.Snapshot.Sku.Tier",
	"source_resource_id":                    "description.Snapshot.SnapshotProperties.CreationData.SourceResourceID",
	"source_unique_id":                      "description.Snapshot.SnapshotProperties.CreationData.SourceUniqueID",
	"source_uri":                            "description.Snapshot.SnapshotProperties.CreationData.SourceURI",
	"storage_account_id":                    "description.Snapshot.SnapshotProperties.CreationData.StorageAccountID",
	"tags":                                  "description.Snapshot.Tags",
	"time_created":                          "description.Snapshot.SnapshotProperties.TimeCreated",
	"title":                                 "description.Snapshot.Name",
	"type":                                  "description.Snapshot.Type",
	"unique_id":                             "description.Snapshot.SnapshotProperties.UniqueID",
	"upload_size_bytes":                     "description.Snapshot.SnapshotProperties.CreationData.UploadSizeBytes",
}

func GetComputeSnapshots(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeSnapshots")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeSnapshotsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeSnapshotsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeSnapshots =============================

// ==========================  START: ComputeAvailabilitySet =============================

type ComputeAvailabilitySet struct {
	Description   azure.ComputeAvailabilitySetDescription `json:"description"`
	Metadata      azure.Metadata                          `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type ComputeAvailabilitySetHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  ComputeAvailabilitySet `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type ComputeAvailabilitySetHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []ComputeAvailabilitySetHit `json:"hits"`
}

type ComputeAvailabilitySetSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  ComputeAvailabilitySetHits `json:"hits"`
}

type ComputeAvailabilitySetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeAvailabilitySetPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeAvailabilitySetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_availabilitysets", filters, limit)
	if err != nil {
		return ComputeAvailabilitySetPaginator{}, err
	}

	p := ComputeAvailabilitySetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeAvailabilitySetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeAvailabilitySetPaginator) NextPage(ctx context.Context) ([]ComputeAvailabilitySet, error) {
	var response ComputeAvailabilitySetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeAvailabilitySet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeAvailabilitySetFilters = map[string]string{
	"akas":                         "description.AvailabilitySet.ID",
	"kaytu_account_id":             "metadata.SourceID",
	"name":                         "description.AvailabilitySet.Name",
	"platform_fault_domain_count":  "description.AvailabilitySet.AvailabilitySetProperties.PlatformFaultDomainCount",
	"platform_update_domain_count": "description.AvailabilitySet.AvailabilitySetProperties.PlatformUpdateDomainCount",
	"proximity_placement_group_id": "description.AvailabilitySet.AvailabilitySetProperties.ProximityPlacementGroup.ID",
	"region":                       "description.AvailabilitySet.Location",
	"resource_group":               "description.ResourceGroup",
	"sku_capacity":                 "description.AvailabilitySet.Sku.Capacity",
	"sku_name":                     "description.AvailabilitySet.Sku.Name",
	"sku_tier":                     "description.AvailabilitySet.Sku.Tier",
	"status":                       "description.AvailabilitySet.AvailabilitySetProperties.Statuses",
	"tags":                         "description.AvailabilitySet.Tags",
	"title":                        "description.AvailabilitySet.Name",
	"type":                         "description.AvailabilitySet.Type",
	"virtual_machines":             "description.AvailabilitySet.AvailabilitySetProperties.VirtualMachines",
}

func ListComputeAvailabilitySet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeAvailabilitySet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeAvailabilitySetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeAvailabilitySetFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeAvailabilitySetFilters = map[string]string{
	"akas":                         "description.AvailabilitySet.ID",
	"kaytu_account_id":             "metadata.SourceID",
	"name":                         "description.AvailabilitySet.Name",
	"platform_fault_domain_count":  "description.AvailabilitySet.AvailabilitySetProperties.PlatformFaultDomainCount",
	"platform_update_domain_count": "description.AvailabilitySet.AvailabilitySetProperties.PlatformUpdateDomainCount",
	"proximity_placement_group_id": "description.AvailabilitySet.AvailabilitySetProperties.ProximityPlacementGroup.ID",
	"region":                       "description.AvailabilitySet.Location",
	"resource_group":               "description.ResourceGroup",
	"sku_capacity":                 "description.AvailabilitySet.Sku.Capacity",
	"sku_name":                     "description.AvailabilitySet.Sku.Name",
	"sku_tier":                     "description.AvailabilitySet.Sku.Tier",
	"status":                       "description.AvailabilitySet.AvailabilitySetProperties.Statuses",
	"tags":                         "description.AvailabilitySet.Tags",
	"title":                        "description.AvailabilitySet.Name",
	"type":                         "description.AvailabilitySet.Type",
	"virtual_machines":             "description.AvailabilitySet.AvailabilitySetProperties.VirtualMachines",
}

func GetComputeAvailabilitySet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeAvailabilitySet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeAvailabilitySetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeAvailabilitySetFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeAvailabilitySet =============================

// ==========================  START: ComputeDiskEncryptionSet =============================

type ComputeDiskEncryptionSet struct {
	Description   azure.ComputeDiskEncryptionSetDescription `json:"description"`
	Metadata      azure.Metadata                            `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type ComputeDiskEncryptionSetHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  ComputeDiskEncryptionSet `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type ComputeDiskEncryptionSetHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []ComputeDiskEncryptionSetHit `json:"hits"`
}

type ComputeDiskEncryptionSetSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  ComputeDiskEncryptionSetHits `json:"hits"`
}

type ComputeDiskEncryptionSetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeDiskEncryptionSetPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeDiskEncryptionSetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_diskencryptionsets", filters, limit)
	if err != nil {
		return ComputeDiskEncryptionSetPaginator{}, err
	}

	p := ComputeDiskEncryptionSetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeDiskEncryptionSetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeDiskEncryptionSetPaginator) NextPage(ctx context.Context) ([]ComputeDiskEncryptionSet, error) {
	var response ComputeDiskEncryptionSetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeDiskEncryptionSet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeDiskEncryptionSetFilters = map[string]string{
	"active_key_source_vault_id": "description.DiskEncryptionSet.EncryptionSetProperties.ActiveKey.SourceVault.ID",
	"active_key_url":             "description.DiskEncryptionSet.EncryptionSetProperties.ActiveKey.KeyURL",
	"akas":                       "description.DiskEncryptionSet.ID",
	"encryption_type":            "description.DiskEncryptionSet.EncryptionSetProperties.EncryptionType",
	"identity_principal_id":      "description.DiskEncryptionSet.Identity.PrincipalID",
	"identity_tenant_id":         "description.DiskEncryptionSet.Identity.TenantID",
	"identity_type":              "description.DiskEncryptionSet.Identity.Type",
	"kaytu_account_id":           "metadata.SourceID",
	"name":                       "description.DiskEncryptionSet.Name",
	"previous_keys":              "description.DiskEncryptionSet.EncryptionSetProperties.PreviousKeys",
	"provisioning_state":         "description.DiskEncryptionSet.EncryptionSetProperties.ProvisioningState",
	"region":                     "description.DiskEncryptionSet.Location",
	"resource_group":             "description.ResourceGroup",
	"tags":                       "description.DiskEncryptionSet.Tags",
	"title":                      "description.DiskEncryptionSet.Name",
	"type":                       "description.DiskEncryptionSet.Type",
}

func ListComputeDiskEncryptionSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeDiskEncryptionSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeDiskEncryptionSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeDiskEncryptionSetFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeDiskEncryptionSetFilters = map[string]string{
	"active_key_source_vault_id": "description.DiskEncryptionSet.EncryptionSetProperties.ActiveKey.SourceVault.ID",
	"active_key_url":             "description.DiskEncryptionSet.EncryptionSetProperties.ActiveKey.KeyURL",
	"akas":                       "description.DiskEncryptionSet.ID",
	"encryption_type":            "description.DiskEncryptionSet.EncryptionSetProperties.EncryptionType",
	"identity_principal_id":      "description.DiskEncryptionSet.Identity.PrincipalID",
	"identity_tenant_id":         "description.DiskEncryptionSet.Identity.TenantID",
	"identity_type":              "description.DiskEncryptionSet.Identity.Type",
	"kaytu_account_id":           "metadata.SourceID",
	"name":                       "description.DiskEncryptionSet.Name",
	"previous_keys":              "description.DiskEncryptionSet.EncryptionSetProperties.PreviousKeys",
	"provisioning_state":         "description.DiskEncryptionSet.EncryptionSetProperties.ProvisioningState",
	"region":                     "description.DiskEncryptionSet.Location",
	"resource_group":             "description.ResourceGroup",
	"tags":                       "description.DiskEncryptionSet.Tags",
	"title":                      "description.DiskEncryptionSet.Name",
	"type":                       "description.DiskEncryptionSet.Type",
}

func GetComputeDiskEncryptionSet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeDiskEncryptionSet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeDiskEncryptionSetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeDiskEncryptionSetFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeDiskEncryptionSet =============================

// ==========================  START: ComputeImageGallery =============================

type ComputeImageGallery struct {
	Description   azure.ComputeImageGalleryDescription `json:"description"`
	Metadata      azure.Metadata                       `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type ComputeImageGalleryHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ComputeImageGallery `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ComputeImageGalleryHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ComputeImageGalleryHit `json:"hits"`
}

type ComputeImageGallerySearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ComputeImageGalleryHits `json:"hits"`
}

type ComputeImageGalleryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeImageGalleryPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeImageGalleryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_galleries", filters, limit)
	if err != nil {
		return ComputeImageGalleryPaginator{}, err
	}

	p := ComputeImageGalleryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeImageGalleryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeImageGalleryPaginator) NextPage(ctx context.Context) ([]ComputeImageGallery, error) {
	var response ComputeImageGallerySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeImageGallery
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeImageGalleryFilters = map[string]string{
	"akas":             "description.ImageGallery.ID",
	"id":               "description.ImageGallery.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ImageGallery.Name",
	"tags":             "description.ImageGallery.Tags",
	"title":            "description.ImageGallery.Name",
}

func ListComputeImageGallery(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeImageGallery")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeImageGalleryPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeImageGalleryFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeImageGalleryFilters = map[string]string{
	"akas":             "description.ImageGallery.ID",
	"id":               "description.ImageGallery.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ImageGallery.Name",
	"resource_group":   "description.ResourceGroup",
	"tags":             "description.ImageGallery.Tags",
	"title":            "description.ImageGallery.Name",
}

func GetComputeImageGallery(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeImageGallery")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeImageGalleryPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeImageGalleryFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeImageGallery =============================

// ==========================  START: ComputeImage =============================

type ComputeImage struct {
	Description   azure.ComputeImageDescription `json:"description"`
	Metadata      azure.Metadata                `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type ComputeImageHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ComputeImage  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ComputeImageHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ComputeImageHit `json:"hits"`
}

type ComputeImageSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  ComputeImageHits `json:"hits"`
}

type ComputeImagePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeImagePaginator(filters []essdk.BoolFilter, limit *int64) (ComputeImagePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_images", filters, limit)
	if err != nil {
		return ComputeImagePaginator{}, err
	}

	p := ComputeImagePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeImagePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeImagePaginator) NextPage(ctx context.Context) ([]ComputeImage, error) {
	var response ComputeImageSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeImage
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeImageFilters = map[string]string{
	"akas":                                   "description.Image.ID",
	"hyper_v_generation":                     "description.Image.ImageProperties.HyperVGeneration",
	"id":                                     "description.Image.ID",
	"kaytu_account_id":                       "metadata.SourceID",
	"name":                                   "description.Image.Name",
	"provisioning_state":                     "description.Image.ImageProperties.ProvisioningState",
	"region":                                 "description.Image.Location",
	"resource_group":                         "description.ResourceGroup",
	"source_virtual_machine_id":              "description.Image.ImageProperties.SourceVirtualMachine.ID",
	"storage_profile_data_disks":             "description.Image.ImageProperties.StorageProfile.DataDisks",
	"storage_profile_os_disk_blob_uri":       "description.Image.ImageProperties.StorageProfile.OsDisk.BlobURI",
	"storage_profile_os_disk_caching":        "description.Image.ImageProperties.StorageProfile.OsDisk.Caching",
	"storage_profile_os_disk_encryption_set": "description.Image.ImageProperties.StorageProfile.OsDisk.DiskEncryptionSet.ID",
	"storage_profile_os_disk_managed_disk_id":      "description.Image.ImageProperties.StorageProfile.OsDisk.ManagedDisk.ID",
	"storage_profile_os_disk_size_gb":              "description.Image.ImageProperties.StorageProfile.OsDisk.DiskSizeGB",
	"storage_profile_os_disk_snapshot_id":          "description.Image.ImageProperties.StorageProfile.OsDisk.Snapshot.ID",
	"storage_profile_os_disk_state":                "description.Image.ImageProperties.StorageProfile.OsDisk.OsState",
	"storage_profile_os_disk_storage_account_type": "description.Image.ImageProperties.StorageProfile.OsDisk.StorageAccountType",
	"storage_profile_os_disk_type":                 "description.Image.ImageProperties.StorageProfile.OsDisk.OsType",
	"storage_profile_zone_resilient":               "description.Image.ImageProperties.StorageProfile.ZoneResilient",
	"tags":                                         "description.Image.Tags",
	"title":                                        "description.Image.Name",
	"type":                                         "description.Image.Type",
}

func ListComputeImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeImage")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeImagePaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeImageFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeImageFilters = map[string]string{
	"akas":                                   "description.Image.ID",
	"hyper_v_generation":                     "description.Image.ImageProperties.HyperVGeneration",
	"id":                                     "description.Image.ID",
	"kaytu_account_id":                       "metadata.SourceID",
	"name":                                   "Description.Image.Name",
	"provisioning_state":                     "description.Image.ImageProperties.ProvisioningState",
	"region":                                 "description.Image.Location",
	"resource_group":                         "Description.Image.ResourceGroup",
	"source_virtual_machine_id":              "description.Image.ImageProperties.SourceVirtualMachine.ID",
	"storage_profile_data_disks":             "description.Image.ImageProperties.StorageProfile.DataDisks",
	"storage_profile_os_disk_blob_uri":       "description.Image.ImageProperties.StorageProfile.OsDisk.BlobURI",
	"storage_profile_os_disk_caching":        "description.Image.ImageProperties.StorageProfile.OsDisk.Caching",
	"storage_profile_os_disk_encryption_set": "description.Image.ImageProperties.StorageProfile.OsDisk.DiskEncryptionSet.ID",
	"storage_profile_os_disk_managed_disk_id":      "description.Image.ImageProperties.StorageProfile.OsDisk.ManagedDisk.ID",
	"storage_profile_os_disk_size_gb":              "description.Image.ImageProperties.StorageProfile.OsDisk.DiskSizeGB",
	"storage_profile_os_disk_snapshot_id":          "description.Image.ImageProperties.StorageProfile.OsDisk.Snapshot.ID",
	"storage_profile_os_disk_state":                "description.Image.ImageProperties.StorageProfile.OsDisk.OsState",
	"storage_profile_os_disk_storage_account_type": "description.Image.ImageProperties.StorageProfile.OsDisk.StorageAccountType",
	"storage_profile_os_disk_type":                 "description.Image.ImageProperties.StorageProfile.OsDisk.OsType",
	"storage_profile_zone_resilient":               "description.Image.ImageProperties.StorageProfile.ZoneResilient",
	"tags":                                         "description.Image.Tags",
	"title":                                        "description.Image.Name",
	"type":                                         "description.Image.Type",
}

func GetComputeImage(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeImage")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeImagePaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeImageFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeImage =============================

// ==========================  START: ComputeHostGroup =============================

type ComputeHostGroup struct {
	Description   azure.ComputeHostGroupDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type ComputeHostGroupHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  ComputeHostGroup `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type ComputeHostGroupHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []ComputeHostGroupHit `json:"hits"`
}

type ComputeHostGroupSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  ComputeHostGroupHits `json:"hits"`
}

type ComputeHostGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeHostGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeHostGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_hostgroups", filters, limit)
	if err != nil {
		return ComputeHostGroupPaginator{}, err
	}

	p := ComputeHostGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeHostGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeHostGroupPaginator) NextPage(ctx context.Context) ([]ComputeHostGroup, error) {
	var response ComputeHostGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeHostGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeHostGroupFilters = map[string]string{
	"akas":  "description.HostGroup.ID",
	"id":    "description.HostGroup.Id",
	"name":  "description.HostGroup.Name",
	"tags":  "description.HostGroup.Tags",
	"title": "description.HostGroup.Name",
}

func ListComputeHostGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeHostGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeHostGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeHostGroupFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeHostGroupFilters = map[string]string{
	"akas":  "description.HostGroup.ID",
	"id":    "description.HostGroup.Id",
	"name":  "description.HostGroup.Name",
	"tags":  "description.HostGroup.Tags",
	"title": "description.HostGroup.Name",
}

func GetComputeHostGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeHostGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeHostGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeHostGroupFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeHostGroup =============================

// ==========================  START: ComputeHostGroupHost =============================

type ComputeHostGroupHost struct {
	Description   azure.ComputeHostGroupHostDescription `json:"description"`
	Metadata      azure.Metadata                        `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type ComputeHostGroupHostHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  ComputeHostGroupHost `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type ComputeHostGroupHostHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []ComputeHostGroupHostHit `json:"hits"`
}

type ComputeHostGroupHostSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  ComputeHostGroupHostHits `json:"hits"`
}

type ComputeHostGroupHostPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeHostGroupHostPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeHostGroupHostPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_hostgroups_hosts", filters, limit)
	if err != nil {
		return ComputeHostGroupHostPaginator{}, err
	}

	p := ComputeHostGroupHostPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeHostGroupHostPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeHostGroupHostPaginator) NextPage(ctx context.Context) ([]ComputeHostGroupHost, error) {
	var response ComputeHostGroupHostSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeHostGroupHost
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeHostGroupHostFilters = map[string]string{
	"akas":  "description.Host.ID",
	"id":    "description.Host.Id",
	"name":  "description.Host.Name",
	"tags":  "description.Host.Tags",
	"title": "description.Host.Name",
}

func ListComputeHostGroupHost(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeHostGroupHost")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeHostGroupHostPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeHostGroupHostFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeHostGroupHostFilters = map[string]string{
	"akas":  "description.Host.ID",
	"id":    "description.Host.Id",
	"name":  "description.Host.Name",
	"tags":  "description.Host.Tags",
	"title": "description.Host.Name",
}

func GetComputeHostGroupHost(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeHostGroupHost")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeHostGroupHostPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeHostGroupHostFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeHostGroupHost =============================

// ==========================  START: DataboxEdgeDevice =============================

type DataboxEdgeDevice struct {
	Description   azure.DataboxEdgeDeviceDescription `json:"description"`
	Metadata      azure.Metadata                     `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type DataboxEdgeDeviceHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  DataboxEdgeDevice `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type DataboxEdgeDeviceHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []DataboxEdgeDeviceHit `json:"hits"`
}

type DataboxEdgeDeviceSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  DataboxEdgeDeviceHits `json:"hits"`
}

type DataboxEdgeDevicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataboxEdgeDevicePaginator(filters []essdk.BoolFilter, limit *int64) (DataboxEdgeDevicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_databoxedge_databoxedgedevices", filters, limit)
	if err != nil {
		return DataboxEdgeDevicePaginator{}, err
	}

	p := DataboxEdgeDevicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataboxEdgeDevicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataboxEdgeDevicePaginator) NextPage(ctx context.Context) ([]DataboxEdgeDevice, error) {
	var response DataboxEdgeDeviceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataboxEdgeDevice
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataboxEdgeDeviceFilters = map[string]string{
	"akas":                        "description.Device.ID",
	"configured_role_types":       "description.Device.DeviceProperties.ConfiguredRoleTypes",
	"culture":                     "description.Device.DeviceProperties.Culture",
	"data_box_edge_device_status": "description.Device.DeviceProperties.DataBoxEdgeDeviceStatus",
	"description":                 "description.Device.DeviceProperties.Description",
	"device_hcs_version":          "description.Device.DeviceProperties.DeviceHcsVersion",
	"device_local_capacity":       "description.Device.DeviceProperties.DeviceLocalCapacity",
	"device_model":                "description.Device.DeviceProperties.DeviceModel",
	"device_software_version":     "description.Device.DeviceProperties.DeviceSoftwareVersion",
	"device_type":                 "description.Device.DeviceProperties.DeviceType",
	"etag":                        "description.Device.Etag",
	"friendly_name":               "description.Device.DeviceProperties.FriendlyName",
	"id":                          "description.Device.ID",
	"kaytu_account_id":            "metadata.SourceID",
	"location":                    "description.Device.Location",
	"model_description":           "description.Device.DeviceProperties.ModelDescription",
	"name":                        "description.Device.Name",
	"node_count":                  "description.Device.DeviceProperties.NodeCount",
	"region":                      "description.Device.Location",
	"resource_group":              "description.ResourceGroup",
	"serial_number":               "description.Device.DeviceProperties.SerialNumber",
	"sku_name":                    "description.Device.Sku.Name",
	"sku_tier":                    "description.Device.Sku.Tier",
	"tags":                        "description.Device.Tags",
	"time_zone":                   "description.Device.DeviceProperties.TimeZone",
	"title":                       "description.Device.Name",
	"type":                        "description.Device.Type",
}

func ListDataboxEdgeDevice(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataboxEdgeDevice")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDataboxEdgeDevicePaginator(essdk.BuildFilter(d.KeyColumnQuals, listDataboxEdgeDeviceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDataboxEdgeDeviceFilters = map[string]string{
	"akas":                        "description.Device.ID",
	"configured_role_types":       "description.Device.DeviceProperties.ConfiguredRoleTypes",
	"culture":                     "description.Device.DeviceProperties.Culture",
	"data_box_edge_device_status": "description.Device.DeviceProperties.DataBoxEdgeDeviceStatus",
	"description":                 "description.Device.DeviceProperties.Description",
	"device_hcs_version":          "description.Device.DeviceProperties.DeviceHcsVersion",
	"device_local_capacity":       "description.Device.DeviceProperties.DeviceLocalCapacity",
	"device_model":                "description.Device.DeviceProperties.DeviceModel",
	"device_software_version":     "description.Device.DeviceProperties.DeviceSoftwareVersion",
	"device_type":                 "description.Device.DeviceProperties.DeviceType",
	"etag":                        "description.Device.Etag",
	"friendly_name":               "description.Device.DeviceProperties.FriendlyName",
	"id":                          "description.Device.ID",
	"kaytu_account_id":            "metadata.SourceID",
	"location":                    "description.Device.Location",
	"model_description":           "description.Device.DeviceProperties.ModelDescription",
	"name":                        "description.Device.name",
	"node_count":                  "description.Device.DeviceProperties.NodeCount",
	"region":                      "description.Device.Location",
	"resource_group":              "description.ResourceGroup",
	"serial_number":               "description.Device.DeviceProperties.SerialNumber",
	"sku_name":                    "description.Device.Sku.Name",
	"sku_tier":                    "description.Device.Sku.Tier",
	"tags":                        "description.Device.Tags",
	"time_zone":                   "description.Device.DeviceProperties.TimeZone",
	"title":                       "description.Device.Name",
	"type":                        "description.Device.Type",
}

func GetDataboxEdgeDevice(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataboxEdgeDevice")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDataboxEdgeDevicePaginator(essdk.BuildFilter(d.KeyColumnQuals, getDataboxEdgeDeviceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DataboxEdgeDevice =============================

// ==========================  START: HealthcareService =============================

type HealthcareService struct {
	Description   azure.HealthcareServiceDescription `json:"description"`
	Metadata      azure.Metadata                     `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type HealthcareServiceHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  HealthcareService `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type HealthcareServiceHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []HealthcareServiceHit `json:"hits"`
}

type HealthcareServiceSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  HealthcareServiceHits `json:"hits"`
}

type HealthcareServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHealthcareServicePaginator(filters []essdk.BoolFilter, limit *int64) (HealthcareServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_healthcareapis_services", filters, limit)
	if err != nil {
		return HealthcareServicePaginator{}, err
	}

	p := HealthcareServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HealthcareServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HealthcareServicePaginator) NextPage(ctx context.Context) ([]HealthcareService, error) {
	var response HealthcareServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HealthcareService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHealthcareServiceFilters = map[string]string{
	"access_policies":              "description.ServicesDescription.Properties.AccessPolicies",
	"akas":                         "description.ServicesDescription.ID",
	"allow_credentials":            "description.ServicesDescription.Properties.CorsConfiguration.AllowCredentials",
	"audience":                     "description.ServicesDescription.Properties.AuthenticationConfiguration.Audience",
	"authority":                    "description.ServicesDescription.Properties.AuthenticationConfiguration.Authority",
	"cosmos_db_configuration":      "description.ServicesDescription.Properties.CosmosDbConfiguration",
	"diagnostic_settings":          "description.DiagnosticSettingsResources",
	"etag":                         "description.ServicesDescription.Etag",
	"headers":                      "description.ServicesDescription.Properties.CorsConfiguration.Origins",
	"id":                           "description.ServicesDescription.ID",
	"kaytu_account_id":             "metadata.SourceID",
	"kind":                         "description.ServicesDescription.Kind",
	"location":                     "description.ServicesDescription.Location",
	"max_age":                      "description.ServicesDescription.Properties.CorsConfiguration.MaxAge",
	"methods":                      "description.ServicesDescription.Properties.CorsConfiguration.Methods",
	"name":                         "description.ServicesDescription.Name",
	"origins":                      "description.ServicesDescription.Properties.CorsConfiguration.Origins",
	"private_endpoint_connections": "description.PrivateEndpointConnections",
	"provisioning_state":           "description.ServicesDescription.Properties.ProvisioningState",
	"region":                       "description.ServicesDescription.Location",
	"resource_group":               "description.ResourceGroup",
	"smart_proxy_enabled":          "description.ServicesDescription.Properties.AuthenticationConfiguration.SmartProxyEnabled",
	"tags":                         "description.ServicesDescription.Tags",
	"title":                        "description.ServicesDescription.Name",
	"type":                         "description.ServicesDescription.Type",
}

func ListHealthcareService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHealthcareService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewHealthcareServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, listHealthcareServiceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getHealthcareServiceFilters = map[string]string{
	"access_policies":              "description.ServicesDescription.Properties.AccessPolicies",
	"akas":                         "description.ServicesDescription.ID",
	"allow_credentials":            "description.ServicesDescription.Properties.CorsConfiguration.AllowCredentials",
	"audience":                     "description.ServicesDescription.Properties.AuthenticationConfiguration.Audience",
	"authority":                    "description.ServicesDescription.Properties.AuthenticationConfiguration.Authority",
	"cosmos_db_configuration":      "description.ServicesDescription.Properties.CosmosDbConfiguration",
	"diagnostic_settings":          "description.DiagnosticSettingsResources",
	"etag":                         "description.ServicesDescription.Etag",
	"headers":                      "description.ServicesDescription.Properties.CorsConfiguration.Origins",
	"id":                           "description.ServicesDescription.ID",
	"kaytu_account_id":             "metadata.SourceID",
	"kind":                         "description.ServicesDescription.Kind",
	"location":                     "description.ServicesDescription.Location",
	"max_age":                      "description.ServicesDescription.Properties.CorsConfiguration.MaxAge",
	"methods":                      "description.ServicesDescription.Properties.CorsConfiguration.Methods",
	"name":                         "description.ServicesDescription.name",
	"origins":                      "description.ServicesDescription.Properties.CorsConfiguration.Origins",
	"private_endpoint_connections": "description.PrivateEndpointConnections",
	"provisioning_state":           "description.ServicesDescription.Properties.ProvisioningState",
	"region":                       "description.ServicesDescription.Location",
	"resource_group":               "description.ResourceGroup",
	"smart_proxy_enabled":          "description.ServicesDescription.Properties.AuthenticationConfiguration.SmartProxyEnabled",
	"tags":                         "description.ServicesDescription.Tags",
	"title":                        "description.ServicesDescription.Name",
	"type":                         "description.ServicesDescription.Type",
}

func GetHealthcareService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHealthcareService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewHealthcareServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, getHealthcareServiceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: HealthcareService =============================

// ==========================  START: HpcCache =============================

type HpcCache struct {
	Description   azure.HpcCacheDescription `json:"description"`
	Metadata      azure.Metadata            `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type HpcCacheHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  HpcCache      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type HpcCacheHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []HpcCacheHit     `json:"hits"`
}

type HpcCacheSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  HpcCacheHits `json:"hits"`
}

type HpcCachePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHpcCachePaginator(filters []essdk.BoolFilter, limit *int64) (HpcCachePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storagecache_caches", filters, limit)
	if err != nil {
		return HpcCachePaginator{}, err
	}

	p := HpcCachePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HpcCachePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HpcCachePaginator) NextPage(ctx context.Context) ([]HpcCache, error) {
	var response HpcCacheSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HpcCache
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHpcCacheFilters = map[string]string{
	"akas":                        "description.Cache.ID",
	"cache_size_gb":               "description.Cache.CacheProperties.CacheSizeGB",
	"directory_services_settings": "description.Cache.CacheProperties.DirectoryServicesSettings",
	"encryption_settings":         "description.Cache.CacheProperties.EncryptionSettings",
	"health":                      "description.Cache.CacheProperties.Health",
	"id":                          "description.Cache.ID",
	"identity":                    "description.Cache.Identity",
	"kaytu_account_id":            "metadata.SourceID",
	"mount_addresses":             "description.Cache.CacheProperties.MountAddresses",
	"name":                        "description.Cache.Name",
	"provisioning_state":          "description.Cache.CacheProperties.ProvisioningState",
	"region":                      "description.Cache.Location",
	"resource_group":              "description.ResourceGroup",
	"security_settings":           "description.Cache.CacheProperties.SecuritySettings",
	"sku_name":                    "description.Cache.Sku.Name",
	"subnet":                      "description.Cache.CacheProperties.Subnet",
	"system_data":                 "description.Cache.SystemData",
	"tags":                        "description.Cache.Tags",
	"title":                       "description.Cache.Name",
	"type":                        "description.Cache.Type",
}

func ListHpcCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHpcCache")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewHpcCachePaginator(essdk.BuildFilter(d.KeyColumnQuals, listHpcCacheFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getHpcCacheFilters = map[string]string{
	"akas":                        "description.Cache.ID",
	"cache_size_gb":               "description.Cache.CacheProperties.CacheSizeGB",
	"directory_services_settings": "description.Cache.CacheProperties.DirectoryServicesSettings",
	"encryption_settings":         "description.Cache.CacheProperties.EncryptionSettings",
	"health":                      "description.Cache.CacheProperties.Health",
	"id":                          "description.Cache.ID",
	"identity":                    "description.Cache.Identity",
	"kaytu_account_id":            "metadata.SourceID",
	"mount_addresses":             "description.Cache.CacheProperties.MountAddresses",
	"name":                        "description.Cache.name",
	"provisioning_state":          "description.Cache.CacheProperties.ProvisioningState",
	"region":                      "description.Cache.Location",
	"resource_group":              "description.ResourceGroup",
	"security_settings":           "description.Cache.CacheProperties.SecuritySettings",
	"sku_name":                    "description.Cache.Sku.Name",
	"subnet":                      "description.Cache.CacheProperties.Subnet",
	"system_data":                 "description.Cache.SystemData",
	"tags":                        "description.Cache.Tags",
	"title":                       "description.Cache.Name",
	"type":                        "description.Cache.Type",
}

func GetHpcCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHpcCache")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewHpcCachePaginator(essdk.BuildFilter(d.KeyColumnQuals, getHpcCacheFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: HpcCache =============================

// ==========================  START: KeyVaultKey =============================

type KeyVaultKey struct {
	Description   azure.KeyVaultKeyDescription `json:"description"`
	Metadata      azure.Metadata               `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type KeyVaultKeyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KeyVaultKey   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KeyVaultKeyHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []KeyVaultKeyHit  `json:"hits"`
}

type KeyVaultKeySearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  KeyVaultKeyHits `json:"hits"`
}

type KeyVaultKeyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyVaultKeyPaginator(filters []essdk.BoolFilter, limit *int64) (KeyVaultKeyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_keyvault_vaults_keys", filters, limit)
	if err != nil {
		return KeyVaultKeyPaginator{}, err
	}

	p := KeyVaultKeyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyVaultKeyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyVaultKeyPaginator) NextPage(ctx context.Context) ([]KeyVaultKey, error) {
	var response KeyVaultKeySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVaultKey
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultKeyFilters = map[string]string{
	"akas":                 "description.Key.ID",
	"created_at":           "description.Key.KeyProperties.Attributes.Created",
	"curve_name":           "description.Key.KeyProperties.CurveName",
	"enabled":              "description.Key.KeyProperties.Attributes.Enabled",
	"expires_at":           "description.Key.KeyProperties.Attributes.Expires",
	"id":                   "description.Key.ID",
	"kaytu_account_id":     "metadata.SourceID",
	"key_ops":              "description.Key.KeyProperties.KeyOps",
	"key_size":             "description.Key.KeyProperties.KeySize",
	"key_type":             "description.Key.Type",
	"key_uri":              "description.Key.KeyProperties.KeyURI",
	"key_uri_with_version": "description.Key.KeyProperties.KeyURIWithVersion",
	"location":             "description.Key.Location",
	"name":                 "description.Key.Name",
	"not_before":           "description.Key.KeyProperties.Attributes.NotBefore",
	"recovery_level":       "description.Key.KeyProperties.Attributes.RecoveryLevel",
	"region":               "description.Key.Location",
	"resource_group":       "description.ResourceGroup",
	"tags":                 "description.Key.Tags",
	"title":                "description.Key.Name",
	"type":                 "description.Key.Type",
	"updated_at":           "description.Key.KeyProperties.Attributes.Updated",
}

func ListKeyVaultKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVaultKey")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKeyVaultKeyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listKeyVaultKeyFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKeyVaultKeyFilters = map[string]string{
	"akas":                 "description.Key.ID",
	"created_at":           "description.Key.KeyProperties.Attributes.Created",
	"curve_name":           "description.Key.KeyProperties.CurveName",
	"enabled":              "description.Key.KeyProperties.Attributes.Enabled",
	"expires_at":           "description.Key.KeyProperties.Attributes.Expires",
	"id":                   "description.Key.ID",
	"kaytu_account_id":     "metadata.SourceID",
	"key_ops":              "description.Key.KeyProperties.KeyOps",
	"key_size":             "description.Key.KeyProperties.KeySize",
	"key_type":             "description.Key.Type",
	"key_uri":              "description.Key.KeyProperties.KeyURI",
	"key_uri_with_version": "description.Key.KeyProperties.KeyURIWithVersion",
	"location":             "description.Key.Location",
	"name":                 "description.Key.name",
	"not_before":           "description.Key.KeyProperties.Attributes.NotBefore",
	"recovery_level":       "description.Key.KeyProperties.Attributes.RecoveryLevel",
	"region":               "description.Key.Location",
	"resource_group":       "description.ResourceGroup",
	"tags":                 "description.Key.Tags",
	"title":                "description.Key.Name",
	"type":                 "description.Key.Type",
	"updated_at":           "description.Key.KeyProperties.Attributes.Updated",
	"vault_name":           "description.Vault.name",
}

func GetKeyVaultKey(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVaultKey")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKeyVaultKeyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getKeyVaultKeyFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KeyVaultKey =============================

// ==========================  START: KubernetesCluster =============================

type KubernetesCluster struct {
	Description   azure.KubernetesClusterDescription `json:"description"`
	Metadata      azure.Metadata                     `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type KubernetesClusterHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  KubernetesCluster `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type KubernetesClusterHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []KubernetesClusterHit `json:"hits"`
}

type KubernetesClusterSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  KubernetesClusterHits `json:"hits"`
}

type KubernetesClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKubernetesClusterPaginator(filters []essdk.BoolFilter, limit *int64) (KubernetesClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_containerservice_managedclusters", filters, limit)
	if err != nil {
		return KubernetesClusterPaginator{}, err
	}

	p := KubernetesClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KubernetesClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KubernetesClusterPaginator) NextPage(ctx context.Context) ([]KubernetesCluster, error) {
	var response KubernetesClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KubernetesCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKubernetesClusterFilters = map[string]string{
	"aad_profile":                "description.ManagedCluster.ManagedClusterProperties.AadProfile",
	"addon_profiles":             "description.ManagedCluster.ManagedClusterProperties.AddonProfiles",
	"agent_pool_profiles":        "description.ManagedCluster.ManagedClusterProperties.AgentPoolProfiles",
	"akas":                       "description.ManagedCluster.ID",
	"api_server_access_profile":  "description.ManagedCluster.ManagedClusterProperties.APIServerAccessProfile",
	"auto_scaler_profile":        "description.ManagedCluster.ManagedClusterProperties.AutoScalerProfile",
	"auto_upgrade_profile":       "description.ManagedCluster.ManagedClusterProperties.AutoUpgradeProfile",
	"azure_portal_fqdn":          "description.ManagedCluster.ManagedClusterProperties.AzurePortalFQDN",
	"disk_encryption_set_id":     "description.ManagedCluster.ManagedClusterProperties.DiskEncryptionSetID",
	"dns_prefix":                 "description.ManagedCluster.ManagedClusterProperties.DNSPrefix",
	"enable_pod_security_policy": "description.ManagedCluster.ManagedClusterProperties.EnablePodSecurityPolicy",
	"enable_rbac":                "description.ManagedCluster.ManagedClusterProperties.EnableRBAC",
	"fqdn":                       "description.ManagedCluster.ManagedClusterProperties.Fqdn",
	"fqdn_subdomain":             "description.ManagedCluster.ManagedClusterProperties.FqdnSubdomain",
	"id":                         "description.ManagedCluster.ID",
	"identity":                   "description.ManagedCluster.Identity",
	"identity_profile":           "description.ManagedCluster.ManagedClusterProperties.IdentityProfile",
	"kaytu_account_id":           "metadata.SourceID",
	"kubernetes_version":         "description.ManagedCluster.ManagedClusterProperties.KubernetesVersion",
	"linux_profile":              "description.ManagedCluster.ManagedClusterProperties.LinuxProfile",
	"location":                   "description.ManagedCluster.Location",
	"max_agent_pools":            "description.ManagedCluster.ManagedClusterProperties.MaxAgentPools",
	"name":                       "description.ManagedCluster.Name",
	"network_profile":            "description.ManagedCluster.ManagedClusterProperties.NetworkProfile",
	"node_resource_group":        "description.ManagedCluster.ManagedClusterProperties.NodeResourceGroup",
	"pod_identity_profile":       "description.ManagedCluster.ManagedClusterProperties.PodIdentityProfile",
	"power_state":                "description.ManagedCluster.ManagedClusterProperties.PowerState",
	"private_fqdn":               "description.ManagedCluster.ManagedClusterProperties.PrivateFQDN",
	"provisioning_state":         "description.ManagedCluster.ManagedClusterProperties.ProvisioningState",
	"region":                     "description.ManagedCluster.Location",
	"resource_group":             "description.ResourceGroup",
	"service_principal_profile":  "description.ManagedCluster.ManagedClusterProperties.ServicePrincipalProfile",
	"sku":                        "description.ManagedCluster.Sku",
	"tags":                       "description.ManagedCluster.Tags",
	"title":                      "description.ManagedCluster.Name",
	"type":                       "description.ManagedCluster.Type",
	"windows_profile":            "description.ManagedCluster.ManagedClusterProperties.WindowsProfile",
}

func ListKubernetesCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKubernetesCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKubernetesClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listKubernetesClusterFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKubernetesClusterFilters = map[string]string{
	"aad_profile":                "description.ManagedCluster.ManagedClusterProperties.AadProfile",
	"addon_profiles":             "description.ManagedCluster.ManagedClusterProperties.AddonProfiles",
	"agent_pool_profiles":        "description.ManagedCluster.ManagedClusterProperties.AgentPoolProfiles",
	"akas":                       "description.ManagedCluster.ID",
	"api_server_access_profile":  "description.ManagedCluster.ManagedClusterProperties.APIServerAccessProfile",
	"auto_scaler_profile":        "description.ManagedCluster.ManagedClusterProperties.AutoScalerProfile",
	"auto_upgrade_profile":       "description.ManagedCluster.ManagedClusterProperties.AutoUpgradeProfile",
	"azure_portal_fqdn":          "description.ManagedCluster.ManagedClusterProperties.AzurePortalFQDN",
	"disk_encryption_set_id":     "description.ManagedCluster.ManagedClusterProperties.DiskEncryptionSetID",
	"dns_prefix":                 "description.ManagedCluster.ManagedClusterProperties.DNSPrefix",
	"enable_pod_security_policy": "description.ManagedCluster.ManagedClusterProperties.EnablePodSecurityPolicy",
	"enable_rbac":                "description.ManagedCluster.ManagedClusterProperties.EnableRBAC",
	"fqdn":                       "description.ManagedCluster.ManagedClusterProperties.Fqdn",
	"fqdn_subdomain":             "description.ManagedCluster.ManagedClusterProperties.FqdnSubdomain",
	"id":                         "description.ManagedCluster.ID",
	"identity":                   "description.ManagedCluster.Identity",
	"identity_profile":           "description.ManagedCluster.ManagedClusterProperties.IdentityProfile",
	"kaytu_account_id":           "metadata.SourceID",
	"kubernetes_version":         "description.ManagedCluster.ManagedClusterProperties.KubernetesVersion",
	"linux_profile":              "description.ManagedCluster.ManagedClusterProperties.LinuxProfile",
	"location":                   "description.ManagedCluster.Location",
	"max_agent_pools":            "description.ManagedCluster.ManagedClusterProperties.MaxAgentPools",
	"name":                       "description.ManagedCluster.name",
	"network_profile":            "description.ManagedCluster.ManagedClusterProperties.NetworkProfile",
	"node_resource_group":        "description.ManagedCluster.ManagedClusterProperties.NodeResourceGroup",
	"pod_identity_profile":       "description.ManagedCluster.ManagedClusterProperties.PodIdentityProfile",
	"power_state":                "description.ManagedCluster.ManagedClusterProperties.PowerState",
	"private_fqdn":               "description.ManagedCluster.ManagedClusterProperties.PrivateFQDN",
	"provisioning_state":         "description.ManagedCluster.ManagedClusterProperties.ProvisioningState",
	"region":                     "description.ManagedCluster.Location",
	"resource_group":             "description.ResourceGroup",
	"service_principal_profile":  "description.ManagedCluster.ManagedClusterProperties.ServicePrincipalProfile",
	"sku":                        "description.ManagedCluster.Sku",
	"tags":                       "description.ManagedCluster.Tags",
	"title":                      "description.ManagedCluster.Name",
	"type":                       "description.ManagedCluster.Type",
	"windows_profile":            "description.ManagedCluster.ManagedClusterProperties.WindowsProfile",
}

func GetKubernetesCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKubernetesCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKubernetesClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getKubernetesClusterFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KubernetesCluster =============================

// ==========================  START: ContainerInstanceContainerGroup =============================

type ContainerInstanceContainerGroup struct {
	Description   azure.ContainerInstanceContainerGroupDescription `json:"description"`
	Metadata      azure.Metadata                                   `json:"metadata"`
	ResourceJobID int                                              `json:"resource_job_id"`
	SourceJobID   int                                              `json:"source_job_id"`
	ResourceType  string                                           `json:"resource_type"`
	SourceType    string                                           `json:"source_type"`
	ID            string                                           `json:"id"`
	ARN           string                                           `json:"arn"`
	SourceID      string                                           `json:"source_id"`
}

type ContainerInstanceContainerGroupHit struct {
	ID      string                          `json:"_id"`
	Score   float64                         `json:"_score"`
	Index   string                          `json:"_index"`
	Type    string                          `json:"_type"`
	Version int64                           `json:"_version,omitempty"`
	Source  ContainerInstanceContainerGroup `json:"_source"`
	Sort    []interface{}                   `json:"sort"`
}

type ContainerInstanceContainerGroupHits struct {
	Total essdk.SearchTotal                    `json:"total"`
	Hits  []ContainerInstanceContainerGroupHit `json:"hits"`
}

type ContainerInstanceContainerGroupSearchResponse struct {
	PitID string                              `json:"pit_id"`
	Hits  ContainerInstanceContainerGroupHits `json:"hits"`
}

type ContainerInstanceContainerGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewContainerInstanceContainerGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ContainerInstanceContainerGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_containerinstance_containergroups", filters, limit)
	if err != nil {
		return ContainerInstanceContainerGroupPaginator{}, err
	}

	p := ContainerInstanceContainerGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ContainerInstanceContainerGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ContainerInstanceContainerGroupPaginator) NextPage(ctx context.Context) ([]ContainerInstanceContainerGroup, error) {
	var response ContainerInstanceContainerGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ContainerInstanceContainerGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listContainerInstanceContainerGroupFilters = map[string]string{
	"akas":             "description.ContainerGroups.ID",
	"id":               "description.ContainerGroups.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ContainerGroups.Name",
	"tags":             "description.ContainerGroups.Tags",
	"title":            "description.ContainerGroups.Name",
}

func ListContainerInstanceContainerGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListContainerInstanceContainerGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewContainerInstanceContainerGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listContainerInstanceContainerGroupFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getContainerInstanceContainerGroupFilters = map[string]string{
	"akas":             "description.ContainerGroups.ID",
	"id":               "description.ContainerGroups.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ContainerGroups.Name",
	"tags":             "description.ContainerGroups.Tags",
	"title":            "description.ContainerGroups.Name",
}

func GetContainerInstanceContainerGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetContainerInstanceContainerGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewContainerInstanceContainerGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getContainerInstanceContainerGroupFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ContainerInstanceContainerGroup =============================

// ==========================  START: CDNProfile =============================

type CDNProfile struct {
	Description   azure.CDNProfileDescription `json:"description"`
	Metadata      azure.Metadata              `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type CDNProfileHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  CDNProfile    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type CDNProfileHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []CDNProfileHit   `json:"hits"`
}

type CDNProfileSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  CDNProfileHits `json:"hits"`
}

type CDNProfilePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCDNProfilePaginator(filters []essdk.BoolFilter, limit *int64) (CDNProfilePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_cdn_profiles", filters, limit)
	if err != nil {
		return CDNProfilePaginator{}, err
	}

	p := CDNProfilePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CDNProfilePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CDNProfilePaginator) NextPage(ctx context.Context) ([]CDNProfile, error) {
	var response CDNProfileSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CDNProfile
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCDNProfileFilters = map[string]string{
	"akas":             "description.Profiles.ID",
	"id":               "description.Profiles.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Profiles.Name",
	"tags":             "description.Profiles.Tags",
	"title":            "description.Profiles.Name",
}

func ListCDNProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCDNProfile")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCDNProfilePaginator(essdk.BuildFilter(d.KeyColumnQuals, listCDNProfileFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCDNProfileFilters = map[string]string{
	"akas":             "description.Profiles.ID",
	"id":               "description.Profiles.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Profiles.Name",
	"tags":             "description.Profiles.Tags",
	"title":            "description.Profiles.Name",
}

func GetCDNProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCDNProfile")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCDNProfilePaginator(essdk.BuildFilter(d.KeyColumnQuals, getCDNProfileFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CDNProfile =============================

// ==========================  START: NetworkInterface =============================

type NetworkInterface struct {
	Description   azure.NetworkInterfaceDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type NetworkInterfaceHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  NetworkInterface `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type NetworkInterfaceHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []NetworkInterfaceHit `json:"hits"`
}

type NetworkInterfaceSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  NetworkInterfaceHits `json:"hits"`
}

type NetworkInterfacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkInterfacePaginator(filters []essdk.BoolFilter, limit *int64) (NetworkInterfacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_networkinterfaces", filters, limit)
	if err != nil {
		return NetworkInterfacePaginator{}, err
	}

	p := NetworkInterfacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkInterfacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkInterfacePaginator) NextPage(ctx context.Context) ([]NetworkInterface, error) {
	var response NetworkInterfaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkInterface
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkInterfaceFilters = map[string]string{
	"akas":                          "description.Interface.ID",
	"applied_dns_servers":           "description.Interface.InterfacePropertiesFormat.DNSSettings.AppliedDNSServers",
	"dns_servers":                   "description.Interface.InterfacePropertiesFormat.DNSSettings.DNSServers",
	"enable_accelerated_networking": "description.Interface.InterfacePropertiesFormat.EnableAcceleratedNetworking",
	"enable_ip_forwarding":          "description.Interface.InterfacePropertiesFormat.EnableIPForwarding",
	"etag":                          "description.Interface.Etag",
	"hosted_workloads":              "description.Interface.InterfacePropertiesFormat.HostedWorkloads",
	"id":                            "description.Interface.ID",
	"internal_dns_name_label":       "description.Interface.InterfacePropertiesFormat.DNSSettings.InternalDNSNameLabel",
	"internal_domain_name_suffix":   "description.Interface.InterfacePropertiesFormat.DNSSettings.InternalDomainNameSuffix",
	"internal_fqdn":                 "description.Interface.InterfacePropertiesFormat.DNSSettings.InternalFqdn",
	"ip_configurations":             "description.Interface.InterfacePropertiesFormat.IPConfigurations",
	"is_primary":                    "description.Interface.InterfacePropertiesFormat.Primary",
	"kaytu_account_id":              "metadata.SourceID",
	"mac_address":                   "description.Interface.InterfacePropertiesFormat.MacAddress",
	"name":                          "description.Interface.Name",
	"network_security_group_id":     "description.Interface.InterfacePropertiesFormat.NetworkSecurityGroup.ID",
	"provisioning_state":            "description.Interface.InterfacePropertiesFormat.ProvisioningState",
	"region":                        "description.Interface.Location",
	"resource_group":                "description.ResourceGroup",
	"resource_guid":                 "description.Interface.InterfacePropertiesFormat.ResourceGUID",
	"tags":                          "description.Interface.Tags",
	"tap_configurations":            "description.Interface.InterfacePropertiesFormat.TapConfigurations",
	"title":                         "description.Interface.Name",
	"type":                          "description.Interface.Type",
	"virtual_machine_id":            "description.Interface.InterfacePropertiesFormat.VirtualMachine.ID",
}

func ListNetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkInterface")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewNetworkInterfacePaginator(essdk.BuildFilter(d.KeyColumnQuals, listNetworkInterfaceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNetworkInterfaceFilters = map[string]string{
	"akas":                          "description.Interface.ID",
	"applied_dns_servers":           "description.Interface.InterfacePropertiesFormat.DNSSettings.AppliedDNSServers",
	"dns_servers":                   "description.Interface.InterfacePropertiesFormat.DNSSettings.DNSServers",
	"enable_accelerated_networking": "description.Interface.InterfacePropertiesFormat.EnableAcceleratedNetworking",
	"enable_ip_forwarding":          "description.Interface.InterfacePropertiesFormat.EnableIPForwarding",
	"etag":                          "description.Interface.Etag",
	"hosted_workloads":              "description.Interface.InterfacePropertiesFormat.HostedWorkloads",
	"id":                            "description.Interface.ID",
	"internal_dns_name_label":       "description.Interface.InterfacePropertiesFormat.DNSSettings.InternalDNSNameLabel",
	"internal_domain_name_suffix":   "description.Interface.InterfacePropertiesFormat.DNSSettings.InternalDomainNameSuffix",
	"internal_fqdn":                 "description.Interface.InterfacePropertiesFormat.DNSSettings.InternalFqdn",
	"ip_configurations":             "description.Interface.InterfacePropertiesFormat.IPConfigurations",
	"is_primary":                    "description.Interface.InterfacePropertiesFormat.Primary",
	"kaytu_account_id":              "metadata.SourceID",
	"mac_address":                   "description.Interface.InterfacePropertiesFormat.MacAddress",
	"name":                          "description.Interface.name",
	"network_security_group_id":     "description.Interface.InterfacePropertiesFormat.NetworkSecurityGroup.ID",
	"provisioning_state":            "description.Interface.InterfacePropertiesFormat.ProvisioningState",
	"region":                        "description.Interface.Location",
	"resource_group":                "description.ResourceGroup",
	"resource_guid":                 "description.Interface.InterfacePropertiesFormat.ResourceGUID",
	"tags":                          "description.Interface.Tags",
	"tap_configurations":            "description.Interface.InterfacePropertiesFormat.TapConfigurations",
	"title":                         "description.Interface.Name",
	"type":                          "description.Interface.Type",
	"virtual_machine_id":            "description.Interface.InterfacePropertiesFormat.VirtualMachine.ID",
}

func GetNetworkInterface(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkInterface")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewNetworkInterfacePaginator(essdk.BuildFilter(d.KeyColumnQuals, getNetworkInterfaceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NetworkInterface =============================

// ==========================  START: NetworkWatcherFlowLog =============================

type NetworkWatcherFlowLog struct {
	Description   azure.NetworkWatcherFlowLogDescription `json:"description"`
	Metadata      azure.Metadata                         `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type NetworkWatcherFlowLogHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  NetworkWatcherFlowLog `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type NetworkWatcherFlowLogHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []NetworkWatcherFlowLogHit `json:"hits"`
}

type NetworkWatcherFlowLogSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  NetworkWatcherFlowLogHits `json:"hits"`
}

type NetworkWatcherFlowLogPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkWatcherFlowLogPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkWatcherFlowLogPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_networkwatchers_flowlogs", filters, limit)
	if err != nil {
		return NetworkWatcherFlowLogPaginator{}, err
	}

	p := NetworkWatcherFlowLogPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkWatcherFlowLogPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkWatcherFlowLogPaginator) NextPage(ctx context.Context) ([]NetworkWatcherFlowLog, error) {
	var response NetworkWatcherFlowLogSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkWatcherFlowLog
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkWatcherFlowLogFilters = map[string]string{
	"akas":                     "description.FlowLog.ID",
	"enabled":                  "description.FlowLog.FlowLogPropertiesFormat.Enabled",
	"etag":                     "description.FlowLog.Etag",
	"file_type":                "description.FlowLog.FlowLogPropertiesFormat.Format.Type",
	"id":                       "description.FlowLog.ID",
	"kaytu_account_id":         "metadata.SourceID",
	"name":                     "description.FlowLog.Name",
	"network_watcher_name":     "description.FlowLog.Name",
	"provisioning_state":       "description.FlowLog.FlowLogPropertiesFormat.ProvisioningState",
	"region":                   "description.FlowLog.Location",
	"resource_group":           "description.ResourceGroup",
	"retention_policy_days":    "description.FlowLog.FlowLogPropertiesFormat.RetentionPolicy.Days",
	"retention_policy_enabled": "description.FlowLog.FlowLogPropertiesFormat.RetentionPolicy.Enabled",
	"storage_id":               "description.FlowLog.FlowLogPropertiesFormat.StorageID",
	"tags":                     "description.FlowLog.Tags",
	"target_resource_guid":     "description.FlowLog.FlowLogPropertiesFormat.TargetResourceGUID",
	"target_resource_id":       "description.FlowLog.FlowLogPropertiesFormat.TargetResourceID",
	"title":                    "description.FlowLog.Name",
	"traffic_analytics":        "description.FlowLog.FlowLogPropertiesFormat.FlowAnalyticsConfiguration.NetworkWatcherFlowAnalyticsConfiguration",
	"type":                     "description.FlowLog.Type",
	"version":                  "description.FlowLog.FlowLogPropertiesFormat.Format.Version",
}

func ListNetworkWatcherFlowLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkWatcherFlowLog")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewNetworkWatcherFlowLogPaginator(essdk.BuildFilter(d.KeyColumnQuals, listNetworkWatcherFlowLogFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNetworkWatcherFlowLogFilters = map[string]string{
	"akas":                     "description.FlowLog.ID",
	"enabled":                  "description.FlowLog.FlowLogPropertiesFormat.Enabled",
	"etag":                     "description.FlowLog.Etag",
	"file_type":                "description.FlowLog.FlowLogPropertiesFormat.Format.Type",
	"id":                       "description.FlowLog.ID",
	"kaytu_account_id":         "metadata.SourceID",
	"name":                     "description.ManagedCluster.name",
	"network_watcher_name":     "description.NetworkWatcherName",
	"provisioning_state":       "description.FlowLog.FlowLogPropertiesFormat.ProvisioningState",
	"region":                   "description.FlowLog.Location",
	"resource_group":           "description.ResourceGroup",
	"retention_policy_days":    "description.FlowLog.FlowLogPropertiesFormat.RetentionPolicy.Days",
	"retention_policy_enabled": "description.FlowLog.FlowLogPropertiesFormat.RetentionPolicy.Enabled",
	"storage_id":               "description.FlowLog.FlowLogPropertiesFormat.StorageID",
	"tags":                     "description.FlowLog.Tags",
	"target_resource_guid":     "description.FlowLog.FlowLogPropertiesFormat.TargetResourceGUID",
	"target_resource_id":       "description.FlowLog.FlowLogPropertiesFormat.TargetResourceID",
	"title":                    "description.FlowLog.Name",
	"traffic_analytics":        "description.FlowLog.FlowLogPropertiesFormat.FlowAnalyticsConfiguration.NetworkWatcherFlowAnalyticsConfiguration",
	"type":                     "description.FlowLog.Type",
	"version":                  "description.FlowLog.FlowLogPropertiesFormat.Format.Version",
}

func GetNetworkWatcherFlowLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkWatcherFlowLog")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewNetworkWatcherFlowLogPaginator(essdk.BuildFilter(d.KeyColumnQuals, getNetworkWatcherFlowLogFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NetworkWatcherFlowLog =============================

// ==========================  START: RouteTables =============================

type RouteTables struct {
	Description   azure.RouteTablesDescription `json:"description"`
	Metadata      azure.Metadata               `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type RouteTablesHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RouteTables   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RouteTablesHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RouteTablesHit  `json:"hits"`
}

type RouteTablesSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  RouteTablesHits `json:"hits"`
}

type RouteTablesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRouteTablesPaginator(filters []essdk.BoolFilter, limit *int64) (RouteTablesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_routetables", filters, limit)
	if err != nil {
		return RouteTablesPaginator{}, err
	}

	p := RouteTablesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RouteTablesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RouteTablesPaginator) NextPage(ctx context.Context) ([]RouteTables, error) {
	var response RouteTablesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RouteTables
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRouteTablesFilters = map[string]string{
	"akas":                          "description.RouteTable.ID",
	"disable_bgp_route_propagation": "description.RouteTable.RouteTablePropertiesFormat.DisableBgpRoutePropagation",
	"etag":                          "description.RouteTable.Etag",
	"kaytu_account_id":              "metadata.SourceID",
	"name":                          "description.RouteTable.Name",
	"provisioning_state":            "description.RouteTable.RouteTablePropertiesFormat.ProvisioningState",
	"region":                        "description.RouteTable.Location",
	"resource_group":                "description.ResourceGroup",
	"routes":                        "description.RouteTable.RouteTablePropertiesFormat.Routes",
	"subnets":                       "description.RouteTable.RouteTablePropertiesFormat.Subnets",
	"tags":                          "description.RouteTable.Tags",
	"title":                         "description.RouteTable.Name",
	"type":                          "description.RouteTable.Type",
}

func ListRouteTables(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRouteTables")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRouteTablesPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRouteTablesFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRouteTablesFilters = map[string]string{
	"akas":                          "description.RouteTable.ID",
	"disable_bgp_route_propagation": "description.RouteTable.RouteTablePropertiesFormat.DisableBgpRoutePropagation",
	"etag":                          "description.RouteTable.Etag",
	"kaytu_account_id":              "metadata.SourceID",
	"name":                          "description.RouteTable.Name",
	"provisioning_state":            "description.RouteTable.RouteTablePropertiesFormat.ProvisioningState",
	"region":                        "description.RouteTable.Location",
	"resource_group":                "description.ResourceGroup",
	"routes":                        "description.RouteTable.RouteTablePropertiesFormat.Routes",
	"subnets":                       "description.RouteTable.RouteTablePropertiesFormat.Subnets",
	"tags":                          "description.RouteTable.Tags",
	"title":                         "description.RouteTable.Name",
	"type":                          "description.RouteTable.Type",
}

func GetRouteTables(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRouteTables")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRouteTablesPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRouteTablesFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RouteTables =============================

// ==========================  START: NetworkApplicationSecurityGroups =============================

type NetworkApplicationSecurityGroups struct {
	Description   azure.NetworkApplicationSecurityGroupsDescription `json:"description"`
	Metadata      azure.Metadata                                    `json:"metadata"`
	ResourceJobID int                                               `json:"resource_job_id"`
	SourceJobID   int                                               `json:"source_job_id"`
	ResourceType  string                                            `json:"resource_type"`
	SourceType    string                                            `json:"source_type"`
	ID            string                                            `json:"id"`
	ARN           string                                            `json:"arn"`
	SourceID      string                                            `json:"source_id"`
}

type NetworkApplicationSecurityGroupsHit struct {
	ID      string                           `json:"_id"`
	Score   float64                          `json:"_score"`
	Index   string                           `json:"_index"`
	Type    string                           `json:"_type"`
	Version int64                            `json:"_version,omitempty"`
	Source  NetworkApplicationSecurityGroups `json:"_source"`
	Sort    []interface{}                    `json:"sort"`
}

type NetworkApplicationSecurityGroupsHits struct {
	Total essdk.SearchTotal                     `json:"total"`
	Hits  []NetworkApplicationSecurityGroupsHit `json:"hits"`
}

type NetworkApplicationSecurityGroupsSearchResponse struct {
	PitID string                               `json:"pit_id"`
	Hits  NetworkApplicationSecurityGroupsHits `json:"hits"`
}

type NetworkApplicationSecurityGroupsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkApplicationSecurityGroupsPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkApplicationSecurityGroupsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_applicationsecuritygroups", filters, limit)
	if err != nil {
		return NetworkApplicationSecurityGroupsPaginator{}, err
	}

	p := NetworkApplicationSecurityGroupsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkApplicationSecurityGroupsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkApplicationSecurityGroupsPaginator) NextPage(ctx context.Context) ([]NetworkApplicationSecurityGroups, error) {
	var response NetworkApplicationSecurityGroupsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkApplicationSecurityGroups
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkApplicationSecurityGroupsFilters = map[string]string{
	"akas":               "description.ApplicationSecurityGroup.ID",
	"etag":               "description.ApplicationSecurityGroup.Etag",
	"kaytu_account_id":   "metadata.SourceID",
	"name":               "description.ApplicationSecurityGroup.Name",
	"provisioning_state": "description.ApplicationSecurityGroup.ApplicationSecurityGroupPropertiesFormat.ProvisioningState",
	"region":             "description.ApplicationSecurityGroup.Location",
	"resource_group":     "description.ResourceGroup",
	"resource_guid":      "description.ApplicationSecurityGroup.ApplicationSecurityGroupPropertiesFormat.ResourceGUID",
	"tags":               "description.ApplicationSecurityGroup.Tags",
	"title":              "description.ApplicationSecurityGroup.Name",
	"type":               "description.ApplicationSecurityGroup.Type",
}

func ListNetworkApplicationSecurityGroups(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkApplicationSecurityGroups")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewNetworkApplicationSecurityGroupsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listNetworkApplicationSecurityGroupsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNetworkApplicationSecurityGroupsFilters = map[string]string{
	"akas":               "description.ApplicationSecurityGroup.ID",
	"etag":               "description.ApplicationSecurityGroup.Etag",
	"kaytu_account_id":   "metadata.SourceID",
	"name":               "description.ApplicationSecurityGroup.Name",
	"provisioning_state": "description.ApplicationSecurityGroup.ApplicationSecurityGroupPropertiesFormat.ProvisioningState",
	"region":             "description.ApplicationSecurityGroup.Location",
	"resource_group":     "description.ResourceGroup",
	"resource_guid":      "description.ApplicationSecurityGroup.ApplicationSecurityGroupPropertiesFormat.ResourceGUID",
	"tags":               "description.ApplicationSecurityGroup.Tags",
	"title":              "description.ApplicationSecurityGroup.Name",
	"type":               "description.ApplicationSecurityGroup.Type",
}

func GetNetworkApplicationSecurityGroups(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkApplicationSecurityGroups")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewNetworkApplicationSecurityGroupsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getNetworkApplicationSecurityGroupsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NetworkApplicationSecurityGroups =============================

// ==========================  START: NetworkAzureFirewall =============================

type NetworkAzureFirewall struct {
	Description   azure.NetworkAzureFirewallDescription `json:"description"`
	Metadata      azure.Metadata                        `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type NetworkAzureFirewallHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  NetworkAzureFirewall `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type NetworkAzureFirewallHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []NetworkAzureFirewallHit `json:"hits"`
}

type NetworkAzureFirewallSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  NetworkAzureFirewallHits `json:"hits"`
}

type NetworkAzureFirewallPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkAzureFirewallPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkAzureFirewallPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_azurefirewalls", filters, limit)
	if err != nil {
		return NetworkAzureFirewallPaginator{}, err
	}

	p := NetworkAzureFirewallPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkAzureFirewallPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkAzureFirewallPaginator) NextPage(ctx context.Context) ([]NetworkAzureFirewall, error) {
	var response NetworkAzureFirewallSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkAzureFirewall
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkAzureFirewallFilters = map[string]string{
	"additional_properties":        "description.AzureFirewall.AzureFirewallPropertiesFormat.AdditionalProperties",
	"akas":                         "description.AzureFirewall.ID",
	"application_rule_collections": "description.AzureFirewall.AzureFirewallPropertiesFormat.ApplicationRuleCollections",
	"availability_zones":           "description.AzureFirewall.Zones",
	"etag":                         "description.AzureFirewall.Etag",
	"firewall_policy_id":           "description.AzureFirewall.AzureFirewallPropertiesFormat.FirewallPolicy.ID",
	"hub_private_ip_address":       "description.AzureFirewall.AzureFirewallPropertiesFormat.HubIPAddresses.PrivateIPAddress",
	"hub_public_ip_address_count":  "description.AzureFirewall.AzureFirewallPropertiesFormat.HubIPAddresses.PublicIPs.Count",
	"hub_public_ip_addresses":      "description.AzureFirewall.AzureFirewallPropertiesFormat.HubIPAddresses.PublicIPs.Addresses",
	"ip_groups":                    "description.AzureFirewall.AzureFirewallPropertiesFormat.IPGroups",
	"kaytu_account_id":             "metadata.SourceID",
	"name":                         "description.AzureFirewall.Name",
	"nat_rule_collections":         "description.AzureFirewall.AzureFirewallPropertiesFormat.NatRuleCollections",
	"network_rule_collections":     "description.AzureFirewall.AzureFirewallPropertiesFormat.NetworkRuleCollections",
	"provisioning_state":           "description.AzureFirewall.AzureFirewallPropertiesFormat.ProvisioningState",
	"region":                       "description.AzureFirewall.Location",
	"resource_group":               "description.ResourceGroup",
	"sku_name":                     "description.AzureFirewall.AzureFirewallPropertiesFormat.Sku.Name",
	"sku_tier":                     "description.AzureFirewall.AzureFirewallPropertiesFormat.Sku.Tier",
	"tags":                         "description.AzureFirewall.Tags",
	"threat_intel_mode":            "description.AzureFirewall.AzureFirewallPropertiesFormat.ThreatIntelMode",
	"title":                        "description.AzureFirewall.Name",
	"type":                         "description.AzureFirewall.Type",
	"virtual_hub_id":               "description.AzureFirewall.AzureFirewallPropertiesFormat.VirtualHub.ID",
}

func ListNetworkAzureFirewall(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkAzureFirewall")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewNetworkAzureFirewallPaginator(essdk.BuildFilter(d.KeyColumnQuals, listNetworkAzureFirewallFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNetworkAzureFirewallFilters = map[string]string{
	"additional_properties":        "description.AzureFirewall.AzureFirewallPropertiesFormat.AdditionalProperties",
	"akas":                         "description.AzureFirewall.ID",
	"application_rule_collections": "description.AzureFirewall.AzureFirewallPropertiesFormat.ApplicationRuleCollections",
	"availability_zones":           "description.AzureFirewall.Zones",
	"etag":                         "description.AzureFirewall.Etag",
	"firewall_policy_id":           "description.AzureFirewall.AzureFirewallPropertiesFormat.FirewallPolicy.ID",
	"hub_private_ip_address":       "description.AzureFirewall.AzureFirewallPropertiesFormat.HubIPAddresses.PrivateIPAddress",
	"hub_public_ip_address_count":  "description.AzureFirewall.AzureFirewallPropertiesFormat.HubIPAddresses.PublicIPs.Count",
	"hub_public_ip_addresses":      "description.AzureFirewall.AzureFirewallPropertiesFormat.HubIPAddresses.PublicIPs.Addresses",
	"ip_groups":                    "description.AzureFirewall.AzureFirewallPropertiesFormat.IPGroups",
	"kaytu_account_id":             "metadata.SourceID",
	"name":                         "description.AzureFirewall.Name",
	"nat_rule_collections":         "description.AzureFirewall.AzureFirewallPropertiesFormat.NatRuleCollections",
	"network_rule_collections":     "description.AzureFirewall.AzureFirewallPropertiesFormat.NetworkRuleCollections",
	"provisioning_state":           "description.AzureFirewall.AzureFirewallPropertiesFormat.ProvisioningState",
	"region":                       "description.AzureFirewall.Location",
	"resource_group":               "description.ResourceGroup",
	"sku_name":                     "description.AzureFirewall.AzureFirewallPropertiesFormat.Sku.Name",
	"sku_tier":                     "description.AzureFirewall.AzureFirewallPropertiesFormat.Sku.Tier",
	"tags":                         "description.AzureFirewall.Tags",
	"threat_intel_mode":            "description.AzureFirewall.AzureFirewallPropertiesFormat.ThreatIntelMode",
	"title":                        "description.AzureFirewall.Name",
	"type":                         "description.AzureFirewall.Type",
	"virtual_hub_id":               "description.AzureFirewall.AzureFirewallPropertiesFormat.VirtualHub.ID",
}

func GetNetworkAzureFirewall(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkAzureFirewall")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewNetworkAzureFirewallPaginator(essdk.BuildFilter(d.KeyColumnQuals, getNetworkAzureFirewallFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NetworkAzureFirewall =============================

// ==========================  START: ExpressRouteCircuit =============================

type ExpressRouteCircuit struct {
	Description   azure.ExpressRouteCircuitDescription `json:"description"`
	Metadata      azure.Metadata                       `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type ExpressRouteCircuitHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ExpressRouteCircuit `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ExpressRouteCircuitHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ExpressRouteCircuitHit `json:"hits"`
}

type ExpressRouteCircuitSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ExpressRouteCircuitHits `json:"hits"`
}

type ExpressRouteCircuitPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewExpressRouteCircuitPaginator(filters []essdk.BoolFilter, limit *int64) (ExpressRouteCircuitPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_expressroutecircuits", filters, limit)
	if err != nil {
		return ExpressRouteCircuitPaginator{}, err
	}

	p := ExpressRouteCircuitPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ExpressRouteCircuitPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ExpressRouteCircuitPaginator) NextPage(ctx context.Context) ([]ExpressRouteCircuit, error) {
	var response ExpressRouteCircuitSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ExpressRouteCircuit
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listExpressRouteCircuitFilters = map[string]string{
	"akas":                                "description.ExpressRouteCircuit.ID",
	"allow_classic_operations":            "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.AllowClassicOperations",
	"authorizations":                      "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.Authorizations",
	"bandwidth_in_gbps":                   "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.BandwidthInGbps",
	"circuit_provisioning_state":          "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.CircuitProvisioningState",
	"etag":                                "description.ExpressRouteCircuit.Etag",
	"express_route_port":                  "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.ExpressRoutePort",
	"global_reach_enabled":                "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.GlobalReachEnabled",
	"kaytu_account_id":                    "metadata.SourceID",
	"name":                                "description.ExpressRouteCircuit.Name",
	"peerings":                            "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.Peerings",
	"provisioning_state":                  "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.ProvisioningState",
	"region":                              "description.ExpressRouteCircuit.Location",
	"resource_group":                      "description.ResourceGroup",
	"service_key":                         "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.ServiceKey",
	"service_provider_notes":              "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.ServiceProviderNotes",
	"service_provider_properties":         "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.ServiceProviderProperties",
	"service_provider_provisioning_state": "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.ServiceProviderProvisioningState",
	"sku_family":                          "description.ExpressRouteCircuit.Sku.Family",
	"sku_name":                            "description.ExpressRouteCircuit.Sku.Name",
	"sku_tier":                            "description.ExpressRouteCircuit.Sku.Tier",
	"tags":                                "description.ExpressRouteCircuit.Tags",
	"title":                               "description.ExpressRouteCircuit.Name",
}

func ListExpressRouteCircuit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListExpressRouteCircuit")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewExpressRouteCircuitPaginator(essdk.BuildFilter(d.KeyColumnQuals, listExpressRouteCircuitFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getExpressRouteCircuitFilters = map[string]string{
	"akas":                                "description.ExpressRouteCircuit.ID",
	"allow_classic_operations":            "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.AllowClassicOperations",
	"authorizations":                      "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.Authorizations",
	"bandwidth_in_gbps":                   "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.BandwidthInGbps",
	"circuit_provisioning_state":          "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.CircuitProvisioningState",
	"etag":                                "description.ExpressRouteCircuit.Etag",
	"express_route_port":                  "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.ExpressRoutePort",
	"global_reach_enabled":                "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.GlobalReachEnabled",
	"kaytu_account_id":                    "metadata.SourceID",
	"name":                                "description.ExpressRouteCircuit.name",
	"peerings":                            "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.Peerings",
	"provisioning_state":                  "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.ProvisioningState",
	"region":                              "description.ExpressRouteCircuit.Location",
	"resource_group":                      "description.ResourceGroup",
	"service_key":                         "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.ServiceKey",
	"service_provider_notes":              "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.ServiceProviderNotes",
	"service_provider_properties":         "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.ServiceProviderProperties",
	"service_provider_provisioning_state": "description.ExpressRouteCircuit.ExpressRouteCircuitPropertiesFormat.ServiceProviderProvisioningState",
	"sku_family":                          "description.ExpressRouteCircuit.Sku.Family",
	"sku_name":                            "description.ExpressRouteCircuit.Sku.Name",
	"sku_tier":                            "description.ExpressRouteCircuit.Sku.Tier",
	"tags":                                "description.ExpressRouteCircuit.Tags",
	"title":                               "description.ExpressRouteCircuit.Name",
}

func GetExpressRouteCircuit(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetExpressRouteCircuit")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewExpressRouteCircuitPaginator(essdk.BuildFilter(d.KeyColumnQuals, getExpressRouteCircuitFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ExpressRouteCircuit =============================

// ==========================  START: VirtualNetworkGateway =============================

type VirtualNetworkGateway struct {
	Description   azure.VirtualNetworkGatewayDescription `json:"description"`
	Metadata      azure.Metadata                         `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type VirtualNetworkGatewayHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  VirtualNetworkGateway `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type VirtualNetworkGatewayHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []VirtualNetworkGatewayHit `json:"hits"`
}

type VirtualNetworkGatewaySearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  VirtualNetworkGatewayHits `json:"hits"`
}

type VirtualNetworkGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVirtualNetworkGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (VirtualNetworkGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_virtualnetworkgateways", filters, limit)
	if err != nil {
		return VirtualNetworkGatewayPaginator{}, err
	}

	p := VirtualNetworkGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VirtualNetworkGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VirtualNetworkGatewayPaginator) NextPage(ctx context.Context) ([]VirtualNetworkGateway, error) {
	var response VirtualNetworkGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VirtualNetworkGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVirtualNetworkGatewayFilters = map[string]string{
	"active_active":                   "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.ActiveActive",
	"akas":                            "description.VirtualNetworkGateway.ID",
	"bgp_settings":                    "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.BgpSettings",
	"custom_routes_address_prefixes":  "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.CustomRoutes.AddressPrefixes",
	"enable_bgp":                      "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.EnableBgp",
	"enable_dns_forwarding":           "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.EnableDNSForwarding",
	"enable_private_ip_address":       "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.EnablePrivateIPAddress",
	"etag":                            "description.VirtualNetworkGateway.Etag",
	"gateway_connections":             "description.VirtualNetworkGatewayConnection",
	"gateway_default_site":            "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.GatewayDefaultSite.ID",
	"gateway_type":                    "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.GatewayType",
	"inbound_dns_forwarding_endpoint": "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.InboundDNSForwardingEndpoint",
	"ip_configurations":               "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.IPConfigurations",
	"kaytu_account_id":                "metadata.SourceID",
	"name":                            "description.VirtualNetworkGateway.Name",
	"provisioning_state":              "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.ProvisioningState",
	"region":                          "description.VirtualNetworkGateway.Location",
	"resource_group":                  "description.ResourceGroup",
	"resource_guid":                   "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.ResourceGUID",
	"sku_capacity":                    "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.Sku.Capacity",
	"sku_name":                        "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.Sku.Name",
	"sku_tier":                        "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.Sku.Tier",
	"tags":                            "description.VirtualNetworkGateway.Tags",
	"title":                           "description.VirtualNetworkGateway.Name",
	"type":                            "description.VirtualNetworkGateway.Type",
	"vpn_client_configuration":        "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.VpnClientConfiguration",
	"vpn_gateway_generation":          "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.VpnGatewayGeneration",
	"vpn_type":                        "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.VpnType",
}

func ListVirtualNetworkGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVirtualNetworkGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewVirtualNetworkGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, listVirtualNetworkGatewayFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getVirtualNetworkGatewayFilters = map[string]string{
	"active_active":                   "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.ActiveActive",
	"akas":                            "description.VirtualNetworkGateway.ID",
	"bgp_settings":                    "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.BgpSettings",
	"custom_routes_address_prefixes":  "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.CustomRoutes.AddressPrefixes",
	"enable_bgp":                      "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.EnableBgp",
	"enable_dns_forwarding":           "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.EnableDNSForwarding",
	"enable_private_ip_address":       "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.EnablePrivateIPAddress",
	"etag":                            "description.VirtualNetworkGateway.Etag",
	"gateway_connections":             "description.VirtualNetworkGatewayConnection",
	"gateway_default_site":            "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.GatewayDefaultSite.ID",
	"gateway_type":                    "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.GatewayType",
	"inbound_dns_forwarding_endpoint": "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.InboundDNSForwardingEndpoint",
	"ip_configurations":               "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.IPConfigurations",
	"kaytu_account_id":                "metadata.SourceID",
	"name":                            "description.VirtualNetworkGateway.Name",
	"provisioning_state":              "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.ProvisioningState",
	"region":                          "description.VirtualNetworkGateway.Location",
	"resource_group":                  "description.ResourceGroup",
	"resource_guid":                   "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.ResourceGUID",
	"sku_capacity":                    "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.Sku.Capacity",
	"sku_name":                        "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.Sku.Name",
	"sku_tier":                        "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.Sku.Tier",
	"tags":                            "description.VirtualNetworkGateway.Tags",
	"title":                           "description.VirtualNetworkGateway.Name",
	"type":                            "description.VirtualNetworkGateway.Type",
	"vpn_client_configuration":        "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.VpnClientConfiguration",
	"vpn_gateway_generation":          "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.VpnGatewayGeneration",
	"vpn_type":                        "description.VirtualNetworkGateway.VirtualNetworkGatewayPropertiesFormat.VpnType",
}

func GetVirtualNetworkGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVirtualNetworkGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewVirtualNetworkGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, getVirtualNetworkGatewayFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: VirtualNetworkGateway =============================

// ==========================  START: FirewallPolicy =============================

type FirewallPolicy struct {
	Description   azure.FirewallPolicyDescription `json:"description"`
	Metadata      azure.Metadata                  `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type FirewallPolicyHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  FirewallPolicy `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type FirewallPolicyHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []FirewallPolicyHit `json:"hits"`
}

type FirewallPolicySearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  FirewallPolicyHits `json:"hits"`
}

type FirewallPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFirewallPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (FirewallPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_firewallpolicies", filters, limit)
	if err != nil {
		return FirewallPolicyPaginator{}, err
	}

	p := FirewallPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FirewallPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FirewallPolicyPaginator) NextPage(ctx context.Context) ([]FirewallPolicy, error) {
	var response FirewallPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FirewallPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFirewallPolicyFilters = map[string]string{
	"akas":             "description.FirewallPolicies.ID",
	"id":               "description.FirewallPolicies.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.FirewallPolicies.Name",
	"tags":             "description.FirewallPolicies.Tags",
	"title":            "description.FirewallPolicies.Name",
}

func ListFirewallPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFirewallPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewFirewallPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listFirewallPolicyFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getFirewallPolicyFilters = map[string]string{
	"akas":             "description.FirewallPolicies.ID",
	"id":               "description.FirewallPolicies.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.FirewallPolicy.Name",
	"resource_group":   "description.ResourceGroup",
	"tags":             "description.FirewallPolicies.Tags",
	"title":            "description.FirewallPolicies.Name",
}

func GetFirewallPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFirewallPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewFirewallPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getFirewallPolicyFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: FirewallPolicy =============================

// ==========================  START: LocalNetworkGateway =============================

type LocalNetworkGateway struct {
	Description   azure.LocalNetworkGatewayDescription `json:"description"`
	Metadata      azure.Metadata                       `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type LocalNetworkGatewayHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  LocalNetworkGateway `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type LocalNetworkGatewayHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []LocalNetworkGatewayHit `json:"hits"`
}

type LocalNetworkGatewaySearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  LocalNetworkGatewayHits `json:"hits"`
}

type LocalNetworkGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLocalNetworkGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (LocalNetworkGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_localnetworkgateways", filters, limit)
	if err != nil {
		return LocalNetworkGatewayPaginator{}, err
	}

	p := LocalNetworkGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LocalNetworkGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LocalNetworkGatewayPaginator) NextPage(ctx context.Context) ([]LocalNetworkGateway, error) {
	var response LocalNetworkGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LocalNetworkGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLocalNetworkGatewayFilters = map[string]string{
	"akas":             "description.LocalNetworkGateways.ID",
	"id":               "description.LocalNetworkGateways.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.LocalNetworkGateways.Name",
	"tags":             "description.LocalNetworkGateways.Tags",
	"title":            "description.LocalNetworkGateways.Name",
}

func ListLocalNetworkGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLocalNetworkGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLocalNetworkGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, listLocalNetworkGatewayFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLocalNetworkGatewayFilters = map[string]string{
	"akas":             "description.LocalNetworkGateways.ID",
	"id":               "description.LocalNetworkGateways.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.LocalNetworkGateway.Name",
	"resource_group":   "description.ResourceGroup",
	"tags":             "description.LocalNetworkGateways.Tags",
	"title":            "description.LocalNetworkGateways.Name",
}

func GetLocalNetworkGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLocalNetworkGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLocalNetworkGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, getLocalNetworkGatewayFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LocalNetworkGateway =============================

// ==========================  START: NatGateway =============================

type NatGateway struct {
	Description   azure.NatGatewayDescription `json:"description"`
	Metadata      azure.Metadata              `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type NatGatewayHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  NatGateway    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type NatGatewayHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []NatGatewayHit   `json:"hits"`
}

type NatGatewaySearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  NatGatewayHits `json:"hits"`
}

type NatGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNatGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (NatGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_natgateways", filters, limit)
	if err != nil {
		return NatGatewayPaginator{}, err
	}

	p := NatGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NatGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NatGatewayPaginator) NextPage(ctx context.Context) ([]NatGateway, error) {
	var response NatGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NatGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNatGatewayFilters = map[string]string{
	"akas":             "description.NatGateway.ID",
	"etag":             "description.NatGateway.Etag",
	"id":               "description.NatGateway.ID",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.NatGateway.Name",
	"region":           "description.NatGateway.Location",
	"resource_group":   "description.ResourceGroup",
	"sku_name":         "description.NatGateway.Sku.Name",
	"tags":             "description.NatGateway.Tags",
	"title":            "description.NatGateway.Name",
	"type":             "description.NatGateway.Type",
	"zones":            "description.NatGateway.Zones",
}

func ListNatGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNatGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewNatGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, listNatGatewayFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNatGatewayFilters = map[string]string{
	"akas":             "description.NatGateway.ID",
	"etag":             "description.NatGateway.Etag",
	"id":               "description.NatGateway.ID",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.NatGateway.Name",
	"region":           "description.NatGateway.Location",
	"resource_group":   "description.ResourceGroup",
	"sku_name":         "description.NatGateway.Sku.Name",
	"tags":             "description.NatGateway.Tags",
	"title":            "description.NatGateway.Name",
	"type":             "description.NatGateway.Type",
	"zones":            "description.NatGateway.Zones",
}

func GetNatGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNatGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewNatGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, getNatGatewayFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NatGateway =============================

// ==========================  START: PrivateLinkService =============================

type PrivateLinkService struct {
	Description   azure.PrivateLinkServiceDescription `json:"description"`
	Metadata      azure.Metadata                      `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type PrivateLinkServiceHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  PrivateLinkService `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type PrivateLinkServiceHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []PrivateLinkServiceHit `json:"hits"`
}

type PrivateLinkServiceSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  PrivateLinkServiceHits `json:"hits"`
}

type PrivateLinkServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPrivateLinkServicePaginator(filters []essdk.BoolFilter, limit *int64) (PrivateLinkServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_privatelinkservices", filters, limit)
	if err != nil {
		return PrivateLinkServicePaginator{}, err
	}

	p := PrivateLinkServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PrivateLinkServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PrivateLinkServicePaginator) NextPage(ctx context.Context) ([]PrivateLinkService, error) {
	var response PrivateLinkServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PrivateLinkService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPrivateLinkServiceFilters = map[string]string{
	"akas":             "description.PrivateLinkServices.ID",
	"id":               "description.PrivateLinkServices.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.PrivateLinkServices.Name",
	"tags":             "description.PrivateLinkServices.Tags",
	"title":            "description.PrivateLinkServices.Name",
}

func ListPrivateLinkService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPrivateLinkService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewPrivateLinkServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, listPrivateLinkServiceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getPrivateLinkServiceFilters = map[string]string{
	"akas":             "description.PrivateLinkServices.ID",
	"id":               "description.PrivateLinkServices.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.PrivateLinkService.Name",
	"resource_group":   "description.ResourceGroup",
	"tags":             "description.PrivateLinkServices.Tags",
	"title":            "description.PrivateLinkServices.Name",
}

func GetPrivateLinkService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPrivateLinkService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewPrivateLinkServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, getPrivateLinkServiceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: PrivateLinkService =============================

// ==========================  START: VpnGateway =============================

type VpnGateway struct {
	Description   azure.VpnGatewayDescription `json:"description"`
	Metadata      azure.Metadata              `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type VpnGatewayHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  VpnGateway    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VpnGatewayHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VpnGatewayHit   `json:"hits"`
}

type VpnGatewaySearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  VpnGatewayHits `json:"hits"`
}

type VpnGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVpnGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (VpnGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_vpngateways", filters, limit)
	if err != nil {
		return VpnGatewayPaginator{}, err
	}

	p := VpnGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VpnGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VpnGatewayPaginator) NextPage(ctx context.Context) ([]VpnGateway, error) {
	var response VpnGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VpnGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVpnGatewayFilters = map[string]string{
	"akas":             "description.VPNGateways.ID",
	"id":               "description.VPNGateways.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VPNGateways.Name",
	"tags":             "description.VPNGateways.Tags",
	"title":            "description.VPNGateways.Name",
}

func ListVpnGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVpnGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewVpnGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, listVpnGatewayFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getVpnGatewayFilters = map[string]string{
	"akas":             "description.VPNGateways.ID",
	"id":               "description.VPNGateways.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VpnGateway.Name",
	"resource_group":   "description.ResourceGroup",
	"tags":             "description.VPNGateways.Tags",
	"title":            "description.VPNGateways.Name",
}

func GetVpnGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVpnGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewVpnGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, getVpnGatewayFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: VpnGateway =============================

// ==========================  START: VpnGatewayVpnConnection =============================

type VpnGatewayVpnConnection struct {
	Description   azure.VpnGatewayVpnConnectionDescription `json:"description"`
	Metadata      azure.Metadata                           `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type VpnGatewayVpnConnectionHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  VpnGatewayVpnConnection `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type VpnGatewayVpnConnectionHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []VpnGatewayVpnConnectionHit `json:"hits"`
}

type VpnGatewayVpnConnectionSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  VpnGatewayVpnConnectionHits `json:"hits"`
}

type VpnGatewayVpnConnectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVpnGatewayVpnConnectionPaginator(filters []essdk.BoolFilter, limit *int64) (VpnGatewayVpnConnectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_vpngateways_vpnconnections", filters, limit)
	if err != nil {
		return VpnGatewayVpnConnectionPaginator{}, err
	}

	p := VpnGatewayVpnConnectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VpnGatewayVpnConnectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VpnGatewayVpnConnectionPaginator) NextPage(ctx context.Context) ([]VpnGatewayVpnConnection, error) {
	var response VpnGatewayVpnConnectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VpnGatewayVpnConnection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVpnGatewayVpnConnectionFilters = map[string]string{
	"akas":             "description.VPNConnections.ID",
	"id":               "description.VPNConnections.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VPNConnections.Name",
	"tags":             "description.VPNConnections.Tags",
	"title":            "description.VPNConnections.Name",
}

func ListVpnGatewayVpnConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVpnGatewayVpnConnection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewVpnGatewayVpnConnectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listVpnGatewayVpnConnectionFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getVpnGatewayVpnConnectionFilters = map[string]string{
	"akas":             "description.VPNConnections.ID",
	"id":               "description.VPNConnections.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VPNConnections.Name",
	"tags":             "description.VPNConnections.Tags",
	"title":            "description.VPNConnections.Name",
}

func GetVpnGatewayVpnConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVpnGatewayVpnConnection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewVpnGatewayVpnConnectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getVpnGatewayVpnConnectionFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: VpnGatewayVpnConnection =============================

// ==========================  START: VpnSite =============================

type VpnSite struct {
	Description   azure.VpnSiteDescription `json:"description"`
	Metadata      azure.Metadata           `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type VpnSiteHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  VpnSite       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VpnSiteHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VpnSiteHit      `json:"hits"`
}

type VpnSiteSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  VpnSiteHits `json:"hits"`
}

type VpnSitePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVpnSitePaginator(filters []essdk.BoolFilter, limit *int64) (VpnSitePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_vpnsites", filters, limit)
	if err != nil {
		return VpnSitePaginator{}, err
	}

	p := VpnSitePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VpnSitePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VpnSitePaginator) NextPage(ctx context.Context) ([]VpnSite, error) {
	var response VpnSiteSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VpnSite
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVpnSiteFilters = map[string]string{
	"akas":             "description.VPNSites.ID",
	"id":               "description.VPNSites.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VPNSites.Name",
	"tags":             "description.VPNSites.Tags",
	"title":            "description.VPNSites.Name",
}

func ListVpnSite(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVpnSite")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewVpnSitePaginator(essdk.BuildFilter(d.KeyColumnQuals, listVpnSiteFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getVpnSiteFilters = map[string]string{
	"akas":             "description.VPNSites.ID",
	"id":               "description.VPNSites.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VPNSites.Name",
	"tags":             "description.VPNSites.Tags",
	"title":            "description.VPNSites.Name",
}

func GetVpnSite(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVpnSite")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewVpnSitePaginator(essdk.BuildFilter(d.KeyColumnQuals, getVpnSiteFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: VpnSite =============================

// ==========================  START: PublicIPAddress =============================

type PublicIPAddress struct {
	Description   azure.PublicIPAddressDescription `json:"description"`
	Metadata      azure.Metadata                   `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type PublicIPAddressHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  PublicIPAddress `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type PublicIPAddressHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []PublicIPAddressHit `json:"hits"`
}

type PublicIPAddressSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  PublicIPAddressHits `json:"hits"`
}

type PublicIPAddressPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPublicIPAddressPaginator(filters []essdk.BoolFilter, limit *int64) (PublicIPAddressPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_publicipaddresses", filters, limit)
	if err != nil {
		return PublicIPAddressPaginator{}, err
	}

	p := PublicIPAddressPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PublicIPAddressPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PublicIPAddressPaginator) NextPage(ctx context.Context) ([]PublicIPAddress, error) {
	var response PublicIPAddressSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PublicIPAddress
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPublicIPAddressFilters = map[string]string{
	"akas":                              "description.PublicIPAddress.ID",
	"ddos_custom_policy_id":             "description.PublicIPAddress.PublicIPAddressPropertiesFormat.DdosSettings.DdosCustomPolicy.ID",
	"ddos_settings_protected_ip":        "description.PublicIPAddress.PublicIPAddressPropertiesFormat.DdosSettings.ProtectedIP",
	"ddos_settings_protection_coverage": "description.PublicIPAddress.PublicIPAddressPropertiesFormat.DdosSettings.ProtectionCoverage",
	"dns_settings_domain_name_label":    "description.PublicIPAddress.PublicIPAddressPropertiesFormat.DNSSettings.DomainNameLabel",
	"dns_settings_fqdn":                 "description.PublicIPAddress.PublicIPAddressPropertiesFormat.DNSSettings.Fqdn",
	"dns_settings_reverse_fqdn":         "description.PublicIPAddress.PublicIPAddressPropertiesFormat.DNSSettings.ReverseFqdn",
	"etag":                              "description.PublicIPAddress.Etag",
	"id":                                "description.PublicIPAddress.ID",
	"idle_timeout_in_minutes":           "description.PublicIPAddress.PublicIPAddressPropertiesFormat.IdleTimeoutInMinutes",
	"ip_address":                        "description.PublicIPAddress.PublicIPAddressPropertiesFormat.IPAddress",
	"ip_configuration_id":               "description.PublicIPAddress.PublicIPAddressPropertiesFormat.IPConfiguration.ID",
	"ip_tags":                           "description.PublicIPAddress.PublicIPAddressPropertiesFormat.IPTags",
	"kaytu_account_id":                  "metadata.SourceID",
	"name":                              "description.PublicIPAddress.Name",
	"provisioning_state":                "description.PublicIPAddress.PublicIPAddressPropertiesFormat.ProvisioningState",
	"public_ip_address_version":         "description.PublicIPAddress.PublicIPAddressPropertiesFormat.PublicIPAddressVersion",
	"public_ip_allocation_method":       "description.PublicIPAddress.PublicIPAddressPropertiesFormat.PublicIPAllocationMethod",
	"public_ip_prefix_id":               "description.PublicIPAddress.PublicIPAddressPropertiesFormat.PublicIPPrefix.ID",
	"region":                            "description.PublicIPAddress.Location",
	"resource_group":                    "description.ResourceGroup",
	"resource_guid":                     "description.PublicIPAddress.PublicIPAddressPropertiesFormat.ResourceGUID",
	"sku_name":                          "description.PublicIPAddress.Sku.Name",
	"tags":                              "description.PublicIPAddress.Tags",
	"title":                             "description.PublicIPAddress.Name",
	"type":                              "description.PublicIPAddress.Type",
	"zones":                             "description.PublicIPAddress.Location",
}

func ListPublicIPAddress(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPublicIPAddress")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewPublicIPAddressPaginator(essdk.BuildFilter(d.KeyColumnQuals, listPublicIPAddressFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getPublicIPAddressFilters = map[string]string{
	"akas":                              "description.PublicIPAddress.ID",
	"ddos_custom_policy_id":             "description.PublicIPAddress.PublicIPAddressPropertiesFormat.DdosSettings.DdosCustomPolicy.ID",
	"ddos_settings_protected_ip":        "description.PublicIPAddress.PublicIPAddressPropertiesFormat.DdosSettings.ProtectedIP",
	"ddos_settings_protection_coverage": "description.PublicIPAddress.PublicIPAddressPropertiesFormat.DdosSettings.ProtectionCoverage",
	"dns_settings_domain_name_label":    "description.PublicIPAddress.PublicIPAddressPropertiesFormat.DNSSettings.DomainNameLabel",
	"dns_settings_fqdn":                 "description.PublicIPAddress.PublicIPAddressPropertiesFormat.DNSSettings.Fqdn",
	"dns_settings_reverse_fqdn":         "description.PublicIPAddress.PublicIPAddressPropertiesFormat.DNSSettings.ReverseFqdn",
	"etag":                              "description.PublicIPAddress.Etag",
	"id":                                "description.PublicIPAddress.ID",
	"idle_timeout_in_minutes":           "description.PublicIPAddress.PublicIPAddressPropertiesFormat.IdleTimeoutInMinutes",
	"ip_address":                        "description.PublicIPAddress.PublicIPAddressPropertiesFormat.IPAddress",
	"ip_configuration_id":               "description.PublicIPAddress.PublicIPAddressPropertiesFormat.IPConfiguration.ID",
	"ip_tags":                           "description.PublicIPAddress.PublicIPAddressPropertiesFormat.IPTags",
	"kaytu_account_id":                  "metadata.SourceID",
	"name":                              "description.PublicIPAddress.Name",
	"provisioning_state":                "description.PublicIPAddress.PublicIPAddressPropertiesFormat.ProvisioningState",
	"public_ip_address_version":         "description.PublicIPAddress.PublicIPAddressPropertiesFormat.PublicIPAddressVersion",
	"public_ip_allocation_method":       "description.PublicIPAddress.PublicIPAddressPropertiesFormat.PublicIPAllocationMethod",
	"public_ip_prefix_id":               "description.PublicIPAddress.PublicIPAddressPropertiesFormat.PublicIPPrefix.ID",
	"region":                            "description.PublicIPAddress.Location",
	"resource_group":                    "description.ResourceGroup",
	"resource_guid":                     "description.PublicIPAddress.PublicIPAddressPropertiesFormat.ResourceGUID",
	"sku_name":                          "description.PublicIPAddress.Sku.Name",
	"tags":                              "description.PublicIPAddress.Tags",
	"title":                             "description.PublicIPAddress.Name",
	"type":                              "description.PublicIPAddress.Type",
	"zones":                             "description.PublicIPAddress.Location",
}

func GetPublicIPAddress(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPublicIPAddress")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewPublicIPAddressPaginator(essdk.BuildFilter(d.KeyColumnQuals, getPublicIPAddressFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: PublicIPAddress =============================

// ==========================  START: PublicIPPrefix =============================

type PublicIPPrefix struct {
	Description   azure.PublicIPPrefixDescription `json:"description"`
	Metadata      azure.Metadata                  `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type PublicIPPrefixHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  PublicIPPrefix `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type PublicIPPrefixHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []PublicIPPrefixHit `json:"hits"`
}

type PublicIPPrefixSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  PublicIPPrefixHits `json:"hits"`
}

type PublicIPPrefixPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPublicIPPrefixPaginator(filters []essdk.BoolFilter, limit *int64) (PublicIPPrefixPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_publicipprefixes", filters, limit)
	if err != nil {
		return PublicIPPrefixPaginator{}, err
	}

	p := PublicIPPrefixPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PublicIPPrefixPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PublicIPPrefixPaginator) NextPage(ctx context.Context) ([]PublicIPPrefix, error) {
	var response PublicIPPrefixSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PublicIPPrefix
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPublicIPPrefixFilters = map[string]string{
	"akas":             "description.PublicIPPrefixes.ID",
	"id":               "description.PublicIPPrefixes.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.PublicIPPrefixes.Name",
	"tags":             "description.PublicIPPrefixes.Tags",
	"title":            "description.PublicIPPrefixes.Name",
}

func ListPublicIPPrefix(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPublicIPPrefix")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewPublicIPPrefixPaginator(essdk.BuildFilter(d.KeyColumnQuals, listPublicIPPrefixFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getPublicIPPrefixFilters = map[string]string{
	"akas":             "description.PublicIPPrefixes.ID",
	"id":               "description.PublicIPPrefixes.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.PublicIPPrefixes.Name",
	"tags":             "description.PublicIPPrefixes.Tags",
	"title":            "description.PublicIPPrefixes.Name",
}

func GetPublicIPPrefix(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPublicIPPrefix")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewPublicIPPrefixPaginator(essdk.BuildFilter(d.KeyColumnQuals, getPublicIPPrefixFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: PublicIPPrefix =============================

// ==========================  START: DNSZones =============================

type DNSZones struct {
	Description   azure.DNSZonesDescription `json:"description"`
	Metadata      azure.Metadata            `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type DNSZonesHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DNSZones      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DNSZonesHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DNSZonesHit     `json:"hits"`
}

type DNSZonesSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  DNSZonesHits `json:"hits"`
}

type DNSZonesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDNSZonesPaginator(filters []essdk.BoolFilter, limit *int64) (DNSZonesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_dnszones", filters, limit)
	if err != nil {
		return DNSZonesPaginator{}, err
	}

	p := DNSZonesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DNSZonesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DNSZonesPaginator) NextPage(ctx context.Context) ([]DNSZones, error) {
	var response DNSZonesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DNSZones
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDNSZonesFilters = map[string]string{
	"akas":             "description.DNSZones.ID",
	"id":               "description.DNSZones.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.DNSZones.Name",
	"tags":             "description.DNSZones.Tags",
	"title":            "description.DNSZones.Name",
}

func ListDNSZones(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDNSZones")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDNSZonesPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDNSZonesFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDNSZonesFilters = map[string]string{
	"akas":             "description.DNSZones.ID",
	"id":               "description.DNSZones.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.DNSZones.Name",
	"tags":             "description.DNSZones.Tags",
	"title":            "description.DNSZones.Name",
}

func GetDNSZones(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDNSZones")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDNSZonesPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDNSZonesFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DNSZones =============================

// ==========================  START: BastionHosts =============================

type BastionHosts struct {
	Description   azure.BastionHostsDescription `json:"description"`
	Metadata      azure.Metadata                `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type BastionHostsHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BastionHosts  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BastionHostsHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BastionHostsHit `json:"hits"`
}

type BastionHostsSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  BastionHostsHits `json:"hits"`
}

type BastionHostsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBastionHostsPaginator(filters []essdk.BoolFilter, limit *int64) (BastionHostsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_bastionhosts", filters, limit)
	if err != nil {
		return BastionHostsPaginator{}, err
	}

	p := BastionHostsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BastionHostsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BastionHostsPaginator) NextPage(ctx context.Context) ([]BastionHosts, error) {
	var response BastionHostsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BastionHosts
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBastionHostsFilters = map[string]string{
	"akas":             "description.BastionHosts.ID",
	"id":               "description.BastionHosts.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.BastionHosts.Name",
	"tags":             "description.BastionHosts.Tags",
	"title":            "description.BastionHosts.Name",
}

func ListBastionHosts(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBastionHosts")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewBastionHostsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listBastionHostsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBastionHostsFilters = map[string]string{
	"akas":             "description.BastionHosts.ID",
	"id":               "description.BastionHosts.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.BastionHosts.Name",
	"tags":             "description.BastionHosts.Tags",
	"title":            "description.BastionHosts.Name",
}

func GetBastionHosts(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBastionHosts")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewBastionHostsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getBastionHostsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: BastionHosts =============================

// ==========================  START: Connection =============================

type Connection struct {
	Description   azure.ConnectionDescription `json:"description"`
	Metadata      azure.Metadata              `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type ConnectionHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Connection    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ConnectionHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ConnectionHit   `json:"hits"`
}

type ConnectionSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  ConnectionHits `json:"hits"`
}

type ConnectionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewConnectionPaginator(filters []essdk.BoolFilter, limit *int64) (ConnectionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_connections", filters, limit)
	if err != nil {
		return ConnectionPaginator{}, err
	}

	p := ConnectionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ConnectionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ConnectionPaginator) NextPage(ctx context.Context) ([]Connection, error) {
	var response ConnectionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Connection
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listConnectionFilters = map[string]string{
	"akas":             "description.Connections.ID",
	"id":               "description.Connections.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Connections.Name",
	"tags":             "description.Connections.Tags",
	"title":            "description.Connections.Name",
}

func ListConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListConnection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewConnectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listConnectionFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getConnectionFilters = map[string]string{
	"akas":             "description.Connections.ID",
	"id":               "description.Connections.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Connections.Name",
	"tags":             "description.Connections.Tags",
	"title":            "description.Connections.Name",
}

func GetConnection(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetConnection")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewConnectionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getConnectionFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Connection =============================

// ==========================  START: VirtualHubs =============================

type VirtualHubs struct {
	Description   azure.VirtualHubsDescription `json:"description"`
	Metadata      azure.Metadata               `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type VirtualHubsHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  VirtualHubs   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VirtualHubsHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VirtualHubsHit  `json:"hits"`
}

type VirtualHubsSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  VirtualHubsHits `json:"hits"`
}

type VirtualHubsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVirtualHubsPaginator(filters []essdk.BoolFilter, limit *int64) (VirtualHubsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_virtualhubs", filters, limit)
	if err != nil {
		return VirtualHubsPaginator{}, err
	}

	p := VirtualHubsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VirtualHubsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VirtualHubsPaginator) NextPage(ctx context.Context) ([]VirtualHubs, error) {
	var response VirtualHubsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VirtualHubs
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVirtualHubsFilters = map[string]string{
	"akas":             "description.VirtualHubs.ID",
	"id":               "description.VirtualHubs.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VirtualHubs.Name",
	"tags":             "description.VirtualHubs.Tags",
	"title":            "description.VirtualHubs.Name",
}

func ListVirtualHubs(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVirtualHubs")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewVirtualHubsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listVirtualHubsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getVirtualHubsFilters = map[string]string{
	"akas":             "description.VirtualHubs.ID",
	"id":               "description.VirtualHubs.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VirtualHubs.Name",
	"tags":             "description.VirtualHubs.Tags",
	"title":            "description.VirtualHubs.Name",
}

func GetVirtualHubs(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVirtualHubs")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewVirtualHubsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getVirtualHubsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: VirtualHubs =============================

// ==========================  START: VirtualWans =============================

type VirtualWans struct {
	Description   azure.VirtualWansDescription `json:"description"`
	Metadata      azure.Metadata               `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type VirtualWansHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  VirtualWans   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type VirtualWansHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []VirtualWansHit  `json:"hits"`
}

type VirtualWansSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  VirtualWansHits `json:"hits"`
}

type VirtualWansPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVirtualWansPaginator(filters []essdk.BoolFilter, limit *int64) (VirtualWansPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_virtualwans", filters, limit)
	if err != nil {
		return VirtualWansPaginator{}, err
	}

	p := VirtualWansPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VirtualWansPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VirtualWansPaginator) NextPage(ctx context.Context) ([]VirtualWans, error) {
	var response VirtualWansSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VirtualWans
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVirtualWansFilters = map[string]string{
	"akas":             "description.VirtualWans.ID",
	"id":               "description.VirtualWans.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VirtualWans.Name",
	"tags":             "description.VirtualWans.Tags",
	"title":            "description.VirtualWans.Name",
}

func ListVirtualWans(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVirtualWans")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewVirtualWansPaginator(essdk.BuildFilter(d.KeyColumnQuals, listVirtualWansFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getVirtualWansFilters = map[string]string{
	"akas":             "description.VirtualWans.ID",
	"id":               "description.VirtualWans.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VirtualWans.Name",
	"tags":             "description.VirtualWans.Tags",
	"title":            "description.VirtualWans.Name",
}

func GetVirtualWans(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVirtualWans")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewVirtualWansPaginator(essdk.BuildFilter(d.KeyColumnQuals, getVirtualWansFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: VirtualWans =============================

// ==========================  START: DNSResolvers =============================

type DNSResolvers struct {
	Description   azure.DNSResolversDescription `json:"description"`
	Metadata      azure.Metadata                `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type DNSResolversHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DNSResolvers  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DNSResolversHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DNSResolversHit `json:"hits"`
}

type DNSResolversSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  DNSResolversHits `json:"hits"`
}

type DNSResolversPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDNSResolversPaginator(filters []essdk.BoolFilter, limit *int64) (DNSResolversPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_dnsresolvers", filters, limit)
	if err != nil {
		return DNSResolversPaginator{}, err
	}

	p := DNSResolversPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DNSResolversPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DNSResolversPaginator) NextPage(ctx context.Context) ([]DNSResolvers, error) {
	var response DNSResolversSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DNSResolvers
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDNSResolversFilters = map[string]string{
	"akas":             "description.DNSResolvers.ID",
	"id":               "description.DNSResolvers.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.DNSResolvers.Name",
	"tags":             "description.DNSResolvers.Tags",
	"title":            "description.DNSResolvers.Name",
}

func ListDNSResolvers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDNSResolvers")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDNSResolversPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDNSResolversFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDNSResolversFilters = map[string]string{
	"akas":             "description.DNSResolvers.ID",
	"id":               "description.DNSResolvers.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.DNSResolvers.Name",
	"tags":             "description.DNSResolvers.Tags",
	"title":            "description.DNSResolvers.Name",
}

func GetDNSResolvers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDNSResolvers")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDNSResolversPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDNSResolversFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DNSResolvers =============================

// ==========================  START: PrivateDNSZones =============================

type PrivateDNSZones struct {
	Description   azure.PrivateDNSZonesDescription `json:"description"`
	Metadata      azure.Metadata                   `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type PrivateDNSZonesHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  PrivateDNSZones `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type PrivateDNSZonesHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []PrivateDNSZonesHit `json:"hits"`
}

type PrivateDNSZonesSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  PrivateDNSZonesHits `json:"hits"`
}

type PrivateDNSZonesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPrivateDNSZonesPaginator(filters []essdk.BoolFilter, limit *int64) (PrivateDNSZonesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_privatednszones", filters, limit)
	if err != nil {
		return PrivateDNSZonesPaginator{}, err
	}

	p := PrivateDNSZonesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PrivateDNSZonesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PrivateDNSZonesPaginator) NextPage(ctx context.Context) ([]PrivateDNSZones, error) {
	var response PrivateDNSZonesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PrivateDNSZones
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPrivateDNSZonesFilters = map[string]string{
	"akas":             "description.PrivateDNSZones.ID",
	"id":               "description.PrivateDNSZones.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.PrivateDNSZones.Name",
	"tags":             "description.PrivateDNSZones.Tags",
	"title":            "description.PrivateDNSZones.Name",
}

func ListPrivateDNSZones(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPrivateDNSZones")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewPrivateDNSZonesPaginator(essdk.BuildFilter(d.KeyColumnQuals, listPrivateDNSZonesFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getPrivateDNSZonesFilters = map[string]string{
	"akas":             "description.PrivateDNSZones.ID",
	"id":               "description.PrivateDNSZones.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.PrivateDNSZones.Name",
	"tags":             "description.PrivateDNSZones.Tags",
	"title":            "description.PrivateDNSZones.Name",
}

func GetPrivateDNSZones(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPrivateDNSZones")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewPrivateDNSZonesPaginator(essdk.BuildFilter(d.KeyColumnQuals, getPrivateDNSZonesFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: PrivateDNSZones =============================

// ==========================  START: PrivateEndpoint =============================

type PrivateEndpoint struct {
	Description   azure.PrivateEndpointDescription `json:"description"`
	Metadata      azure.Metadata                   `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type PrivateEndpointHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  PrivateEndpoint `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type PrivateEndpointHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []PrivateEndpointHit `json:"hits"`
}

type PrivateEndpointSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  PrivateEndpointHits `json:"hits"`
}

type PrivateEndpointPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPrivateEndpointPaginator(filters []essdk.BoolFilter, limit *int64) (PrivateEndpointPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_privateendpoints", filters, limit)
	if err != nil {
		return PrivateEndpointPaginator{}, err
	}

	p := PrivateEndpointPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PrivateEndpointPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PrivateEndpointPaginator) NextPage(ctx context.Context) ([]PrivateEndpoint, error) {
	var response PrivateEndpointSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PrivateEndpoint
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPrivateEndpointFilters = map[string]string{
	"akas":             "description.PrivateEndpoints.ID",
	"id":               "description.PrivateEndpoints.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.PrivateEndpoints.Name",
	"tags":             "description.PrivateEndpoints.Tags",
	"title":            "description.PrivateEndpoints.Name",
}

func ListPrivateEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPrivateEndpoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewPrivateEndpointPaginator(essdk.BuildFilter(d.KeyColumnQuals, listPrivateEndpointFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getPrivateEndpointFilters = map[string]string{
	"akas":             "description.PrivateEndpoints.ID",
	"id":               "description.PrivateEndpoints.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.PrivateEndpoints.Name",
	"tags":             "description.PrivateEndpoints.Tags",
	"title":            "description.PrivateEndpoints.Name",
}

func GetPrivateEndpoint(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPrivateEndpoint")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewPrivateEndpointPaginator(essdk.BuildFilter(d.KeyColumnQuals, getPrivateEndpointFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: PrivateEndpoint =============================

// ==========================  START: PolicyAssignment =============================

type PolicyAssignment struct {
	Description   azure.PolicyAssignmentDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type PolicyAssignmentHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  PolicyAssignment `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type PolicyAssignmentHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []PolicyAssignmentHit `json:"hits"`
}

type PolicyAssignmentSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  PolicyAssignmentHits `json:"hits"`
}

type PolicyAssignmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPolicyAssignmentPaginator(filters []essdk.BoolFilter, limit *int64) (PolicyAssignmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_authorization_policyassignments", filters, limit)
	if err != nil {
		return PolicyAssignmentPaginator{}, err
	}

	p := PolicyAssignmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PolicyAssignmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PolicyAssignmentPaginator) NextPage(ctx context.Context) ([]PolicyAssignment, error) {
	var response PolicyAssignmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PolicyAssignment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPolicyAssignmentFilters = map[string]string{
	"akas":                 "description.Assignment.ID",
	"description":          "description.Assignment.AssignmentProperties.Description",
	"display_name":         "description.Assignment.AssignmentProperties.DisplayName",
	"enforcement_mode":     "description.Assignment.AssignmentProperties.EnforcementMode",
	"id":                   "description.Assignment.ID",
	"identity":             "description.Assignment.Identity",
	"kaytu_account_id":     "metadata.SourceID",
	"metadata":             "description.Assignment.AssignmentProperties.Metadata",
	"name":                 "description.Assignment.Name",
	"not_scopes":           "description.Assignment.AssignmentProperties.NotScopes",
	"parameters":           "description.Assignment.AssignmentProperties.Parameters",
	"policy_definition_id": "description.Assignment.AssignmentProperties.PolicyDefinitionID",
	"scope":                "description.Assignment.AssignmentProperties.Scope",
	"sku_name":             "description.Assignment.Sku.Name",
	"sku_tier":             "description.Assignment.Sku.Tier",
	"title":                "description.Assignment.Name",
	"type":                 "description.Assignment.Type",
}

func ListPolicyAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPolicyAssignment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewPolicyAssignmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, listPolicyAssignmentFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getPolicyAssignmentFilters = map[string]string{
	"akas":                 "description.Assignment.ID",
	"description":          "description.Assignment.AssignmentProperties.Description",
	"display_name":         "description.Assignment.AssignmentProperties.DisplayName",
	"enforcement_mode":     "description.Assignment.AssignmentProperties.EnforcementMode",
	"id":                   "description.Assignment.ID",
	"identity":             "description.Assignment.Identity",
	"kaytu_account_id":     "metadata.SourceID",
	"metadata":             "description.Assignment.AssignmentProperties.Metadata",
	"name":                 "description.Assignment.name",
	"not_scopes":           "description.Assignment.AssignmentProperties.NotScopes",
	"parameters":           "description.Assignment.AssignmentProperties.Parameters",
	"policy_definition_id": "description.Assignment.AssignmentProperties.PolicyDefinitionID",
	"scope":                "description.Assignment.AssignmentProperties.Scope",
	"sku_name":             "description.Assignment.Sku.Name",
	"sku_tier":             "description.Assignment.Sku.Tier",
	"title":                "description.Assignment.Name",
	"type":                 "description.Assignment.Type",
}

func GetPolicyAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPolicyAssignment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewPolicyAssignmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, getPolicyAssignmentFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: PolicyAssignment =============================

// ==========================  START: RedisCache =============================

type RedisCache struct {
	Description   azure.RedisCacheDescription `json:"description"`
	Metadata      azure.Metadata              `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type RedisCacheHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  RedisCache    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type RedisCacheHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []RedisCacheHit   `json:"hits"`
}

type RedisCacheSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  RedisCacheHits `json:"hits"`
}

type RedisCachePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedisCachePaginator(filters []essdk.BoolFilter, limit *int64) (RedisCachePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_cache_redis", filters, limit)
	if err != nil {
		return RedisCachePaginator{}, err
	}

	p := RedisCachePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedisCachePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedisCachePaginator) NextPage(ctx context.Context) ([]RedisCache, error) {
	var response RedisCacheSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedisCache
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedisCacheFilters = map[string]string{
	"access_keys":                  "description.ResourceType.Properties.AccessKeys",
	"akas":                         "description.ResourceType.ID",
	"enable_non_ssl_port":          "description.ResourceType.Properties.EnableNonSslPort",
	"host_name":                    "description.ResourceType.Properties.HostName",
	"id":                           "description.ResourceType.ID",
	"instances":                    "description.ResourceType.Properties.Instances",
	"kaytu_account_id":             "metadata.SourceID",
	"linked_servers":               "description.ResourceType.Properties.LinkedServers",
	"minimum_tls_version":          "description.ResourceType.Properties.MinimumTLSVersion",
	"name":                         "description.ResourceType.Name",
	"port":                         "description.ResourceType.Properties.Port",
	"private_endpoint_connections": "description.ResourceType.Properties.PrivateEndpointConnections",
	"provisioning_state":           "description.ResourceType.Properties.ProvisioningState",
	"public_network_access":        "description.ResourceType.Properties.PublicNetworkAccess",
	"redis_configuration":          "description.ResourceType.Properties.RedisConfiguration",
	"redis_version":                "description.ResourceType.Properties.RedisVersion",
	"region":                       "description.ResourceType.Location",
	"replicas_per_master":          "description.ResourceType.Properties.ReplicasPerMaster",
	"resource_group":               "description.ResourceGroup",
	"shard_count":                  "description.ResourceType.Properties.ShardCount",
	"sku_capacity":                 "description.ResourceType.Properties.Sku.Capacity",
	"sku_family":                   "description.ResourceType.Properties.Sku.Family",
	"sku_name":                     "description.ResourceType.Properties.Sku.Name",
	"ssl_port":                     "description.ResourceType.Properties.SslPort",
	"static_ip":                    "description.ResourceType.Properties.StaticIP",
	"subnet_id":                    "description.ResourceType.Properties.SubnetID",
	"tags":                         "description.ResourceType.Tags",
	"tenant_settings":              "description.ResourceType.Properties.TenantSettings",
	"title":                        "description.ResourceType.Name",
	"type":                         "description.ResourceType",
	"zones":                        "description.ResourceType.Zones",
}

func ListRedisCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedisCache")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRedisCachePaginator(essdk.BuildFilter(d.KeyColumnQuals, listRedisCacheFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRedisCacheFilters = map[string]string{
	"access_keys":                  "description.ResourceType.Properties.AccessKeys",
	"akas":                         "description.ResourceType.ID",
	"enable_non_ssl_port":          "description.ResourceType.Properties.EnableNonSslPort",
	"host_name":                    "description.ResourceType.Properties.HostName",
	"id":                           "description.ResourceType.ID",
	"instances":                    "description.ResourceType.Properties.Instances",
	"kaytu_account_id":             "metadata.SourceID",
	"linked_servers":               "description.ResourceType.Properties.LinkedServers",
	"minimum_tls_version":          "description.ResourceType.Properties.MinimumTLSVersion",
	"name":                         "description.ResourceType.name",
	"port":                         "description.ResourceType.Properties.Port",
	"private_endpoint_connections": "description.ResourceType.Properties.PrivateEndpointConnections",
	"provisioning_state":           "description.ResourceType.Properties.ProvisioningState",
	"public_network_access":        "description.ResourceType.Properties.PublicNetworkAccess",
	"redis_configuration":          "description.ResourceType.Properties.RedisConfiguration",
	"redis_version":                "description.ResourceType.Properties.RedisVersion",
	"region":                       "description.ResourceType.Location",
	"replicas_per_master":          "description.ResourceType.Properties.ReplicasPerMaster",
	"resource_group":               "description.ResourceGroup",
	"shard_count":                  "description.ResourceType.Properties.ShardCount",
	"sku_capacity":                 "description.ResourceType.Properties.Sku.Capacity",
	"sku_family":                   "description.ResourceType.Properties.Sku.Family",
	"sku_name":                     "description.ResourceType.Properties.Sku.Name",
	"ssl_port":                     "description.ResourceType.Properties.SslPort",
	"static_ip":                    "description.ResourceType.Properties.StaticIP",
	"subnet_id":                    "description.ResourceType.Properties.SubnetID",
	"tags":                         "description.ResourceType.Tags",
	"tenant_settings":              "description.ResourceType.Properties.TenantSettings",
	"title":                        "description.ResourceType.Name",
	"type":                         "description.ResourceType",
	"zones":                        "description.ResourceType.Zones",
}

func GetRedisCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedisCache")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRedisCachePaginator(essdk.BuildFilter(d.KeyColumnQuals, getRedisCacheFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RedisCache =============================

// ==========================  START: RedisEnterpriseCache =============================

type RedisEnterpriseCache struct {
	Description   azure.RedisEnterpriseCacheDescription `json:"description"`
	Metadata      azure.Metadata                        `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type RedisEnterpriseCacheHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  RedisEnterpriseCache `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type RedisEnterpriseCacheHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []RedisEnterpriseCacheHit `json:"hits"`
}

type RedisEnterpriseCacheSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  RedisEnterpriseCacheHits `json:"hits"`
}

type RedisEnterpriseCachePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRedisEnterpriseCachePaginator(filters []essdk.BoolFilter, limit *int64) (RedisEnterpriseCachePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_cache_redisenterprise", filters, limit)
	if err != nil {
		return RedisEnterpriseCachePaginator{}, err
	}

	p := RedisEnterpriseCachePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RedisEnterpriseCachePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RedisEnterpriseCachePaginator) NextPage(ctx context.Context) ([]RedisEnterpriseCache, error) {
	var response RedisEnterpriseCacheSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RedisEnterpriseCache
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRedisEnterpriseCacheFilters = map[string]string{
	"akas":             "description.RedisEnterprise.ID",
	"id":               "description.RedisEnterprise.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.RedisEnterprise.Name",
	"tags":             "description.RedisEnterprise.Tags",
	"title":            "description.RedisEnterprise.Name",
}

func ListRedisEnterpriseCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRedisEnterpriseCache")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRedisEnterpriseCachePaginator(essdk.BuildFilter(d.KeyColumnQuals, listRedisEnterpriseCacheFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRedisEnterpriseCacheFilters = map[string]string{
	"akas":             "description.RedisEnterprise.ID",
	"id":               "description.RedisEnterprise.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.RedisEnterprise.Name",
	"tags":             "description.RedisEnterprise.Tags",
	"title":            "description.RedisEnterprise.Name",
}

func GetRedisEnterpriseCache(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRedisEnterpriseCache")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRedisEnterpriseCachePaginator(essdk.BuildFilter(d.KeyColumnQuals, getRedisEnterpriseCacheFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RedisEnterpriseCache =============================

// ==========================  START: ResourceLink =============================

type ResourceLink struct {
	Description   azure.ResourceLinkDescription `json:"description"`
	Metadata      azure.Metadata                `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type ResourceLinkHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ResourceLink  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ResourceLinkHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ResourceLinkHit `json:"hits"`
}

type ResourceLinkSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  ResourceLinkHits `json:"hits"`
}

type ResourceLinkPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewResourceLinkPaginator(filters []essdk.BoolFilter, limit *int64) (ResourceLinkPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_links", filters, limit)
	if err != nil {
		return ResourceLinkPaginator{}, err
	}

	p := ResourceLinkPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ResourceLinkPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ResourceLinkPaginator) NextPage(ctx context.Context) ([]ResourceLink, error) {
	var response ResourceLinkSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ResourceLink
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listResourceLinkFilters = map[string]string{
	"akas":             "description.ResourceLink.Name",
	"id":               "description.ResourceLink.ID",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ResourceLink.Name",
	"notes":            "description.ResourceLink.Properties.Notes",
	"resource_group":   "description.ResourceGroup",
	"source_id":        "description.ResourceLink.Properties.SourceID",
	"target_id":        "description.ResourceLink.Properties.TargetID",
	"title":            "description.ResourceLink.Name",
	"type":             "description.ResourceLink.Type",
}

func ListResourceLink(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListResourceLink")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewResourceLinkPaginator(essdk.BuildFilter(d.KeyColumnQuals, listResourceLinkFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getResourceLinkFilters = map[string]string{
	"akas":             "description.ResourceLink.Name",
	"id":               "description.ResourceLink.id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ResourceLink.Name",
	"notes":            "description.ResourceLink.Properties.Notes",
	"resource_group":   "description.ResourceGroup",
	"source_id":        "description.ResourceLink.Properties.SourceID",
	"target_id":        "description.ResourceLink.Properties.TargetID",
	"title":            "description.ResourceLink.Name",
	"type":             "description.ResourceLink.Type",
}

func GetResourceLink(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetResourceLink")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewResourceLinkPaginator(essdk.BuildFilter(d.KeyColumnQuals, getResourceLinkFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ResourceLink =============================

// ==========================  START: RoleAssignment =============================

type RoleAssignment struct {
	Description   azure.RoleAssignmentDescription `json:"description"`
	Metadata      azure.Metadata                  `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type RoleAssignmentHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  RoleAssignment `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type RoleAssignmentHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []RoleAssignmentHit `json:"hits"`
}

type RoleAssignmentSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  RoleAssignmentHits `json:"hits"`
}

type RoleAssignmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoleAssignmentPaginator(filters []essdk.BoolFilter, limit *int64) (RoleAssignmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_authorization_roleassignment", filters, limit)
	if err != nil {
		return RoleAssignmentPaginator{}, err
	}

	p := RoleAssignmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RoleAssignmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RoleAssignmentPaginator) NextPage(ctx context.Context) ([]RoleAssignment, error) {
	var response RoleAssignmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RoleAssignment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoleAssignmentFilters = map[string]string{
	"akas":               "description.RoleAssignment.ID",
	"id":                 "description.RoleAssignment.ID",
	"kaytu_account_id":   "metadata.SourceID",
	"name":               "description.RoleAssignment.Name",
	"principal_id":       "description.RoleAssignment.RoleAssignmentPropertiesWithScope.PrincipalID",
	"principal_type":     "description.RoleAssignment.RoleAssignmentPropertiesWithScope.PrincipalType",
	"role_definition_id": "description.RoleAssignment.RoleAssignmentPropertiesWithScope.RoleDefinitionID",
	"scope":              "description.RoleAssignment.RoleAssignmentPropertiesWithScope.Scope",
	"title":              "description.RoleAssignment.Name",
	"type":               "description.RoleAssignment.Type",
}

func ListRoleAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoleAssignment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRoleAssignmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRoleAssignmentFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRoleAssignmentFilters = map[string]string{
	"akas":               "description.RoleAssignment.ID",
	"id":                 "description.RoleAssignment.id",
	"kaytu_account_id":   "metadata.SourceID",
	"name":               "description.RoleAssignment.Name",
	"principal_id":       "description.RoleAssignment.RoleAssignmentPropertiesWithScope.PrincipalID",
	"principal_type":     "description.RoleAssignment.RoleAssignmentPropertiesWithScope.PrincipalType",
	"role_definition_id": "description.RoleAssignment.RoleAssignmentPropertiesWithScope.RoleDefinitionID",
	"scope":              "description.RoleAssignment.RoleAssignmentPropertiesWithScope.Scope",
	"title":              "description.RoleAssignment.Name",
	"type":               "description.RoleAssignment.Type",
}

func GetRoleAssignment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoleAssignment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRoleAssignmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRoleAssignmentFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RoleAssignment =============================

// ==========================  START: RoleDefinition =============================

type RoleDefinition struct {
	Description   azure.RoleDefinitionDescription `json:"description"`
	Metadata      azure.Metadata                  `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type RoleDefinitionHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  RoleDefinition `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type RoleDefinitionHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []RoleDefinitionHit `json:"hits"`
}

type RoleDefinitionSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  RoleDefinitionHits `json:"hits"`
}

type RoleDefinitionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRoleDefinitionPaginator(filters []essdk.BoolFilter, limit *int64) (RoleDefinitionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_authorization_roledefinitions", filters, limit)
	if err != nil {
		return RoleDefinitionPaginator{}, err
	}

	p := RoleDefinitionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RoleDefinitionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RoleDefinitionPaginator) NextPage(ctx context.Context) ([]RoleDefinition, error) {
	var response RoleDefinitionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RoleDefinition
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRoleDefinitionFilters = map[string]string{
	"akas":              "description.RoleDefinition.ID",
	"assignable_scopes": "description.RoleDefinition.RoleDefinitionProperties.AssignableScopes",
	"description":       "description.RoleDefinition.RoleDefinitionProperties.Description",
	"id":                "description.RoleDefinition.ID",
	"kaytu_account_id":  "metadata.SourceID",
	"name":              "description.RoleDefinition.Name",
	"permissions":       "description.RoleDefinition.RoleDefinitionProperties.Permissions",
	"role_name":         "description.RoleDefinition.RoleDefinitionProperties.RoleName",
	"role_type":         "description.RoleDefinition.RoleDefinitionProperties.RoleType",
	"title":             "description.RoleDefinition.RoleDefinitionProperties.RoleName",
	"type":              "description.RoleDefinition.Type",
}

func ListRoleDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRoleDefinition")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRoleDefinitionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRoleDefinitionFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRoleDefinitionFilters = map[string]string{
	"akas":              "description.RoleDefinition.ID",
	"assignable_scopes": "description.RoleDefinition.RoleDefinitionProperties.AssignableScopes",
	"description":       "description.RoleDefinition.RoleDefinitionProperties.Description",
	"id":                "description.RoleDefinition.ID",
	"kaytu_account_id":  "metadata.SourceID",
	"name":              "description.RoleDefinition.name",
	"permissions":       "description.RoleDefinition.RoleDefinitionProperties.Permissions",
	"role_name":         "description.RoleDefinition.RoleDefinitionProperties.RoleName",
	"role_type":         "description.RoleDefinition.RoleDefinitionProperties.RoleType",
	"title":             "description.RoleDefinition.RoleDefinitionProperties.RoleName",
	"type":              "description.RoleDefinition.Type",
}

func GetRoleDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRoleDefinition")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRoleDefinitionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRoleDefinitionFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RoleDefinition =============================

// ==========================  START: PolicyDefinition =============================

type PolicyDefinition struct {
	Description   azure.PolicyDefinitionDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type PolicyDefinitionHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  PolicyDefinition `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type PolicyDefinitionHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []PolicyDefinitionHit `json:"hits"`
}

type PolicyDefinitionSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  PolicyDefinitionHits `json:"hits"`
}

type PolicyDefinitionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPolicyDefinitionPaginator(filters []essdk.BoolFilter, limit *int64) (PolicyDefinitionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_authorization_policydefinitions", filters, limit)
	if err != nil {
		return PolicyDefinitionPaginator{}, err
	}

	p := PolicyDefinitionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PolicyDefinitionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PolicyDefinitionPaginator) NextPage(ctx context.Context) ([]PolicyDefinition, error) {
	var response PolicyDefinitionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PolicyDefinition
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPolicyDefinitionFilters = map[string]string{
	"akas":             "description.TurboData",
	"description":      "description.Definition.DefinitionProperties.Description",
	"display_name":     "description.Definition.DefinitionProperties.DisplayName",
	"id":               "iD",
	"kaytu_account_id": "metadata.SourceID",
	"metadata":         "description.Definition.DefinitionProperties.Metadata",
	"mode":             "description.Definition.DefinitionProperties.Mode",
	"name":             "description.Definition.Name",
	"parameters":       "description.Definition.DefinitionProperties.Parameters",
	"policy_rule":      "description.Definition.DefinitionProperties.PolicyRule",
	"policy_type":      "description.Definition.DefinitionProperties.PolicyType",
	"title":            "description.Definition.DefinitionProperties.DisplayName",
	"type":             "description.Definition.Type",
}

func ListPolicyDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPolicyDefinition")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewPolicyDefinitionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listPolicyDefinitionFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getPolicyDefinitionFilters = map[string]string{
	"akas":             "description.TurboData",
	"description":      "description.Definition.DefinitionProperties.Description",
	"display_name":     "description.Definition.DefinitionProperties.DisplayName",
	"id":               "iD",
	"kaytu_account_id": "metadata.SourceID",
	"metadata":         "description.Definition.DefinitionProperties.Metadata",
	"mode":             "description.Definition.DefinitionProperties.Mode",
	"name":             "description.Definition.Name",
	"parameters":       "description.Definition.DefinitionProperties.Parameters",
	"policy_rule":      "description.Definition.DefinitionProperties.PolicyRule",
	"policy_type":      "description.Definition.DefinitionProperties.PolicyType",
	"title":            "description.Definition.DefinitionProperties.DisplayName",
	"type":             "description.Definition.Type",
}

func GetPolicyDefinition(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPolicyDefinition")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewPolicyDefinitionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getPolicyDefinitionFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: PolicyDefinition =============================

// ==========================  START: SecurityCenterAutoProvisioning =============================

type SecurityCenterAutoProvisioning struct {
	Description   azure.SecurityCenterAutoProvisioningDescription `json:"description"`
	Metadata      azure.Metadata                                  `json:"metadata"`
	ResourceJobID int                                             `json:"resource_job_id"`
	SourceJobID   int                                             `json:"source_job_id"`
	ResourceType  string                                          `json:"resource_type"`
	SourceType    string                                          `json:"source_type"`
	ID            string                                          `json:"id"`
	ARN           string                                          `json:"arn"`
	SourceID      string                                          `json:"source_id"`
}

type SecurityCenterAutoProvisioningHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  SecurityCenterAutoProvisioning `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type SecurityCenterAutoProvisioningHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []SecurityCenterAutoProvisioningHit `json:"hits"`
}

type SecurityCenterAutoProvisioningSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  SecurityCenterAutoProvisioningHits `json:"hits"`
}

type SecurityCenterAutoProvisioningPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityCenterAutoProvisioningPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityCenterAutoProvisioningPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_security_autoprovisioningsettings", filters, limit)
	if err != nil {
		return SecurityCenterAutoProvisioningPaginator{}, err
	}

	p := SecurityCenterAutoProvisioningPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityCenterAutoProvisioningPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityCenterAutoProvisioningPaginator) NextPage(ctx context.Context) ([]SecurityCenterAutoProvisioning, error) {
	var response SecurityCenterAutoProvisioningSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterAutoProvisioning
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterAutoProvisioningFilters = map[string]string{
	"akas":             "description.AutoProvisioningSetting.ID",
	"auto_provision":   "description.AutoProvisioningSetting.AutoProvisioningSettingProperties.AutoProvision",
	"id":               "description.AutoProvisioningSetting.ID",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.AutoProvisioningSetting.Name",
	"title":            "description.AutoProvisioningSetting.Name",
	"type":             "description.AutoProvisioningSetting.Type",
}

func ListSecurityCenterAutoProvisioning(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterAutoProvisioning")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityCenterAutoProvisioningPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityCenterAutoProvisioningFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityCenterAutoProvisioningFilters = map[string]string{
	"akas":             "description.AutoProvisioningSetting.ID",
	"auto_provision":   "description.AutoProvisioningSetting.AutoProvisioningSettingProperties.AutoProvision",
	"id":               "description.AutoProvisioningSetting.ID",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.AutoProvisioningSetting.name",
	"title":            "description.AutoProvisioningSetting.Name",
	"type":             "description.AutoProvisioningSetting.Type",
}

func GetSecurityCenterAutoProvisioning(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterAutoProvisioning")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterAutoProvisioningPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityCenterAutoProvisioningFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityCenterAutoProvisioning =============================

// ==========================  START: SecurityCenterContact =============================

type SecurityCenterContact struct {
	Description   azure.SecurityCenterContactDescription `json:"description"`
	Metadata      azure.Metadata                         `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type SecurityCenterContactHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  SecurityCenterContact `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type SecurityCenterContactHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []SecurityCenterContactHit `json:"hits"`
}

type SecurityCenterContactSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  SecurityCenterContactHits `json:"hits"`
}

type SecurityCenterContactPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityCenterContactPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityCenterContactPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_security_securitycontacts", filters, limit)
	if err != nil {
		return SecurityCenterContactPaginator{}, err
	}

	p := SecurityCenterContactPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityCenterContactPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityCenterContactPaginator) NextPage(ctx context.Context) ([]SecurityCenterContact, error) {
	var response SecurityCenterContactSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterContact
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterContactFilters = map[string]string{
	"akas":                "description.Contact.ID",
	"alert_notifications": "description.Contact.ContactProperties.AlertNotifications",
	"alerts_to_admins":    "description.Contact.ContactProperties.AlertsToAdmins",
	"email":               "description.Contact.ContactProperties.Email",
	"id":                  "description.Contact.ID",
	"kaytu_account_id":    "metadata.SourceID",
	"name":                "description.Contact.Name",
	"phone":               "description.Contact.ContactProperties.Phone",
	"title":               "description.Contact.Name",
	"type":                "description.Contact.Type",
}

func ListSecurityCenterContact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterContact")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityCenterContactPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityCenterContactFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityCenterContactFilters = map[string]string{
	"akas":                "description.Contact.ID",
	"alert_notifications": "description.Contact.ContactProperties.AlertNotifications",
	"alerts_to_admins":    "description.Contact.ContactProperties.AlertsToAdmins",
	"email":               "description.Contact.ContactProperties.Email",
	"id":                  "description.Contact.ID",
	"kaytu_account_id":    "metadata.SourceID",
	"name":                "description.Contact.name",
	"phone":               "description.Contact.ContactProperties.Phone",
	"title":               "description.Contact.Name",
	"type":                "description.Contact.Type",
}

func GetSecurityCenterContact(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterContact")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterContactPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityCenterContactFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityCenterContact =============================

// ==========================  START: SecurityCenterJitNetworkAccessPolicy =============================

type SecurityCenterJitNetworkAccessPolicy struct {
	Description   azure.SecurityCenterJitNetworkAccessPolicyDescription `json:"description"`
	Metadata      azure.Metadata                                        `json:"metadata"`
	ResourceJobID int                                                   `json:"resource_job_id"`
	SourceJobID   int                                                   `json:"source_job_id"`
	ResourceType  string                                                `json:"resource_type"`
	SourceType    string                                                `json:"source_type"`
	ID            string                                                `json:"id"`
	ARN           string                                                `json:"arn"`
	SourceID      string                                                `json:"source_id"`
}

type SecurityCenterJitNetworkAccessPolicyHit struct {
	ID      string                               `json:"_id"`
	Score   float64                              `json:"_score"`
	Index   string                               `json:"_index"`
	Type    string                               `json:"_type"`
	Version int64                                `json:"_version,omitempty"`
	Source  SecurityCenterJitNetworkAccessPolicy `json:"_source"`
	Sort    []interface{}                        `json:"sort"`
}

type SecurityCenterJitNetworkAccessPolicyHits struct {
	Total essdk.SearchTotal                         `json:"total"`
	Hits  []SecurityCenterJitNetworkAccessPolicyHit `json:"hits"`
}

type SecurityCenterJitNetworkAccessPolicySearchResponse struct {
	PitID string                                   `json:"pit_id"`
	Hits  SecurityCenterJitNetworkAccessPolicyHits `json:"hits"`
}

type SecurityCenterJitNetworkAccessPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityCenterJitNetworkAccessPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityCenterJitNetworkAccessPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_security_locations_jitnetworkaccesspolicies", filters, limit)
	if err != nil {
		return SecurityCenterJitNetworkAccessPolicyPaginator{}, err
	}

	p := SecurityCenterJitNetworkAccessPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityCenterJitNetworkAccessPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityCenterJitNetworkAccessPolicyPaginator) NextPage(ctx context.Context) ([]SecurityCenterJitNetworkAccessPolicy, error) {
	var response SecurityCenterJitNetworkAccessPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterJitNetworkAccessPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterJitNetworkAccessPolicyFilters = map[string]string{
	"akas":               "description.JitNetworkAccessPolicy.ID",
	"id":                 "description.JitNetworkAccessPolicy.ID",
	"kaytu_account_id":   "metadata.SourceID",
	"kind":               "description.JitNetworkAccessPolicy.Kind",
	"name":               "description.JitNetworkAccessPolicy.Name",
	"provisioning_state": "description.JitNetworkAccessPolicy.JitNetworkAccessPolicyProperties.ProvisioningState",
	"title":              "description.JitNetworkAccessPolicy.Name",
	"type":               "description.JitNetworkAccessPolicy.Type",
	"virtual_machines":   "description.JitNetworkAccessPolicy.JitNetworkAccessPolicyProperties.VirtualMachines",
}

func ListSecurityCenterJitNetworkAccessPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterJitNetworkAccessPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityCenterJitNetworkAccessPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityCenterJitNetworkAccessPolicyFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityCenterJitNetworkAccessPolicyFilters = map[string]string{
	"akas":               "description.JitNetworkAccessPolicy.ID",
	"id":                 "description.JitNetworkAccessPolicy.ID",
	"kaytu_account_id":   "metadata.SourceID",
	"kind":               "description.JitNetworkAccessPolicy.Kind",
	"name":               "description.JitNetworkAccessPolicy.Name",
	"provisioning_state": "description.JitNetworkAccessPolicy.JitNetworkAccessPolicyProperties.ProvisioningState",
	"title":              "description.JitNetworkAccessPolicy.Name",
	"type":               "description.JitNetworkAccessPolicy.Type",
	"virtual_machines":   "description.JitNetworkAccessPolicy.JitNetworkAccessPolicyProperties.VirtualMachines",
}

func GetSecurityCenterJitNetworkAccessPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterJitNetworkAccessPolicy")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterJitNetworkAccessPolicyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityCenterJitNetworkAccessPolicyFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityCenterJitNetworkAccessPolicy =============================

// ==========================  START: SecurityCenterSetting =============================

type SecurityCenterSetting struct {
	Description   azure.SecurityCenterSettingDescription `json:"description"`
	Metadata      azure.Metadata                         `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type SecurityCenterSettingHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  SecurityCenterSetting `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type SecurityCenterSettingHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []SecurityCenterSettingHit `json:"hits"`
}

type SecurityCenterSettingSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  SecurityCenterSettingHits `json:"hits"`
}

type SecurityCenterSettingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityCenterSettingPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityCenterSettingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_security_settings", filters, limit)
	if err != nil {
		return SecurityCenterSettingPaginator{}, err
	}

	p := SecurityCenterSettingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityCenterSettingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityCenterSettingPaginator) NextPage(ctx context.Context) ([]SecurityCenterSetting, error) {
	var response SecurityCenterSettingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterSetting
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterSettingFilters = map[string]string{
	"akas":             "description.Setting.ID",
	"enabled":          "dataExportSettingProperties.Enabled",
	"id":               "description.Setting.ID",
	"kaytu_account_id": "metadata.SourceID",
	"kind":             "description.Setting.Kind",
	"name":             "description.Setting.Name",
	"title":            "description.Setting.Name",
	"type":             "description.Setting.Type",
}

func ListSecurityCenterSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterSetting")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityCenterSettingPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityCenterSettingFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityCenterSettingFilters = map[string]string{
	"akas":             "description.Setting.ID",
	"enabled":          "dataExportSettingProperties.Enabled",
	"id":               "description.Setting.ID",
	"kaytu_account_id": "metadata.SourceID",
	"kind":             "description.Setting.Kind",
	"name":             "description.Setting.name",
	"title":            "description.Setting.Name",
	"type":             "description.Setting.Type",
}

func GetSecurityCenterSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterSetting")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterSettingPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityCenterSettingFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityCenterSetting =============================

// ==========================  START: SecurityCenterSubscriptionPricing =============================

type SecurityCenterSubscriptionPricing struct {
	Description   azure.SecurityCenterSubscriptionPricingDescription `json:"description"`
	Metadata      azure.Metadata                                     `json:"metadata"`
	ResourceJobID int                                                `json:"resource_job_id"`
	SourceJobID   int                                                `json:"source_job_id"`
	ResourceType  string                                             `json:"resource_type"`
	SourceType    string                                             `json:"source_type"`
	ID            string                                             `json:"id"`
	ARN           string                                             `json:"arn"`
	SourceID      string                                             `json:"source_id"`
}

type SecurityCenterSubscriptionPricingHit struct {
	ID      string                            `json:"_id"`
	Score   float64                           `json:"_score"`
	Index   string                            `json:"_index"`
	Type    string                            `json:"_type"`
	Version int64                             `json:"_version,omitempty"`
	Source  SecurityCenterSubscriptionPricing `json:"_source"`
	Sort    []interface{}                     `json:"sort"`
}

type SecurityCenterSubscriptionPricingHits struct {
	Total essdk.SearchTotal                      `json:"total"`
	Hits  []SecurityCenterSubscriptionPricingHit `json:"hits"`
}

type SecurityCenterSubscriptionPricingSearchResponse struct {
	PitID string                                `json:"pit_id"`
	Hits  SecurityCenterSubscriptionPricingHits `json:"hits"`
}

type SecurityCenterSubscriptionPricingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityCenterSubscriptionPricingPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityCenterSubscriptionPricingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_security_pricings", filters, limit)
	if err != nil {
		return SecurityCenterSubscriptionPricingPaginator{}, err
	}

	p := SecurityCenterSubscriptionPricingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityCenterSubscriptionPricingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityCenterSubscriptionPricingPaginator) NextPage(ctx context.Context) ([]SecurityCenterSubscriptionPricing, error) {
	var response SecurityCenterSubscriptionPricingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterSubscriptionPricing
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterSubscriptionPricingFilters = map[string]string{
	"akas":                      "description.Pricing.Name",
	"free_trial_remaining_time": "description.Pricing.PricingProperties.FreeTrialRemainingTime",
	"id":                        "description.Pricing.ID",
	"kaytu_account_id":          "metadata.SourceID",
	"name":                      "description.Pricing.Name",
	"pricing_tier":              "description.Pricing.PricingProperties.PricingTier",
	"title":                     "description.Pricing.Name",
	"type":                      "description.Pricing.Type",
}

func ListSecurityCenterSubscriptionPricing(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterSubscriptionPricing")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityCenterSubscriptionPricingPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityCenterSubscriptionPricingFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityCenterSubscriptionPricingFilters = map[string]string{
	"akas":                      "description.Pricing.Name",
	"free_trial_remaining_time": "description.Pricing.PricingProperties.FreeTrialRemainingTime",
	"id":                        "description.Pricing.ID",
	"kaytu_account_id":          "metadata.SourceID",
	"name":                      "description.Pricing.name",
	"pricing_tier":              "description.Pricing.PricingProperties.PricingTier",
	"title":                     "description.Pricing.Name",
	"type":                      "description.Pricing.Type",
}

func GetSecurityCenterSubscriptionPricing(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterSubscriptionPricing")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterSubscriptionPricingPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityCenterSubscriptionPricingFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityCenterSubscriptionPricing =============================

// ==========================  START: SecurityCenterAutomation =============================

type SecurityCenterAutomation struct {
	Description   azure.SecurityCenterAutomationDescription `json:"description"`
	Metadata      azure.Metadata                            `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type SecurityCenterAutomationHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  SecurityCenterAutomation `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type SecurityCenterAutomationHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []SecurityCenterAutomationHit `json:"hits"`
}

type SecurityCenterAutomationSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  SecurityCenterAutomationHits `json:"hits"`
}

type SecurityCenterAutomationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityCenterAutomationPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityCenterAutomationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_security_automations", filters, limit)
	if err != nil {
		return SecurityCenterAutomationPaginator{}, err
	}

	p := SecurityCenterAutomationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityCenterAutomationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityCenterAutomationPaginator) NextPage(ctx context.Context) ([]SecurityCenterAutomation, error) {
	var response SecurityCenterAutomationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterAutomation
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterAutomationFilters = map[string]string{
	"actions":          "description.Automation.AutomationProperties.Actions",
	"akas":             "description.Automation.ID",
	"description":      "description.Automation.AutomationProperties.Description",
	"etag":             "description.Automation.Etag",
	"id":               "description.Automation.ID",
	"is_enabled":       "description.Automation.AutomationProperties.IsEnabled",
	"kaytu_account_id": "metadata.SourceID",
	"kind":             "description.Automation.Kind",
	"name":             "description.Automation.Name",
	"region":           "description.Automation.Location",
	"resource_group":   "description.ResourceGroup",
	"scopes":           "description.Automation.AutomationProperties.Scopes",
	"sources":          "description.Automation.AutomationProperties.Sources",
	"tags":             "description.Automation.Tags",
	"title":            "description.Automation.Name",
	"type":             "description.Automation.Type",
}

func ListSecurityCenterAutomation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterAutomation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityCenterAutomationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityCenterAutomationFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityCenterAutomationFilters = map[string]string{
	"actions":          "description.Automation.AutomationProperties.Actions",
	"akas":             "description.Automation.ID",
	"description":      "description.Automation.AutomationProperties.Description",
	"etag":             "description.Automation.Etag",
	"id":               "description.Automation.ID",
	"is_enabled":       "description.Automation.AutomationProperties.IsEnabled",
	"kaytu_account_id": "metadata.SourceID",
	"kind":             "description.Automation.Kind",
	"name":             "description.Automation.name",
	"region":           "description.Automation.Location",
	"resource_group":   "description.ResourceGroup",
	"scopes":           "description.Automation.AutomationProperties.Scopes",
	"sources":          "description.Automation.AutomationProperties.Sources",
	"tags":             "description.Automation.Tags",
	"title":            "description.Automation.Name",
	"type":             "description.Automation.Type",
}

func GetSecurityCenterAutomation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterAutomation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterAutomationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityCenterAutomationFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityCenterAutomation =============================

// ==========================  START: SecurityCenterSubAssessment =============================

type SecurityCenterSubAssessment struct {
	Description   azure.SecurityCenterSubAssessmentDescription `json:"description"`
	Metadata      azure.Metadata                               `json:"metadata"`
	ResourceJobID int                                          `json:"resource_job_id"`
	SourceJobID   int                                          `json:"source_job_id"`
	ResourceType  string                                       `json:"resource_type"`
	SourceType    string                                       `json:"source_type"`
	ID            string                                       `json:"id"`
	ARN           string                                       `json:"arn"`
	SourceID      string                                       `json:"source_id"`
}

type SecurityCenterSubAssessmentHit struct {
	ID      string                      `json:"_id"`
	Score   float64                     `json:"_score"`
	Index   string                      `json:"_index"`
	Type    string                      `json:"_type"`
	Version int64                       `json:"_version,omitempty"`
	Source  SecurityCenterSubAssessment `json:"_source"`
	Sort    []interface{}               `json:"sort"`
}

type SecurityCenterSubAssessmentHits struct {
	Total essdk.SearchTotal                `json:"total"`
	Hits  []SecurityCenterSubAssessmentHit `json:"hits"`
}

type SecurityCenterSubAssessmentSearchResponse struct {
	PitID string                          `json:"pit_id"`
	Hits  SecurityCenterSubAssessmentHits `json:"hits"`
}

type SecurityCenterSubAssessmentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSecurityCenterSubAssessmentPaginator(filters []essdk.BoolFilter, limit *int64) (SecurityCenterSubAssessmentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_security_subassessments", filters, limit)
	if err != nil {
		return SecurityCenterSubAssessmentPaginator{}, err
	}

	p := SecurityCenterSubAssessmentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SecurityCenterSubAssessmentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SecurityCenterSubAssessmentPaginator) NextPage(ctx context.Context) ([]SecurityCenterSubAssessment, error) {
	var response SecurityCenterSubAssessmentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SecurityCenterSubAssessment
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSecurityCenterSubAssessmentFilters = map[string]string{
	"akas":             "description.SubAssessment.ID",
	"category":         "description.SubAssessment.SubAssessmentProperties.Category",
	"description":      "description.SubAssessment.SubAssessmentProperties.Description",
	"display_name":     "description.SubAssessment.SubAssessmentProperties.DisplayName",
	"id":               "description.SubAssessment.ID",
	"impact":           "description.SubAssessment.SubAssessmentProperties.Impact",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.SubAssessment.Name",
	"remediation":      "description.SubAssessment.SubAssessmentProperties.Remediation",
	"resource_group":   "description.ResourceGroup",
	"time_generated":   "description.SubAssessment.SubAssessmentProperties.TimeGenerated",
	"title":            "description.SubAssessment.Name",
	"type":             "description.SubAssessment.Type",
}

func ListSecurityCenterSubAssessment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSecurityCenterSubAssessment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSecurityCenterSubAssessmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSecurityCenterSubAssessmentFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSecurityCenterSubAssessmentFilters = map[string]string{
	"akas":             "description.SubAssessment.ID",
	"category":         "description.SubAssessment.SubAssessmentProperties.Category",
	"description":      "description.SubAssessment.SubAssessmentProperties.Description",
	"display_name":     "description.SubAssessment.SubAssessmentProperties.DisplayName",
	"id":               "description.SubAssessment.ID",
	"impact":           "description.SubAssessment.SubAssessmentProperties.Impact",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.SubAssessment.Name",
	"remediation":      "description.SubAssessment.SubAssessmentProperties.Remediation",
	"resource_group":   "description.ResourceGroup",
	"time_generated":   "description.SubAssessment.SubAssessmentProperties.TimeGenerated",
	"title":            "description.SubAssessment.Name",
	"type":             "description.SubAssessment.Type",
}

func GetSecurityCenterSubAssessment(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSecurityCenterSubAssessment")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSecurityCenterSubAssessmentPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSecurityCenterSubAssessmentFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SecurityCenterSubAssessment =============================

// ==========================  START: StorageContainer =============================

type StorageContainer struct {
	Description   azure.StorageContainerDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type StorageContainerHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  StorageContainer `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type StorageContainerHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []StorageContainerHit `json:"hits"`
}

type StorageContainerSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  StorageContainerHits `json:"hits"`
}

type StorageContainerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageContainerPaginator(filters []essdk.BoolFilter, limit *int64) (StorageContainerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_storageaccounts_blobservices_containers", filters, limit)
	if err != nil {
		return StorageContainerPaginator{}, err
	}

	p := StorageContainerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageContainerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageContainerPaginator) NextPage(ctx context.Context) ([]StorageContainer, error) {
	var response StorageContainerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageContainer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageContainerFilters = map[string]string{
	"account_name":                   "description.AccountName",
	"akas":                           "description.ListContainerItem.ID",
	"default_encryption_scope":       "description.ListContainerItem.ContainerProperties.DefaultEncryptionScope",
	"deleted":                        "description.ListContainerItem.ContainerProperties.Deleted",
	"deleted_time":                   "description.ListContainerItem.ContainerProperties.DeletedTime",
	"deny_encryption_scope_override": "description.ListContainerItem.ContainerProperties.DenyEncryptionScopeOverride",
	"has_immutability_policy":        "description.ListContainerItem.ContainerProperties.HasImmutabilityPolicy",
	"has_legal_hold":                 "description.ListContainerItem.ContainerProperties.HasLegalHold",
	"id":                             "description.ListContainerItem.ID",
	"immutability_policy":            "description.ImmutabilityPolicy",
	"kaytu_account_id":               "metadata.SourceID",
	"last_modified_time":             "description.ListContainerItem.ContainerProperties.LastModifiedTime",
	"lease_duration":                 "description.ListContainerItem.ContainerProperties.LeaseDuration",
	"lease_state":                    "description.ListContainerItem.ContainerProperties.LeaseState",
	"lease_status":                   "description.ListContainerItem.ContainerProperties.LeaseStatus",
	"legal_hold":                     "description.ListContainerItem.ContainerProperties.LegalHold",
	"metadata":                       "description.ListContainerItem.ContainerProperties.Metadata",
	"name":                           "description.ListContainerItem.Name",
	"public_access":                  "description.ListContainerItem.ContainerProperties.PublicAccess",
	"remaining_retention_days":       "description.ListContainerItem.ContainerProperties.RemainingRetentionDays",
	"resource_group":                 "description.ResourceGroup",
	"title":                          "description.ListContainerItem.Name",
	"type":                           "description.ListContainerItem.Type",
	"version":                        "description.ListContainerItem.ContainerProperties.Version",
}

func ListStorageContainer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageContainer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStorageContainerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listStorageContainerFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStorageContainerFilters = map[string]string{
	"account_name":                   "description.AccountName",
	"akas":                           "description.ListContainerItem.ID",
	"default_encryption_scope":       "description.ListContainerItem.ContainerProperties.DefaultEncryptionScope",
	"deleted":                        "description.ListContainerItem.ContainerProperties.Deleted",
	"deleted_time":                   "description.ListContainerItem.ContainerProperties.DeletedTime",
	"deny_encryption_scope_override": "description.ListContainerItem.ContainerProperties.DenyEncryptionScopeOverride",
	"has_immutability_policy":        "description.ListContainerItem.ContainerProperties.HasImmutabilityPolicy",
	"has_legal_hold":                 "description.ListContainerItem.ContainerProperties.HasLegalHold",
	"id":                             "description.ListContainerItem.ID",
	"immutability_policy":            "description.ImmutabilityPolicy",
	"kaytu_account_id":               "metadata.SourceID",
	"last_modified_time":             "description.ListContainerItem.ContainerProperties.LastModifiedTime",
	"lease_duration":                 "description.ListContainerItem.ContainerProperties.LeaseDuration",
	"lease_state":                    "description.ListContainerItem.ContainerProperties.LeaseState",
	"lease_status":                   "description.ListContainerItem.ContainerProperties.LeaseStatus",
	"legal_hold":                     "description.ListContainerItem.ContainerProperties.LegalHold",
	"metadata":                       "description.ListContainerItem.ContainerProperties.Metadata",
	"name":                           "description.ListContainerItem.name",
	"public_access":                  "description.ListContainerItem.ContainerProperties.PublicAccess",
	"remaining_retention_days":       "description.ListContainerItem.ContainerProperties.RemainingRetentionDays",
	"resource_group":                 "description.ResourceGroup",
	"title":                          "description.ListContainerItem.Name",
	"type":                           "description.ListContainerItem.Type",
	"version":                        "description.ListContainerItem.ContainerProperties.Version",
}

func GetStorageContainer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageContainer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStorageContainerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getStorageContainerFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StorageContainer =============================

// ==========================  START: StorageBlob =============================

type StorageBlob struct {
	Description   azure.StorageBlobDescription `json:"description"`
	Metadata      azure.Metadata               `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type StorageBlobHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  StorageBlob   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StorageBlobHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []StorageBlobHit  `json:"hits"`
}

type StorageBlobSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  StorageBlobHits `json:"hits"`
}

type StorageBlobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageBlobPaginator(filters []essdk.BoolFilter, limit *int64) (StorageBlobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_blobs", filters, limit)
	if err != nil {
		return StorageBlobPaginator{}, err
	}

	p := StorageBlobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageBlobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageBlobPaginator) NextPage(ctx context.Context) ([]StorageBlob, error) {
	var response StorageBlobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageBlob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageBlobFilters = map[string]string{
	"access_tier":              "description.Blob.Properties.AccessTier",
	"access_tier_change_time":  "description.Blob.Properties.AccessTierChangeTime",
	"access_tier_inferred":     "description.Blob.Properties.AccessTierInferred",
	"archive_status":           "description.Blob.Properties.ArchiveStatus",
	"blob_sequence_number":     "description.Blob.Properties.BlobSequenceNumber",
	"blob_tag_set":             "description.Blob.BlobTags.BlobTagSet",
	"cache_control":            "description.Blob.Properties.CacheControl",
	"container_name":           "description.ContainerName",
	"content_disposition":      "description.Blob.Properties.ContentDisposition",
	"content_encoding":         "description.Blob.Properties.ContentEncoding",
	"content_language":         "description.Blob.Properties.ContentLanguage",
	"content_length":           "description.Blob.Properties.ContentLength",
	"content_md5":              "description.Blob.Properties.ContentMD5",
	"content_type":             "description.Blob.Properties.ContentType",
	"copy_completion_time":     "description.Blob.Properties.CopyCompletionTime",
	"copy_id":                  "description.Blob.Properties.CopyID",
	"copy_progress":            "description.Blob.Properties.CopyProgress",
	"copy_source":              "description.Blob.Properties.CopySource",
	"copy_status":              "description.Blob.Properties.CopyStatus",
	"copy_status_description":  "description.Blob.Properties.CopyStatusDescription",
	"creation_time":            "description.Blob.Properties.CreationTime",
	"deleted":                  "description.Blob.Deleted",
	"deleted_time":             "description.Blob.Properties.DeletedTime",
	"destination_snapshot":     "description.Blob.Properties.DestinationSnapshot",
	"encryption_key_sha256":    "description.Blob.Properties.CustomerProvidedKeySha256",
	"encryption_scope":         "description.Blob.Properties.EncryptionScope",
	"etag":                     "description.Blob.Properties.Etag",
	"incremental_copy":         "description.Blob.Properties.IncrementalCopy",
	"is_current_version":       "description.Blob.IsCurrentVersion",
	"is_sealed":                "description.Blob.Properties.IsSealed",
	"is_snapshot":              "description.IsSnapshot",
	"kaytu_account_id":         "metadata.SourceID",
	"last_modified":            "description.Blob.Properties.LastModified",
	"lease_duration":           "description.Blob.Properties.LeaseDuration",
	"lease_state":              "description.Blob.Properties.LeaseState",
	"lease_status":             "description.Blob.Properties.LeaseStatus",
	"metadata":                 "description.Blob.Metadata",
	"name":                     "description.Blob.Name",
	"region":                   "location",
	"remaining_retention_days": "description.Blob.Properties.RemainingRetentionDays",
	"resource_group":           "description.ResourceGroup",
	"server_encrypted":         "description.Blob.Properties.ServerEncrypted",
	"snapshot":                 "description.Blob.Snapshot",
	"storage_account_name":     "description.AccountName",
	"title":                    "description.Blob.Name",
	"type":                     "description.Blob.Properties.BlobType",
	"version_id":               "description.Blob.VersionID",
}

func ListStorageBlob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageBlob")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStorageBlobPaginator(essdk.BuildFilter(d.KeyColumnQuals, listStorageBlobFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStorageBlobFilters = map[string]string{
	"access_tier":              "description.Blob.Properties.AccessTier",
	"access_tier_change_time":  "description.Blob.Properties.AccessTierChangeTime",
	"access_tier_inferred":     "description.Blob.Properties.AccessTierInferred",
	"archive_status":           "description.Blob.Properties.ArchiveStatus",
	"blob_sequence_number":     "description.Blob.Properties.BlobSequenceNumber",
	"blob_tag_set":             "description.Blob.BlobTags.BlobTagSet",
	"cache_control":            "description.Blob.Properties.CacheControl",
	"container_name":           "description.ContainerName",
	"content_disposition":      "description.Blob.Properties.ContentDisposition",
	"content_encoding":         "description.Blob.Properties.ContentEncoding",
	"content_language":         "description.Blob.Properties.ContentLanguage",
	"content_length":           "description.Blob.Properties.ContentLength",
	"content_md5":              "description.Blob.Properties.ContentMD5",
	"content_type":             "description.Blob.Properties.ContentType",
	"copy_completion_time":     "description.Blob.Properties.CopyCompletionTime",
	"copy_id":                  "description.Blob.Properties.CopyID",
	"copy_progress":            "description.Blob.Properties.CopyProgress",
	"copy_source":              "description.Blob.Properties.CopySource",
	"copy_status":              "description.Blob.Properties.CopyStatus",
	"copy_status_description":  "description.Blob.Properties.CopyStatusDescription",
	"creation_time":            "description.Blob.Properties.CreationTime",
	"deleted":                  "description.Blob.Deleted",
	"deleted_time":             "description.Blob.Properties.DeletedTime",
	"destination_snapshot":     "description.Blob.Properties.DestinationSnapshot",
	"encryption_key_sha256":    "description.Blob.Properties.CustomerProvidedKeySha256",
	"encryption_scope":         "description.Blob.Properties.EncryptionScope",
	"etag":                     "description.Blob.Properties.Etag",
	"incremental_copy":         "description.Blob.Properties.IncrementalCopy",
	"is_current_version":       "description.Blob.IsCurrentVersion",
	"is_sealed":                "description.Blob.Properties.IsSealed",
	"is_snapshot":              "description.IsSnapshot",
	"kaytu_account_id":         "metadata.SourceID",
	"last_modified":            "description.Blob.Properties.LastModified",
	"lease_duration":           "description.Blob.Properties.LeaseDuration",
	"lease_state":              "description.Blob.Properties.LeaseState",
	"lease_status":             "description.Blob.Properties.LeaseStatus",
	"metadata":                 "description.Blob.Metadata",
	"name":                     "description.Blob.Name",
	"region":                   "location",
	"remaining_retention_days": "description.Blob.Properties.RemainingRetentionDays",
	"resource_group":           "description.ResourceGroup",
	"server_encrypted":         "description.Blob.Properties.ServerEncrypted",
	"snapshot":                 "description.Blob.Snapshot",
	"storage_account_name":     "description.AccountName",
	"title":                    "description.Blob.Name",
	"type":                     "description.Blob.Properties.BlobType",
	"version_id":               "description.Blob.VersionID",
}

func GetStorageBlob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageBlob")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStorageBlobPaginator(essdk.BuildFilter(d.KeyColumnQuals, getStorageBlobFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StorageBlob =============================

// ==========================  START: StorageBlobService =============================

type StorageBlobService struct {
	Description   azure.StorageBlobServiceDescription `json:"description"`
	Metadata      azure.Metadata                      `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type StorageBlobServiceHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  StorageBlobService `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type StorageBlobServiceHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []StorageBlobServiceHit `json:"hits"`
}

type StorageBlobServiceSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  StorageBlobServiceHits `json:"hits"`
}

type StorageBlobServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageBlobServicePaginator(filters []essdk.BoolFilter, limit *int64) (StorageBlobServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_blobservives", filters, limit)
	if err != nil {
		return StorageBlobServicePaginator{}, err
	}

	p := StorageBlobServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageBlobServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageBlobServicePaginator) NextPage(ctx context.Context) ([]StorageBlobService, error) {
	var response StorageBlobServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageBlobService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageBlobServiceFilters = map[string]string{
	"akas":                              "description.BlobService.ID",
	"automatic_snapshot_policy_enabled": "description.BlobService.BlobServicePropertiesProperties.AutomaticSnapshotPolicyEnabled",
	"change_feed_enabled":               "description.BlobService.BlobServicePropertiesProperties.ChangeFeed.Enabled",
	"container_delete_retention_policy": "description.BlobService.BlobServicePropertiesProperties.ContainerDeleteRetentionPolicy",
	"cors_rules":                        "description.BlobService.BlobServicePropertiesProperties.Cors.CorsRules",
	"default_service_version":           "description.BlobService.BlobServicePropertiesProperties.DefaultServiceVersion",
	"delete_retention_policy":           "description.BlobService.BlobServicePropertiesProperties.DeleteRetentionPolicy",
	"id":                                "description.BlobService.ID",
	"is_versioning_enabled":             "description.BlobService.BlobServicePropertiesProperties.IsVersioningEnabled",
	"kaytu_account_id":                  "metadata.SourceID",
	"name":                              "description.BlobService.Name",
	"region":                            "description.Location",
	"resource_group":                    "description.ResourceGroup",
	"restore_policy":                    "description.BlobService.BlobServicePropertiesProperties.RestorePolicy",
	"sku_name":                          "description.BlobService.Sku.Name",
	"sku_tier":                          "description.BlobService.Sku.Tier",
	"storage_account_name":              "description.AccountName",
	"title":                             "description.BlobService.Name",
	"type":                              "description.BlobService.Type",
}

func ListStorageBlobService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageBlobService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStorageBlobServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, listStorageBlobServiceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStorageBlobServiceFilters = map[string]string{
	"akas":                              "description.BlobService.ID",
	"automatic_snapshot_policy_enabled": "description.BlobService.BlobServicePropertiesProperties.AutomaticSnapshotPolicyEnabled",
	"change_feed_enabled":               "description.BlobService.BlobServicePropertiesProperties.ChangeFeed.Enabled",
	"container_delete_retention_policy": "description.BlobService.BlobServicePropertiesProperties.ContainerDeleteRetentionPolicy",
	"cors_rules":                        "description.BlobService.BlobServicePropertiesProperties.Cors.CorsRules",
	"default_service_version":           "description.BlobService.BlobServicePropertiesProperties.DefaultServiceVersion",
	"delete_retention_policy":           "description.BlobService.BlobServicePropertiesProperties.DeleteRetentionPolicy",
	"id":                                "description.BlobService.ID",
	"is_versioning_enabled":             "description.BlobService.BlobServicePropertiesProperties.IsVersioningEnabled",
	"kaytu_account_id":                  "metadata.SourceID",
	"name":                              "description.BlobService.Name",
	"region":                            "description.Location",
	"resource_group":                    "description.ResourceGroup",
	"restore_policy":                    "description.BlobService.BlobServicePropertiesProperties.RestorePolicy",
	"sku_name":                          "description.BlobService.Sku.Name",
	"sku_tier":                          "description.BlobService.Sku.Tier",
	"storage_account_name":              "description.AccountName",
	"title":                             "description.BlobService.Name",
	"type":                              "description.BlobService.Type",
}

func GetStorageBlobService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageBlobService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStorageBlobServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, getStorageBlobServiceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StorageBlobService =============================

// ==========================  START: StorageQueue =============================

type StorageQueue struct {
	Description   azure.StorageQueueDescription `json:"description"`
	Metadata      azure.Metadata                `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type StorageQueueHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  StorageQueue  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StorageQueueHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []StorageQueueHit `json:"hits"`
}

type StorageQueueSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  StorageQueueHits `json:"hits"`
}

type StorageQueuePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageQueuePaginator(filters []essdk.BoolFilter, limit *int64) (StorageQueuePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_queues", filters, limit)
	if err != nil {
		return StorageQueuePaginator{}, err
	}

	p := StorageQueuePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageQueuePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageQueuePaginator) NextPage(ctx context.Context) ([]StorageQueue, error) {
	var response StorageQueueSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageQueue
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageQueueFilters = map[string]string{
	"akas":                 "description.Queue.ID",
	"id":                   "description.Queue.ID",
	"kaytu_account_id":     "metadata.SourceID",
	"metadata":             "description.Queue.ListQueueProperties.Metadata",
	"name":                 "description.Queue.Name",
	"region":               "description.Location",
	"resource_group":       "description.ResourceGroup",
	"storage_account_name": "description.AccountName",
	"title":                "description.Queue.Name",
	"type":                 "description.Queue.Type",
}

func ListStorageQueue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageQueue")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStorageQueuePaginator(essdk.BuildFilter(d.KeyColumnQuals, listStorageQueueFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStorageQueueFilters = map[string]string{
	"akas":                 "description.Queue.ID",
	"id":                   "description.Queue.ID",
	"kaytu_account_id":     "metadata.SourceID",
	"metadata":             "description.Queue.ListQueueProperties.Metadata",
	"name":                 "description.Queue.Name",
	"region":               "description.Location",
	"resource_group":       "description.ResourceGroup",
	"storage_account_name": "description.AccountName",
	"title":                "description.Queue.Name",
	"type":                 "description.Queue.Type",
}

func GetStorageQueue(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageQueue")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStorageQueuePaginator(essdk.BuildFilter(d.KeyColumnQuals, getStorageQueueFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StorageQueue =============================

// ==========================  START: StorageFileShare =============================

type StorageFileShare struct {
	Description   azure.StorageFileShareDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type StorageFileShareHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  StorageFileShare `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type StorageFileShareHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []StorageFileShareHit `json:"hits"`
}

type StorageFileShareSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  StorageFileShareHits `json:"hits"`
}

type StorageFileSharePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageFileSharePaginator(filters []essdk.BoolFilter, limit *int64) (StorageFileSharePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_fileshares", filters, limit)
	if err != nil {
		return StorageFileSharePaginator{}, err
	}

	p := StorageFileSharePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageFileSharePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageFileSharePaginator) NextPage(ctx context.Context) ([]StorageFileShare, error) {
	var response StorageFileShareSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageFileShare
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageFileShareFilters = map[string]string{
	"access_tier":              "description.FileShare.FileShareProperties.AccessTier",
	"access_tier_change_time":  "description.FileShare.FileShareProperties.AccessTierChangeTime",
	"access_tier_status":       "description.FileShare.FileShareProperties.AccessTierStatus",
	"akas":                     "description.FileShare.ID",
	"deleted":                  "description.FileShare.FileShareProperties.Deleted",
	"deleted_time":             "description.FileShare.FileShareProperties.DeletedTime",
	"enabled_protocols":        "description.FileShare.FileShareProperties.EnabledProtocols",
	"id":                       "description.FileShare.ID",
	"kaytu_account_id":         "metadata.SourceID",
	"last_modified_time":       "description.FileShare.FileShareProperties.LastModifiedTime",
	"metadata":                 "description.FileShare.FileShareProperties.Metadata",
	"name":                     "description.FileShare.Name",
	"remaining_retention_days": "description.FileShare.FileShareProperties.RemainingRetentionDays",
	"resource_group":           "description.ResourceGroup",
	"root_squash":              "description.FileShare.FileShareProperties.RootSquash",
	"share_quota":              "description.FileShare.FileShareProperties.ShareQuota",
	"share_usage_bytes":        "description.FileShare.FileShareProperties.ShareUsageBytes",
	"storage_account_name":     "description.AccountName",
	"title":                    "description.FileShare.Name",
	"type":                     "description.FileShare.Type",
	"version":                  "description.FileShare.FileShareProperties.Version",
}

func ListStorageFileShare(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageFileShare")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStorageFileSharePaginator(essdk.BuildFilter(d.KeyColumnQuals, listStorageFileShareFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStorageFileShareFilters = map[string]string{
	"access_tier":              "description.FileShare.FileShareProperties.AccessTier",
	"access_tier_change_time":  "description.FileShare.FileShareProperties.AccessTierChangeTime",
	"access_tier_status":       "description.FileShare.FileShareProperties.AccessTierStatus",
	"akas":                     "description.FileShare.ID",
	"deleted":                  "description.FileShare.FileShareProperties.Deleted",
	"deleted_time":             "description.FileShare.FileShareProperties.DeletedTime",
	"enabled_protocols":        "description.FileShare.FileShareProperties.EnabledProtocols",
	"id":                       "description.FileShare.ID",
	"kaytu_account_id":         "metadata.SourceID",
	"last_modified_time":       "description.FileShare.FileShareProperties.LastModifiedTime",
	"metadata":                 "description.FileShare.FileShareProperties.Metadata",
	"name":                     "description.FileShare.Name",
	"remaining_retention_days": "description.FileShare.FileShareProperties.RemainingRetentionDays",
	"resource_group":           "description.ResourceGroup",
	"root_squash":              "description.FileShare.FileShareProperties.RootSquash",
	"share_quota":              "description.FileShare.FileShareProperties.ShareQuota",
	"share_usage_bytes":        "description.FileShare.FileShareProperties.ShareUsageBytes",
	"storage_account_name":     "description.AccountName",
	"title":                    "description.FileShare.Name",
	"type":                     "description.FileShare.Type",
	"version":                  "description.FileShare.FileShareProperties.Version",
}

func GetStorageFileShare(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageFileShare")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStorageFileSharePaginator(essdk.BuildFilter(d.KeyColumnQuals, getStorageFileShareFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StorageFileShare =============================

// ==========================  START: StorageTable =============================

type StorageTable struct {
	Description   azure.StorageTableDescription `json:"description"`
	Metadata      azure.Metadata                `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type StorageTableHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  StorageTable  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StorageTableHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []StorageTableHit `json:"hits"`
}

type StorageTableSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  StorageTableHits `json:"hits"`
}

type StorageTablePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageTablePaginator(filters []essdk.BoolFilter, limit *int64) (StorageTablePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_tables", filters, limit)
	if err != nil {
		return StorageTablePaginator{}, err
	}

	p := StorageTablePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageTablePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageTablePaginator) NextPage(ctx context.Context) ([]StorageTable, error) {
	var response StorageTableSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageTable
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageTableFilters = map[string]string{
	"akas":                 "description.Table.ID",
	"id":                   "description.Table.ID",
	"kaytu_account_id":     "metadata.SourceID",
	"name":                 "description.Table.Name",
	"region":               "description.Location",
	"resource_group":       "description.ResourceGroup",
	"storage_account_name": "description.AccountName",
	"title":                "description.Table.Name",
	"type":                 "description.Table.Type",
}

func ListStorageTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStorageTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, listStorageTableFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStorageTableFilters = map[string]string{
	"akas":                 "description.Table.ID",
	"id":                   "description.Table.ID",
	"kaytu_account_id":     "metadata.SourceID",
	"name":                 "description.Table.Name",
	"region":               "description.Location",
	"resource_group":       "description.ResourceGroup",
	"storage_account_name": "description.AccountName",
	"title":                "description.Table.Name",
	"type":                 "description.Table.Type",
}

func GetStorageTable(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageTable")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStorageTablePaginator(essdk.BuildFilter(d.KeyColumnQuals, getStorageTableFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StorageTable =============================

// ==========================  START: StorageTableService =============================

type StorageTableService struct {
	Description   azure.StorageTableServiceDescription `json:"description"`
	Metadata      azure.Metadata                       `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type StorageTableServiceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  StorageTableService `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type StorageTableServiceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []StorageTableServiceHit `json:"hits"`
}

type StorageTableServiceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  StorageTableServiceHits `json:"hits"`
}

type StorageTableServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageTableServicePaginator(filters []essdk.BoolFilter, limit *int64) (StorageTableServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_tableservices", filters, limit)
	if err != nil {
		return StorageTableServicePaginator{}, err
	}

	p := StorageTableServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageTableServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageTableServicePaginator) NextPage(ctx context.Context) ([]StorageTableService, error) {
	var response StorageTableServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageTableService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageTableServiceFilters = map[string]string{
	"akas":                 "description.TableService.ID",
	"cors_rules":           "description.TableService.TableServicePropertiesProperties.Cors.CorsRules",
	"id":                   "description.TableService.ID",
	"kaytu_account_id":     "metadata.SourceID",
	"name":                 "description.TableService.Name",
	"region":               "description.Location",
	"resource_group":       "description.ResourceGroup",
	"storage_account_name": "description.AccountName",
	"title":                "description.TableService.Name",
	"type":                 "description.TableService.Type",
}

func ListStorageTableService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageTableService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStorageTableServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, listStorageTableServiceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStorageTableServiceFilters = map[string]string{
	"akas":                 "description.TableService.ID",
	"cors_rules":           "description.TableService.TableServicePropertiesProperties.Cors.CorsRules",
	"id":                   "description.TableService.ID",
	"kaytu_account_id":     "metadata.SourceID",
	"name":                 "description.TableService.Name",
	"region":               "description.Location",
	"resource_group":       "description.ResourceGroup",
	"storage_account_name": "description.AccountName",
	"title":                "description.TableService.Name",
	"type":                 "description.TableService.Type",
}

func GetStorageTableService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageTableService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStorageTableServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, getStorageTableServiceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StorageTableService =============================

// ==========================  START: Subnet =============================

type Subnet struct {
	Description   azure.SubnetDescription `json:"description"`
	Metadata      azure.Metadata          `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type SubnetHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Subnet        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SubnetHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SubnetHit       `json:"hits"`
}

type SubnetSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  SubnetHits `json:"hits"`
}

type SubnetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSubnetPaginator(filters []essdk.BoolFilter, limit *int64) (SubnetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_virtualnetworks_subnets", filters, limit)
	if err != nil {
		return SubnetPaginator{}, err
	}

	p := SubnetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SubnetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SubnetPaginator) NextPage(ctx context.Context) ([]Subnet, error) {
	var response SubnetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Subnet
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSubnetFilters = map[string]string{
	"address_prefix":                        "description.Subnet.SubnetPropertiesFormat.AddressPrefix",
	"akas":                                  "description.Subnet.ID",
	"delegations":                           "description.Subnet.SubnetPropertiesFormat.Delegations",
	"etag":                                  "description.Subnet.Etag",
	"id":                                    "subnet.ID",
	"kaytu_account_id":                      "metadata.SourceID",
	"name":                                  "description.Subnet.Name",
	"nat_gateway_id":                        "description.Subnet.SubnetPropertiesFormat.NatGateway.ID",
	"network_security_group_id":             "description.Subnet.SubnetPropertiesFormat.NetworkSecurityGroup.ID",
	"private_endpoint_network_policies":     "description.Subnet.SubnetPropertiesFormat.PrivateEndpointNetworkPolicies",
	"private_link_service_network_policies": "description.Subnet.SubnetPropertiesFormat.PrivateLinkServiceNetworkPolicies",
	"provisioning_state":                    "description.Subnet.SubnetPropertiesFormat.ProvisioningState",
	"resource_group":                        "description.ResourceGroup",
	"route_table_id":                        "description.Subnet.SubnetPropertiesFormat.RouteTable.ID",
	"service_endpoint_policies":             "description.Subnet.SubnetPropertiesFormat.ServiceEndpointPolicies",
	"service_endpoints":                     "description.Subnet.SubnetPropertiesFormat.ServiceEndpoints",
	"title":                                 "description.Subnet.Name",
	"type":                                  "description.Subnet.SubnetPropertiesFormat.RouteTable.Type",
	"virtual_network_name":                  "description.VirtualNetworkName",
}

func ListSubnet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSubnet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSubnetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSubnetFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSubnetFilters = map[string]string{
	"address_prefix":                        "description.Subnet.SubnetPropertiesFormat.AddressPrefix",
	"akas":                                  "description.Subnet.ID",
	"delegations":                           "description.Subnet.SubnetPropertiesFormat.Delegations",
	"etag":                                  "description.Subnet.Etag",
	"id":                                    "subnet.ID",
	"kaytu_account_id":                      "metadata.SourceID",
	"name":                                  "description.Subnet.name",
	"nat_gateway_id":                        "description.Subnet.SubnetPropertiesFormat.NatGateway.ID",
	"network_security_group_id":             "description.Subnet.SubnetPropertiesFormat.NetworkSecurityGroup.ID",
	"private_endpoint_network_policies":     "description.Subnet.SubnetPropertiesFormat.PrivateEndpointNetworkPolicies",
	"private_link_service_network_policies": "description.Subnet.SubnetPropertiesFormat.PrivateLinkServiceNetworkPolicies",
	"provisioning_state":                    "description.Subnet.SubnetPropertiesFormat.ProvisioningState",
	"resource_group":                        "description.ResourceGroup",
	"route_table_id":                        "description.Subnet.SubnetPropertiesFormat.RouteTable.ID",
	"service_endpoint_policies":             "description.Subnet.SubnetPropertiesFormat.ServiceEndpointPolicies",
	"service_endpoints":                     "description.Subnet.SubnetPropertiesFormat.ServiceEndpoints",
	"title":                                 "description.Subnet.Name",
	"type":                                  "description.Subnet.SubnetPropertiesFormat.RouteTable.Type",
	"virtual_network_name":                  "description.VirtualNetworkName",
}

func GetSubnet(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSubnet")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSubnetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSubnetFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Subnet =============================

// ==========================  START: VirtualNetwork =============================

type VirtualNetwork struct {
	Description   azure.VirtualNetworkDescription `json:"description"`
	Metadata      azure.Metadata                  `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type VirtualNetworkHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  VirtualNetwork `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type VirtualNetworkHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []VirtualNetworkHit `json:"hits"`
}

type VirtualNetworkSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  VirtualNetworkHits `json:"hits"`
}

type VirtualNetworkPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVirtualNetworkPaginator(filters []essdk.BoolFilter, limit *int64) (VirtualNetworkPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_virtualnetworks", filters, limit)
	if err != nil {
		return VirtualNetworkPaginator{}, err
	}

	p := VirtualNetworkPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VirtualNetworkPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VirtualNetworkPaginator) NextPage(ctx context.Context) ([]VirtualNetwork, error) {
	var response VirtualNetworkSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VirtualNetwork
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVirtualNetworkFilters = map[string]string{
	"address_prefixes":       "description.VirtualNetwork.VirtualNetworkPropertiesFormat.AddressSpace.AddressPrefixes",
	"akas":                   "description.VirtualNetwork.ID",
	"enable_ddos_protection": "description.VirtualNetwork.VirtualNetworkPropertiesFormat.EnableDdosProtection",
	"enable_vm_protection":   "description.VirtualNetwork.VirtualNetworkPropertiesFormat.EnableVMProtection",
	"etag":                   "description.VirtualNetwork.Etag",
	"id":                     "description.VirtualNetwork.ID",
	"kaytu_account_id":       "metadata.SourceID",
	"name":                   "description.VirtualNetwork.Name",
	"network_peerings":       "description.VirtualNetwork.VirtualNetworkPropertiesFormat.VirtualNetworkPeerings",
	"provisioning_state":     "description.VirtualNetwork.VirtualNetworkPropertiesFormat.ProvisioningState",
	"region":                 "description.VirtualNetwork.Location",
	"resource_group":         "description.ResourceGroup",
	"resource_guid":          "description.VirtualNetwork.VirtualNetworkPropertiesFormat.ResourceGUID",
	"subnets":                "description.VirtualNetwork.VirtualNetworkPropertiesFormat.Subnets",
	"tags":                   "description.VirtualNetwork.Tags",
	"title":                  "description.VirtualNetwork.Name",
	"type":                   "description.VirtualNetwork.Type",
}

func ListVirtualNetwork(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVirtualNetwork")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewVirtualNetworkPaginator(essdk.BuildFilter(d.KeyColumnQuals, listVirtualNetworkFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getVirtualNetworkFilters = map[string]string{
	"address_prefixes":       "description.VirtualNetwork.VirtualNetworkPropertiesFormat.AddressSpace.AddressPrefixes",
	"akas":                   "description.VirtualNetwork.ID",
	"enable_ddos_protection": "description.VirtualNetwork.VirtualNetworkPropertiesFormat.EnableDdosProtection",
	"enable_vm_protection":   "description.VirtualNetwork.VirtualNetworkPropertiesFormat.EnableVMProtection",
	"etag":                   "description.VirtualNetwork.Etag",
	"id":                     "description.VirtualNetwork.ID",
	"kaytu_account_id":       "metadata.SourceID",
	"name":                   "description.VirtualNetwork.name",
	"network_peerings":       "description.VirtualNetwork.VirtualNetworkPropertiesFormat.VirtualNetworkPeerings",
	"provisioning_state":     "description.VirtualNetwork.VirtualNetworkPropertiesFormat.ProvisioningState",
	"region":                 "description.VirtualNetwork.Location",
	"resource_group":         "description.ResourceGroup",
	"resource_guid":          "description.VirtualNetwork.VirtualNetworkPropertiesFormat.ResourceGUID",
	"subnets":                "description.VirtualNetwork.VirtualNetworkPropertiesFormat.Subnets",
	"tags":                   "description.VirtualNetwork.Tags",
	"title":                  "description.VirtualNetwork.Name",
	"type":                   "description.VirtualNetwork.Type",
}

func GetVirtualNetwork(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVirtualNetwork")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewVirtualNetworkPaginator(essdk.BuildFilter(d.KeyColumnQuals, getVirtualNetworkFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: VirtualNetwork =============================

// ==========================  START: Tenant =============================

type Tenant struct {
	Description   azure.TenantDescription `json:"description"`
	Metadata      azure.Metadata          `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type TenantHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Tenant        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type TenantHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []TenantHit       `json:"hits"`
}

type TenantSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  TenantHits `json:"hits"`
}

type TenantPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTenantPaginator(filters []essdk.BoolFilter, limit *int64) (TenantPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_tenants", filters, limit)
	if err != nil {
		return TenantPaginator{}, err
	}

	p := TenantPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TenantPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TenantPaginator) NextPage(ctx context.Context) ([]Tenant, error) {
	var response TenantSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Tenant
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTenantFilters = map[string]string{
	"akas":             "description.TenantIDDescription.ID",
	"country":          "description.TenantIDDescription.Country",
	"country_code":     "description.TenantIDDescription.CountryCode",
	"display_name":     "description.TenantIDDescription.DisplayName",
	"domains":          "description.TenantIDDescription.Domains",
	"id":               "description.TenantIDDescription.ID",
	"kaytu_account_id": "metadata.SourceID",
	"tenant_category":  "description.TenantIDDescription.TenantCategory",
	"tenant_id":        "description.TenantIDDescription",
}

func ListTenant(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTenant")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewTenantPaginator(essdk.BuildFilter(d.KeyColumnQuals, listTenantFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getTenantFilters = map[string]string{
	"akas":             "description.TenantIDDescription.ID",
	"country":          "description.TenantIDDescription.Country",
	"country_code":     "description.TenantIDDescription.CountryCode",
	"display_name":     "description.TenantIDDescription.DisplayName",
	"domains":          "description.TenantIDDescription.Domains",
	"id":               "description.TenantIDDescription.ID",
	"kaytu_account_id": "metadata.SourceID",
	"tenant_category":  "description.TenantIDDescription.TenantCategory",
	"tenant_id":        "description.TenantIDDescription",
}

func GetTenant(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTenant")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewTenantPaginator(essdk.BuildFilter(d.KeyColumnQuals, getTenantFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Tenant =============================

// ==========================  START: Subscription =============================

type Subscription struct {
	Description   azure.SubscriptionDescription `json:"description"`
	Metadata      azure.Metadata                `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type SubscriptionHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Subscription  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SubscriptionHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SubscriptionHit `json:"hits"`
}

type SubscriptionSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  SubscriptionHits `json:"hits"`
}

type SubscriptionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSubscriptionPaginator(filters []essdk.BoolFilter, limit *int64) (SubscriptionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_subscriptions", filters, limit)
	if err != nil {
		return SubscriptionPaginator{}, err
	}

	p := SubscriptionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SubscriptionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SubscriptionPaginator) NextPage(ctx context.Context) ([]Subscription, error) {
	var response SubscriptionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Subscription
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSubscriptionFilters = map[string]string{
	"akas":                  "description.Subscription.ID",
	"authorization_source":  "description.Subscription.AuthorizationSource",
	"cloud_environment":     "description.Subscription.TenantID",
	"display_name":          "description.Subscription.DisplayName",
	"id":                    "description.Subscription.ID",
	"kaytu_account_id":      "metadata.SourceID",
	"keibi_metadata":        "metadata",
	"managed_by_tenants":    "description.Subscription.ManagedByTenants",
	"state":                 "description.Subscription.State",
	"subscription_id":       "description.Subscription.SubscriptionID",
	"subscription_policies": "description.Subscription.SubscriptionPolicies",
	"tenant_id":             "description.Subscription.TenantID",
	"title":                 "description.Subscription.DisplayName",
}

func ListSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSubscription")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSubscriptionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSubscriptionFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSubscriptionFilters = map[string]string{
	"akas":                  "description.Subscription.ID",
	"authorization_source":  "description.Subscription.AuthorizationSource",
	"cloud_environment":     "description.Subscription.TenantID",
	"display_name":          "description.Subscription.DisplayName",
	"id":                    "description.Subscription.ID",
	"kaytu_account_id":      "metadata.SourceID",
	"keibi_metadata":        "metadata",
	"managed_by_tenants":    "description.Subscription.ManagedByTenants",
	"state":                 "description.Subscription.State",
	"subscription_id":       "description.Subscription.SubscriptionID",
	"subscription_policies": "description.Subscription.SubscriptionPolicies",
	"tenant_id":             "description.Subscription.TenantID",
	"title":                 "description.Subscription.DisplayName",
}

func GetSubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSubscription")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSubscriptionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSubscriptionFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Subscription =============================

// ==========================  START: ApplicationGateway =============================

type ApplicationGateway struct {
	Description   azure.ApplicationGatewayDescription `json:"description"`
	Metadata      azure.Metadata                      `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type ApplicationGatewayHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  ApplicationGateway `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type ApplicationGatewayHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []ApplicationGatewayHit `json:"hits"`
}

type ApplicationGatewaySearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  ApplicationGatewayHits `json:"hits"`
}

type ApplicationGatewayPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApplicationGatewayPaginator(filters []essdk.BoolFilter, limit *int64) (ApplicationGatewayPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_applicationgateways", filters, limit)
	if err != nil {
		return ApplicationGatewayPaginator{}, err
	}

	p := ApplicationGatewayPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApplicationGatewayPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApplicationGatewayPaginator) NextPage(ctx context.Context) ([]ApplicationGateway, error) {
	var response ApplicationGatewaySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApplicationGateway
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApplicationGatewayFilters = map[string]string{
	"akas":                                   "description.ApplicationGateway.ID",
	"autoscale_configuration":                "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.AutoscaleConfiguration",
	"custom_error_configurations":            "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.CustomErrorConfigurations",
	"diagnostic_settings":                    "description.DiagnosticSettingsResources",
	"enable_fips":                            "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.EnableFips",
	"enable_http2":                           "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.EnableHTTP2",
	"etag":                                   "description.ApplicationGateway.Etag",
	"firewall_policy":                        "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.FirewallPolicy",
	"force_firewall_policy_association":      "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.ForceFirewallPolicyAssociation",
	"id":                                     "description.ApplicationGateway.ID",
	"identity":                               "description.ApplicationGateway.Identity",
	"kaytu_account_id":                       "metadata.SourceID",
	"name":                                   "description.ApplicationGateway.Name",
	"operational_state":                      "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.OperationalState",
	"provisioning_state":                     "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.ProvisioningState",
	"redirect_configurations":                "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.RedirectConfigurations",
	"region":                                 "description.ApplicationGateway.Location",
	"resource_group":                         "description.ResourceGroup",
	"resource_guid":                          "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.ResourceGUID",
	"sku":                                    "applicationGatewayPropertiesFormat.Sku",
	"ssl_policy":                             "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.SslPolicy",
	"tags":                                   "description.ApplicationGateway.Tags",
	"title":                                  "description.ApplicationGateway.Name",
	"type":                                   "description.ApplicationGateway.Type",
	"web_application_firewall_configuration": "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.WebApplicationFirewallConfiguration",
	"zones":                                  "description.ApplicationGateway.Zones",
}

func ListApplicationGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApplicationGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewApplicationGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, listApplicationGatewayFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getApplicationGatewayFilters = map[string]string{
	"akas":                                   "description.ApplicationGateway.ID",
	"autoscale_configuration":                "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.AutoscaleConfiguration",
	"custom_error_configurations":            "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.CustomErrorConfigurations",
	"diagnostic_settings":                    "description.DiagnosticSettingsResources",
	"enable_fips":                            "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.EnableFips",
	"enable_http2":                           "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.EnableHTTP2",
	"etag":                                   "description.ApplicationGateway.Etag",
	"firewall_policy":                        "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.FirewallPolicy",
	"force_firewall_policy_association":      "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.ForceFirewallPolicyAssociation",
	"id":                                     "description.ApplicationGateway.ID",
	"identity":                               "description.ApplicationGateway.Identity",
	"kaytu_account_id":                       "metadata.SourceID",
	"name":                                   "description.ApplicationGateway.name",
	"operational_state":                      "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.OperationalState",
	"provisioning_state":                     "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.ProvisioningState",
	"redirect_configurations":                "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.RedirectConfigurations",
	"region":                                 "description.ApplicationGateway.Location",
	"resource_group":                         "description.ResourceGroup",
	"resource_guid":                          "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.ResourceGUID",
	"sku":                                    "applicationGatewayPropertiesFormat.Sku",
	"ssl_policy":                             "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.SslPolicy",
	"tags":                                   "description.ApplicationGateway.Tags",
	"title":                                  "description.ApplicationGateway.Name",
	"type":                                   "description.ApplicationGateway.Type",
	"web_application_firewall_configuration": "description.ApplicationGateway.ApplicationGatewayPropertiesFormat.WebApplicationFirewallConfiguration",
	"zones":                                  "description.ApplicationGateway.Zones",
}

func GetApplicationGateway(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApplicationGateway")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewApplicationGatewayPaginator(essdk.BuildFilter(d.KeyColumnQuals, getApplicationGatewayFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ApplicationGateway =============================

// ==========================  START: BatchAccount =============================

type BatchAccount struct {
	Description   azure.BatchAccountDescription `json:"description"`
	Metadata      azure.Metadata                `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type BatchAccountHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  BatchAccount  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type BatchAccountHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []BatchAccountHit `json:"hits"`
}

type BatchAccountSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  BatchAccountHits `json:"hits"`
}

type BatchAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewBatchAccountPaginator(filters []essdk.BoolFilter, limit *int64) (BatchAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_batch_batchaccounts", filters, limit)
	if err != nil {
		return BatchAccountPaginator{}, err
	}

	p := BatchAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p BatchAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p BatchAccountPaginator) NextPage(ctx context.Context) ([]BatchAccount, error) {
	var response BatchAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []BatchAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listBatchAccountFilters = map[string]string{
	"account_endpoint":                            "description.Account.AccountProperties.AccountEndpoint",
	"active_job_and_job_schedule_quota":           "description.Account.AccountProperties.ActiveJobAndJobScheduleQuota",
	"akas":                                        "description.Account.ID",
	"auto_storage":                                "description.Account.AccountProperties.AutoStorage",
	"dedicated_core_quota":                        "description.Account.AccountProperties.DedicatedCoreQuota",
	"dedicated_core_quota_per_vm_family":          "description.Account.AccountProperties.DedicatedCoreQuotaPerVMFamily",
	"dedicated_core_quota_per_vm_family_enforced": "description.Account.AccountProperties.DedicatedCoreQuotaPerVMFamilyEnforced",
	"diagnostic_settings":                         "description.DiagnosticSettingsResources",
	"encryption":                                  "description.Account.AccountProperties.Encryption",
	"id":                                          "description.Account.ID",
	"identity":                                    "description.Account.Identity",
	"kaytu_account_id":                            "metadata.SourceID",
	"key_vault_reference":                         "description.Account.AccountProperties.KeyVaultReference",
	"low_priority_core_quota":                     "description.Account.AccountProperties.LowPriorityCoreQuota",
	"name":                                        "description.Account.Name",
	"pool_allocation_mode":                        "description.Account.AccountProperties.PoolAllocationMode",
	"pool_quota":                                  "description.Account.AccountProperties.PoolQuota",
	"private_endpoint_connections":                "description.Account.AccountProperties.PrivateEndpointConnections",
	"provisioning_state":                          "description.Account.AccountProperties.ProvisioningState",
	"public_network_access":                       "description.Account.AccountProperties.PublicNetworkAccess",
	"region":                                      "description.Account.Location",
	"resource_group":                              "description.ResourceGroup",
	"tags":                                        "description.Account.Tags",
	"title":                                       "description.Account.Name",
	"type":                                        "description.Account.Type",
}

func ListBatchAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListBatchAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewBatchAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, listBatchAccountFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getBatchAccountFilters = map[string]string{
	"account_endpoint":                            "description.Account.AccountProperties.AccountEndpoint",
	"active_job_and_job_schedule_quota":           "description.Account.AccountProperties.ActiveJobAndJobScheduleQuota",
	"akas":                                        "description.Account.ID",
	"auto_storage":                                "description.Account.AccountProperties.AutoStorage",
	"dedicated_core_quota":                        "description.Account.AccountProperties.DedicatedCoreQuota",
	"dedicated_core_quota_per_vm_family":          "description.Account.AccountProperties.DedicatedCoreQuotaPerVMFamily",
	"dedicated_core_quota_per_vm_family_enforced": "description.Account.AccountProperties.DedicatedCoreQuotaPerVMFamilyEnforced",
	"diagnostic_settings":                         "description.DiagnosticSettingsResources",
	"encryption":                                  "description.Account.AccountProperties.Encryption",
	"id":                                          "description.Account.ID",
	"identity":                                    "description.Account.Identity",
	"kaytu_account_id":                            "metadata.SourceID",
	"key_vault_reference":                         "description.Account.AccountProperties.KeyVaultReference",
	"low_priority_core_quota":                     "description.Account.AccountProperties.LowPriorityCoreQuota",
	"name":                                        "description.Account.name",
	"pool_allocation_mode":                        "description.Account.AccountProperties.PoolAllocationMode",
	"pool_quota":                                  "description.Account.AccountProperties.PoolQuota",
	"private_endpoint_connections":                "description.Account.AccountProperties.PrivateEndpointConnections",
	"provisioning_state":                          "description.Account.AccountProperties.ProvisioningState",
	"public_network_access":                       "description.Account.AccountProperties.PublicNetworkAccess",
	"region":                                      "description.Account.Location",
	"resource_group":                              "description.ResourceGroup",
	"tags":                                        "description.Account.Tags",
	"title":                                       "description.Account.Name",
	"type":                                        "description.Account.Type",
}

func GetBatchAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetBatchAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewBatchAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, getBatchAccountFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: BatchAccount =============================

// ==========================  START: CognitiveAccount =============================

type CognitiveAccount struct {
	Description   azure.CognitiveAccountDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type CognitiveAccountHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  CognitiveAccount `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type CognitiveAccountHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []CognitiveAccountHit `json:"hits"`
}

type CognitiveAccountSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  CognitiveAccountHits `json:"hits"`
}

type CognitiveAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCognitiveAccountPaginator(filters []essdk.BoolFilter, limit *int64) (CognitiveAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_cognitiveservices_accounts", filters, limit)
	if err != nil {
		return CognitiveAccountPaginator{}, err
	}

	p := CognitiveAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CognitiveAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CognitiveAccountPaginator) NextPage(ctx context.Context) ([]CognitiveAccount, error) {
	var response CognitiveAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CognitiveAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCognitiveAccountFilters = map[string]string{
	"akas":                             "description.Account.ID",
	"allowed_fqdn_list":                "description.Account.Properties.AllowedFqdnList",
	"api_properties":                   "description.Account.Properties.APIProperties",
	"call_rate_limit":                  "description.Account.Properties.CallRateLimit",
	"capabilities":                     "description.Account.Properties.Capabilities",
	"custom_sub_domain_name":           "description.Account.Properties.CustomSubDomainName",
	"date_created":                     "description.Account.Properties.DateCreated",
	"diagnostic_settings":              "description.DiagnosticSettingsResources",
	"disable_local_auth":               "description.Account.Properties.DisableLocalAuth",
	"encryption":                       "description.Account.Properties.Encryption",
	"endpoint":                         "description.Account.Properties.Endpoint",
	"endpoints":                        "description.Account.Properties.Endpoints",
	"etag":                             "description.Account.Etag",
	"id":                               "description.Account.ID",
	"identity":                         "description.Account.Identity",
	"is_migrated":                      "description.Account.Properties.IsMigrated",
	"kaytu_account_id":                 "metadata.SourceID",
	"kind":                             "description.Account.Kind",
	"migration_token":                  "description.Account.Properties.MigrationToken",
	"name":                             "description.Account.Name",
	"network_acls":                     "description.Account.Properties.NetworkAcls",
	"provisioning_state":               "description.Account.Properties.ProvisioningState",
	"public_network_access":            "description.Account.Properties.PublicNetworkAccess",
	"quota_limit":                      "description.Account.Properties.QuotaLimit",
	"region":                           "description.Account.Location",
	"resource_group":                   "description.ResourceGroup",
	"restore":                          "description.Account.Properties.Restore",
	"restrict_outbound_network_access": "description.Account.Properties.RestrictOutboundNetworkAccess",
	"sku":                              "description.Account.Sku",
	"sku_change_info":                  "description.Account.Properties.SkuChangeInfo",
	"system_data":                      "description.Account.SystemData",
	"tags":                             "description.Account.Tags",
	"title":                            "description.Account.Name",
	"type":                             "description.Account.Type",
	"user_owned_storage":               "description.Account.Properties.UserOwnedStorage",
}

func ListCognitiveAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCognitiveAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCognitiveAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCognitiveAccountFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCognitiveAccountFilters = map[string]string{
	"akas":                             "description.Account.ID",
	"allowed_fqdn_list":                "description.Account.Properties.AllowedFqdnList",
	"api_properties":                   "description.Account.Properties.APIProperties",
	"call_rate_limit":                  "description.Account.Properties.CallRateLimit",
	"capabilities":                     "description.Account.Properties.Capabilities",
	"custom_sub_domain_name":           "description.Account.Properties.CustomSubDomainName",
	"date_created":                     "description.Account.Properties.DateCreated",
	"diagnostic_settings":              "description.DiagnosticSettingsResources",
	"disable_local_auth":               "description.Account.Properties.DisableLocalAuth",
	"encryption":                       "description.Account.Properties.Encryption",
	"endpoint":                         "description.Account.Properties.Endpoint",
	"endpoints":                        "description.Account.Properties.Endpoints",
	"etag":                             "description.Account.Etag",
	"id":                               "description.Account.ID",
	"identity":                         "description.Account.Identity",
	"is_migrated":                      "description.Account.Properties.IsMigrated",
	"kaytu_account_id":                 "metadata.SourceID",
	"kind":                             "description.Account.Kind",
	"migration_token":                  "description.Account.Properties.MigrationToken",
	"name":                             "description.Account.name",
	"network_acls":                     "description.Account.Properties.NetworkAcls",
	"provisioning_state":               "description.Account.Properties.ProvisioningState",
	"public_network_access":            "description.Account.Properties.PublicNetworkAccess",
	"quota_limit":                      "description.Account.Properties.QuotaLimit",
	"region":                           "description.Account.Location",
	"resource_group":                   "description.ResourceGroup",
	"restore":                          "description.Account.Properties.Restore",
	"restrict_outbound_network_access": "description.Account.Properties.RestrictOutboundNetworkAccess",
	"sku":                              "description.Account.Sku",
	"sku_change_info":                  "description.Account.Properties.SkuChangeInfo",
	"system_data":                      "description.Account.SystemData",
	"tags":                             "description.Account.Tags",
	"title":                            "description.Account.Name",
	"type":                             "description.Account.Type",
	"user_owned_storage":               "description.Account.Properties.UserOwnedStorage",
}

func GetCognitiveAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCognitiveAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCognitiveAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCognitiveAccountFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CognitiveAccount =============================

// ==========================  START: ComputeVirtualMachine =============================

type ComputeVirtualMachine struct {
	Description   azure.ComputeVirtualMachineDescription `json:"description"`
	Metadata      azure.Metadata                         `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type ComputeVirtualMachineHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  ComputeVirtualMachine `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type ComputeVirtualMachineHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []ComputeVirtualMachineHit `json:"hits"`
}

type ComputeVirtualMachineSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  ComputeVirtualMachineHits `json:"hits"`
}

type ComputeVirtualMachinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeVirtualMachinePaginator(filters []essdk.BoolFilter, limit *int64) (ComputeVirtualMachinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_virtualmachines", filters, limit)
	if err != nil {
		return ComputeVirtualMachinePaginator{}, err
	}

	p := ComputeVirtualMachinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeVirtualMachinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeVirtualMachinePaginator) NextPage(ctx context.Context) ([]ComputeVirtualMachine, error) {
	var response ComputeVirtualMachineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeVirtualMachine
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeVirtualMachineFilters = map[string]string{
	"additional_unattend_content":         "description.VirtualMachine.VirtualMachineProperties.OsProfile.WindowsConfiguration.AdditionalUnattendContent",
	"admin_user_name":                     "description.VirtualMachine.VirtualMachineProperties.OsProfile.AdminUsername",
	"akas":                                "description.VirtualMachine.ID",
	"allow_extension_operations":          "description.VirtualMachine.VirtualMachineProperties.OsProfile.AllowExtensionOperations",
	"availability_set_id":                 "description.VirtualMachine.VirtualMachineProperties.AvailabilitySet.ID",
	"billing_profile_max_price":           "description.VirtualMachine.VirtualMachineProperties.BillingProfile.MaxPrice",
	"boot_diagnostics_enabled":            "description.VirtualMachine.VirtualMachineProperties.DiagnosticsProfile.BootDiagnostics.Enabled",
	"boot_diagnostics_storage_uri":        "description.VirtualMachine.VirtualMachineProperties.DiagnosticsProfile.BootDiagnostics.StorageURI",
	"computer_name":                       "description.VirtualMachine.VirtualMachineProperties.OsProfile.ComputerName",
	"data_disks":                          "description.VirtualMachine.VirtualMachineProperties.StorageProfile.DataDisks",
	"disable_password_authentication":     "description.VirtualMachine.VirtualMachineProperties.OsProfile.LinuxConfiguration.DisablePasswordAuthentication",
	"enable_automatic_updates":            "description.VirtualMachine.VirtualMachineProperties.OsProfile.WindowsConfiguration.EnableAutomaticUpdates",
	"eviction_policy":                     "description.VirtualMachine.VirtualMachineProperties.EvictionPolicy",
	"extensions":                          "description.VirtualMachineInstanceView.Extensions",
	"guest_configuration_assignments":     "description.Assignments",
	"id":                                  "description.VirtualMachine.ID",
	"identity":                            "description.VirtualMachine.Identity",
	"image_exact_version":                 "description.VirtualMachine.VirtualMachineProperties.StorageProfile.ImageReference.ExactVersion",
	"image_id":                            "description.VirtualMachine.VirtualMachineProperties.StorageProfile.ImageReference.ID",
	"image_offer":                         "description.VirtualMachine.VirtualMachineProperties.StorageProfile.ImageReference.Offer",
	"image_publisher":                     "description.VirtualMachine.VirtualMachineProperties.StorageProfile.ImageReference.Publisher",
	"image_sku":                           "description.VirtualMachine.VirtualMachineProperties.StorageProfile.ImageReference.Sku",
	"image_version":                       "description.VirtualMachine.VirtualMachineProperties.StorageProfile.ImageReference.Version",
	"kaytu_account_id":                    "metadata.SourceID",
	"linux_configuration_ssh_public_keys": "description.VirtualMachine.VirtualMachineProperties.OsProfile.LinuxConfiguration.SSH.PublicKeys",
	"managed_disk_id":                     "description.VirtualMachine.VirtualMachineProperties.StorageProfile.OsDisk.ManagedDisk.ID",
	"name":                                "description.VirtualMachine.Name",
	"network_interfaces":                  "description.VirtualMachine.VirtualMachineProperties.NetworkProfile.NetworkInterfaces",
	"os_disk_caching":                     "description.VirtualMachine.VirtualMachineProperties.StorageProfile.OsDisk.Caching",
	"os_disk_create_option":               "description.VirtualMachine.VirtualMachineProperties.StorageProfile.OsDisk.CreateOption",
	"os_disk_name":                        "description.VirtualMachine.VirtualMachineProperties.StorageProfile.OsDisk.Name",
	"os_disk_vhd_uri":                     "description.VirtualMachine.VirtualMachineProperties.StorageProfile.OsDisk.Vhd.URI",
	"os_name":                             "description.VirtualMachineInstanceView.OsName",
	"os_type":                             "description.VirtualMachine.VirtualMachineProperties.StorageProfile.OsDisk.OsType",
	"os_version":                          "description.VirtualMachineInstanceView.OsVersion",
	"patch_settings":                      "description.VirtualMachine.VirtualMachineProperties.OsProfile.WindowsConfiguration.PatchSettings",
	"power_state":                         "description.VirtualMachineInstanceView.Statuses",
	"priority":                            "description.VirtualMachine.VirtualMachineProperties.Priority",
	"private_ips":                         "description.InterfaceIPConfigurations",
	"provision_vm_agent":                  "description.VirtualMachine.VirtualMachineProperties.OsProfile.LinuxConfiguration.ProvisionVMAgent",
	"provision_vm_agent_windows":          "description.VirtualMachine.VirtualMachineProperties.OsProfile.WindowsConfiguration.ProvisionVMAgent",
	"provisioning_state":                  "description.VirtualMachine.VirtualMachineProperties.ProvisioningState",
	"public_ips":                          "description.PublicIPs",
	"region":                              "description.VirtualMachine.Location",
	"require_guest_provision_signal":      "description.VirtualMachine.VirtualMachineProperties.OsProfile.RequireGuestProvisionSignal",
	"resource_group":                      "description.ResourceGroup",
	"secrets":                             "description.VirtualMachine.VirtualMachineProperties.OsProfile.Secrets",
	"security_profile":                    "description.VirtualMachine.VirtualMachineProperties.SecurityProfile",
	"size":                                "description.VirtualMachine.VirtualMachineProperties.HardwareProfile.VMSize",
	"statuses":                            "description.VirtualMachineInstanceView.Statuses",
	"tags":                                "description.VirtualMachine.Tags",
	"time_zone":                           "description.VirtualMachine.VirtualMachineProperties.OsProfile.WindowsConfiguration.TimeZone",
	"title":                               "description.VirtualMachine.Name",
	"type":                                "description.VirtualMachine.Type",
	"ultra_ssd_enabled":                   "description.VirtualMachine.VirtualMachineProperties.AdditionalCapabilities.UltraSSDEnabled",
	"vm_id":                               "description.VirtualMachine.VirtualMachineProperties.VMID",
	"win_rm":                              "description.VirtualMachine.VirtualMachineProperties.OsProfile.WindowsConfiguration.WinRM",
	"zones":                               "description.VirtualMachine.Zones",
}

func ListComputeVirtualMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeVirtualMachine")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeVirtualMachinePaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeVirtualMachineFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeVirtualMachineFilters = map[string]string{
	"additional_unattend_content":         "description.VirtualMachine.VirtualMachineProperties.OsProfile.WindowsConfiguration.AdditionalUnattendContent",
	"admin_user_name":                     "description.VirtualMachine.VirtualMachineProperties.OsProfile.AdminUsername",
	"akas":                                "description.VirtualMachine.ID",
	"allow_extension_operations":          "description.VirtualMachine.VirtualMachineProperties.OsProfile.AllowExtensionOperations",
	"availability_set_id":                 "description.VirtualMachine.VirtualMachineProperties.AvailabilitySet.ID",
	"billing_profile_max_price":           "description.VirtualMachine.VirtualMachineProperties.BillingProfile.MaxPrice",
	"boot_diagnostics_enabled":            "description.VirtualMachine.VirtualMachineProperties.DiagnosticsProfile.BootDiagnostics.Enabled",
	"boot_diagnostics_storage_uri":        "description.VirtualMachine.VirtualMachineProperties.DiagnosticsProfile.BootDiagnostics.StorageURI",
	"computer_name":                       "description.VirtualMachine.VirtualMachineProperties.OsProfile.ComputerName",
	"data_disks":                          "description.VirtualMachine.VirtualMachineProperties.StorageProfile.DataDisks",
	"disable_password_authentication":     "description.VirtualMachine.VirtualMachineProperties.OsProfile.LinuxConfiguration.DisablePasswordAuthentication",
	"enable_automatic_updates":            "description.VirtualMachine.VirtualMachineProperties.OsProfile.WindowsConfiguration.EnableAutomaticUpdates",
	"eviction_policy":                     "description.VirtualMachine.VirtualMachineProperties.EvictionPolicy",
	"extensions":                          "description.VirtualMachineInstanceView.Extensions",
	"guest_configuration_assignments":     "description.Assignments",
	"id":                                  "description.VirtualMachine.ID",
	"identity":                            "description.VirtualMachine.Identity",
	"image_exact_version":                 "description.VirtualMachine.VirtualMachineProperties.StorageProfile.ImageReference.ExactVersion",
	"image_id":                            "description.VirtualMachine.VirtualMachineProperties.StorageProfile.ImageReference.ID",
	"image_offer":                         "description.VirtualMachine.VirtualMachineProperties.StorageProfile.ImageReference.Offer",
	"image_publisher":                     "description.VirtualMachine.VirtualMachineProperties.StorageProfile.ImageReference.Publisher",
	"image_sku":                           "description.VirtualMachine.VirtualMachineProperties.StorageProfile.ImageReference.Sku",
	"image_version":                       "description.VirtualMachine.VirtualMachineProperties.StorageProfile.ImageReference.Version",
	"kaytu_account_id":                    "metadata.SourceID",
	"linux_configuration_ssh_public_keys": "description.VirtualMachine.VirtualMachineProperties.OsProfile.LinuxConfiguration.SSH.PublicKeys",
	"managed_disk_id":                     "description.VirtualMachine.VirtualMachineProperties.StorageProfile.OsDisk.ManagedDisk.ID",
	"name":                                "description.VirtualMachine.name",
	"network_interfaces":                  "description.VirtualMachine.VirtualMachineProperties.NetworkProfile.NetworkInterfaces",
	"os_disk_caching":                     "description.VirtualMachine.VirtualMachineProperties.StorageProfile.OsDisk.Caching",
	"os_disk_create_option":               "description.VirtualMachine.VirtualMachineProperties.StorageProfile.OsDisk.CreateOption",
	"os_disk_name":                        "description.VirtualMachine.VirtualMachineProperties.StorageProfile.OsDisk.Name",
	"os_disk_vhd_uri":                     "description.VirtualMachine.VirtualMachineProperties.StorageProfile.OsDisk.Vhd.URI",
	"os_name":                             "description.VirtualMachineInstanceView.OsName",
	"os_type":                             "description.VirtualMachine.VirtualMachineProperties.StorageProfile.OsDisk.OsType",
	"os_version":                          "description.VirtualMachineInstanceView.OsVersion",
	"patch_settings":                      "description.VirtualMachine.VirtualMachineProperties.OsProfile.WindowsConfiguration.PatchSettings",
	"power_state":                         "description.VirtualMachineInstanceView.Statuses",
	"priority":                            "description.VirtualMachine.VirtualMachineProperties.Priority",
	"private_ips":                         "description.InterfaceIPConfigurations",
	"provision_vm_agent":                  "description.VirtualMachine.VirtualMachineProperties.OsProfile.LinuxConfiguration.ProvisionVMAgent",
	"provision_vm_agent_windows":          "description.VirtualMachine.VirtualMachineProperties.OsProfile.WindowsConfiguration.ProvisionVMAgent",
	"provisioning_state":                  "description.VirtualMachine.VirtualMachineProperties.ProvisioningState",
	"public_ips":                          "description.PublicIPs",
	"region":                              "description.VirtualMachine.Location",
	"require_guest_provision_signal":      "description.VirtualMachine.VirtualMachineProperties.OsProfile.RequireGuestProvisionSignal",
	"resource_group":                      "description.ResourceGroup",
	"secrets":                             "description.VirtualMachine.VirtualMachineProperties.OsProfile.Secrets",
	"security_profile":                    "description.VirtualMachine.VirtualMachineProperties.SecurityProfile",
	"size":                                "description.VirtualMachine.VirtualMachineProperties.HardwareProfile.VMSize",
	"statuses":                            "description.VirtualMachineInstanceView.Statuses",
	"tags":                                "description.VirtualMachine.Tags",
	"time_zone":                           "description.VirtualMachine.VirtualMachineProperties.OsProfile.WindowsConfiguration.TimeZone",
	"title":                               "description.VirtualMachine.Name",
	"type":                                "description.VirtualMachine.Type",
	"ultra_ssd_enabled":                   "description.VirtualMachine.VirtualMachineProperties.AdditionalCapabilities.UltraSSDEnabled",
	"vm_id":                               "description.VirtualMachine.VirtualMachineProperties.VMID",
	"win_rm":                              "description.VirtualMachine.VirtualMachineProperties.OsProfile.WindowsConfiguration.WinRM",
	"zones":                               "description.VirtualMachine.Zones",
}

func GetComputeVirtualMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeVirtualMachine")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeVirtualMachinePaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeVirtualMachineFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeVirtualMachine =============================

// ==========================  START: ComputeResourceSKU =============================

type ComputeResourceSKU struct {
	Description   azure.ComputeResourceSKUDescription `json:"description"`
	Metadata      azure.Metadata                      `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type ComputeResourceSKUHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  ComputeResourceSKU `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type ComputeResourceSKUHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []ComputeResourceSKUHit `json:"hits"`
}

type ComputeResourceSKUSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  ComputeResourceSKUHits `json:"hits"`
}

type ComputeResourceSKUPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeResourceSKUPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeResourceSKUPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_resourcesku", filters, limit)
	if err != nil {
		return ComputeResourceSKUPaginator{}, err
	}

	p := ComputeResourceSKUPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeResourceSKUPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeResourceSKUPaginator) NextPage(ctx context.Context) ([]ComputeResourceSKU, error) {
	var response ComputeResourceSKUSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeResourceSKU
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeResourceSKUFilters = map[string]string{
	"api_versions":     "description.ResourceSKU.APIVersions",
	"default_capacity": "description.ResourceSKU.Capacity.Default",
	"family":           "description.ResourceSKU.Family",
	"kaytu_account_id": "metadata.SourceID",
	"kind":             "description.ResourceSKU.Kind",
	"locations":        "description.ResourceSKU.Locations",
	"maximum_capacity": "description.ResourceSKU.Capacity.Maximum",
	"minimum_capacity": "description.ResourceSKU.Capacity.Minimum",
	"name":             "description.ResourceSKU.Name",
	"resource_type":    "description.ResourceSKU.ResourceType",
	"scale_type":       "description.ResourceSKU.Capacity.ScaleType",
	"size":             "description.ResourceSKU.Size",
	"tier":             "description.ResourceSKU.Tier",
	"title":            "description.ResourceSKU.Name",
}

func ListComputeResourceSKU(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeResourceSKU")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeResourceSKUPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeResourceSKUFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeResourceSKUFilters = map[string]string{
	"api_versions":     "description.ResourceSKU.APIVersions",
	"default_capacity": "description.ResourceSKU.Capacity.Default",
	"family":           "description.ResourceSKU.Family",
	"kaytu_account_id": "metadata.SourceID",
	"kind":             "description.ResourceSKU.Kind",
	"locations":        "description.ResourceSKU.Locations",
	"maximum_capacity": "description.ResourceSKU.Capacity.Maximum",
	"minimum_capacity": "description.ResourceSKU.Capacity.Minimum",
	"name":             "description.ResourceSKU.Name",
	"resource_type":    "description.ResourceSKU.ResourceType",
	"scale_type":       "description.ResourceSKU.Capacity.ScaleType",
	"size":             "description.ResourceSKU.Size",
	"tier":             "description.ResourceSKU.Tier",
	"title":            "description.ResourceSKU.Name",
}

func GetComputeResourceSKU(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeResourceSKU")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeResourceSKUPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeResourceSKUFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeResourceSKU =============================

// ==========================  START: ComputeVirtualMachineCpuUtilization =============================

type ComputeVirtualMachineCpuUtilization struct {
	Description   azure.ComputeVirtualMachineCpuUtilizationDescription `json:"description"`
	Metadata      azure.Metadata                                       `json:"metadata"`
	ResourceJobID int                                                  `json:"resource_job_id"`
	SourceJobID   int                                                  `json:"source_job_id"`
	ResourceType  string                                               `json:"resource_type"`
	SourceType    string                                               `json:"source_type"`
	ID            string                                               `json:"id"`
	ARN           string                                               `json:"arn"`
	SourceID      string                                               `json:"source_id"`
}

type ComputeVirtualMachineCpuUtilizationHit struct {
	ID      string                              `json:"_id"`
	Score   float64                             `json:"_score"`
	Index   string                              `json:"_index"`
	Type    string                              `json:"_type"`
	Version int64                               `json:"_version,omitempty"`
	Source  ComputeVirtualMachineCpuUtilization `json:"_source"`
	Sort    []interface{}                       `json:"sort"`
}

type ComputeVirtualMachineCpuUtilizationHits struct {
	Total essdk.SearchTotal                        `json:"total"`
	Hits  []ComputeVirtualMachineCpuUtilizationHit `json:"hits"`
}

type ComputeVirtualMachineCpuUtilizationSearchResponse struct {
	PitID string                                  `json:"pit_id"`
	Hits  ComputeVirtualMachineCpuUtilizationHits `json:"hits"`
}

type ComputeVirtualMachineCpuUtilizationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeVirtualMachineCpuUtilizationPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeVirtualMachineCpuUtilizationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_virtualmachinecpuutilization", filters, limit)
	if err != nil {
		return ComputeVirtualMachineCpuUtilizationPaginator{}, err
	}

	p := ComputeVirtualMachineCpuUtilizationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeVirtualMachineCpuUtilizationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeVirtualMachineCpuUtilizationPaginator) NextPage(ctx context.Context) ([]ComputeVirtualMachineCpuUtilization, error) {
	var response ComputeVirtualMachineCpuUtilizationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeVirtualMachineCpuUtilization
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeVirtualMachineCpuUtilizationFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func ListComputeVirtualMachineCpuUtilization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeVirtualMachineCpuUtilization")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeVirtualMachineCpuUtilizationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeVirtualMachineCpuUtilizationFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeVirtualMachineCpuUtilizationFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func GetComputeVirtualMachineCpuUtilization(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeVirtualMachineCpuUtilization")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeVirtualMachineCpuUtilizationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeVirtualMachineCpuUtilizationFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeVirtualMachineCpuUtilization =============================

// ==========================  START: ComputeVirtualMachineCpuUtilizationDaily =============================

type ComputeVirtualMachineCpuUtilizationDaily struct {
	Description   azure.ComputeVirtualMachineCpuUtilizationDailyDescription `json:"description"`
	Metadata      azure.Metadata                                            `json:"metadata"`
	ResourceJobID int                                                       `json:"resource_job_id"`
	SourceJobID   int                                                       `json:"source_job_id"`
	ResourceType  string                                                    `json:"resource_type"`
	SourceType    string                                                    `json:"source_type"`
	ID            string                                                    `json:"id"`
	ARN           string                                                    `json:"arn"`
	SourceID      string                                                    `json:"source_id"`
}

type ComputeVirtualMachineCpuUtilizationDailyHit struct {
	ID      string                                   `json:"_id"`
	Score   float64                                  `json:"_score"`
	Index   string                                   `json:"_index"`
	Type    string                                   `json:"_type"`
	Version int64                                    `json:"_version,omitempty"`
	Source  ComputeVirtualMachineCpuUtilizationDaily `json:"_source"`
	Sort    []interface{}                            `json:"sort"`
}

type ComputeVirtualMachineCpuUtilizationDailyHits struct {
	Total essdk.SearchTotal                             `json:"total"`
	Hits  []ComputeVirtualMachineCpuUtilizationDailyHit `json:"hits"`
}

type ComputeVirtualMachineCpuUtilizationDailySearchResponse struct {
	PitID string                                       `json:"pit_id"`
	Hits  ComputeVirtualMachineCpuUtilizationDailyHits `json:"hits"`
}

type ComputeVirtualMachineCpuUtilizationDailyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeVirtualMachineCpuUtilizationDailyPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeVirtualMachineCpuUtilizationDailyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_virtualmachinecpuutilizationdaily", filters, limit)
	if err != nil {
		return ComputeVirtualMachineCpuUtilizationDailyPaginator{}, err
	}

	p := ComputeVirtualMachineCpuUtilizationDailyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeVirtualMachineCpuUtilizationDailyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeVirtualMachineCpuUtilizationDailyPaginator) NextPage(ctx context.Context) ([]ComputeVirtualMachineCpuUtilizationDaily, error) {
	var response ComputeVirtualMachineCpuUtilizationDailySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeVirtualMachineCpuUtilizationDaily
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeVirtualMachineCpuUtilizationDailyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func ListComputeVirtualMachineCpuUtilizationDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeVirtualMachineCpuUtilizationDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeVirtualMachineCpuUtilizationDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeVirtualMachineCpuUtilizationDailyFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeVirtualMachineCpuUtilizationDailyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func GetComputeVirtualMachineCpuUtilizationDaily(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeVirtualMachineCpuUtilizationDaily")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeVirtualMachineCpuUtilizationDailyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeVirtualMachineCpuUtilizationDailyFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeVirtualMachineCpuUtilizationDaily =============================

// ==========================  START: ComputeVirtualMachineCpuUtilizationHourly =============================

type ComputeVirtualMachineCpuUtilizationHourly struct {
	Description   azure.ComputeVirtualMachineCpuUtilizationHourlyDescription `json:"description"`
	Metadata      azure.Metadata                                             `json:"metadata"`
	ResourceJobID int                                                        `json:"resource_job_id"`
	SourceJobID   int                                                        `json:"source_job_id"`
	ResourceType  string                                                     `json:"resource_type"`
	SourceType    string                                                     `json:"source_type"`
	ID            string                                                     `json:"id"`
	ARN           string                                                     `json:"arn"`
	SourceID      string                                                     `json:"source_id"`
}

type ComputeVirtualMachineCpuUtilizationHourlyHit struct {
	ID      string                                    `json:"_id"`
	Score   float64                                   `json:"_score"`
	Index   string                                    `json:"_index"`
	Type    string                                    `json:"_type"`
	Version int64                                     `json:"_version,omitempty"`
	Source  ComputeVirtualMachineCpuUtilizationHourly `json:"_source"`
	Sort    []interface{}                             `json:"sort"`
}

type ComputeVirtualMachineCpuUtilizationHourlyHits struct {
	Total essdk.SearchTotal                              `json:"total"`
	Hits  []ComputeVirtualMachineCpuUtilizationHourlyHit `json:"hits"`
}

type ComputeVirtualMachineCpuUtilizationHourlySearchResponse struct {
	PitID string                                        `json:"pit_id"`
	Hits  ComputeVirtualMachineCpuUtilizationHourlyHits `json:"hits"`
}

type ComputeVirtualMachineCpuUtilizationHourlyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeVirtualMachineCpuUtilizationHourlyPaginator(filters []essdk.BoolFilter, limit *int64) (ComputeVirtualMachineCpuUtilizationHourlyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_virtualmachinecpuutilizationhourly", filters, limit)
	if err != nil {
		return ComputeVirtualMachineCpuUtilizationHourlyPaginator{}, err
	}

	p := ComputeVirtualMachineCpuUtilizationHourlyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeVirtualMachineCpuUtilizationHourlyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeVirtualMachineCpuUtilizationHourlyPaginator) NextPage(ctx context.Context) ([]ComputeVirtualMachineCpuUtilizationHourly, error) {
	var response ComputeVirtualMachineCpuUtilizationHourlySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeVirtualMachineCpuUtilizationHourly
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeVirtualMachineCpuUtilizationHourlyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func ListComputeVirtualMachineCpuUtilizationHourly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeVirtualMachineCpuUtilizationHourly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeVirtualMachineCpuUtilizationHourlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeVirtualMachineCpuUtilizationHourlyFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeVirtualMachineCpuUtilizationHourlyFilters = map[string]string{
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.MonitoringMetric.DimensionValue",
}

func GetComputeVirtualMachineCpuUtilizationHourly(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeVirtualMachineCpuUtilizationHourly")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeVirtualMachineCpuUtilizationHourlyPaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeVirtualMachineCpuUtilizationHourlyFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeVirtualMachineCpuUtilizationHourly =============================

// ==========================  START: ComputeCloudService =============================

type ComputeCloudService struct {
	Description   azure.ComputeCloudServiceDescription `json:"description"`
	Metadata      azure.Metadata                       `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type ComputeCloudServiceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ComputeCloudService `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ComputeCloudServiceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ComputeCloudServiceHit `json:"hits"`
}

type ComputeCloudServiceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ComputeCloudServiceHits `json:"hits"`
}

type ComputeCloudServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewComputeCloudServicePaginator(filters []essdk.BoolFilter, limit *int64) (ComputeCloudServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_compute_cloudservices", filters, limit)
	if err != nil {
		return ComputeCloudServicePaginator{}, err
	}

	p := ComputeCloudServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ComputeCloudServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ComputeCloudServicePaginator) NextPage(ctx context.Context) ([]ComputeCloudService, error) {
	var response ComputeCloudServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ComputeCloudService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listComputeCloudServiceFilters = map[string]string{
	"akas":             "description.CloudServices.ID",
	"id":               "description.CloudServices.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.CloudServices.Name",
	"tags":             "description.CloudServices.Tags",
	"title":            "description.CloudServices.Name",
}

func ListComputeCloudService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListComputeCloudService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewComputeCloudServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, listComputeCloudServiceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getComputeCloudServiceFilters = map[string]string{
	"akas":             "description.CloudServices.ID",
	"id":               "description.CloudServices.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.CloudServices.Name",
	"tags":             "description.CloudServices.Tags",
	"title":            "description.CloudServices.Name",
}

func GetComputeCloudService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetComputeCloudService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewComputeCloudServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, getComputeCloudServiceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ComputeCloudService =============================

// ==========================  START: ContainerRegistry =============================

type ContainerRegistry struct {
	Description   azure.ContainerRegistryDescription `json:"description"`
	Metadata      azure.Metadata                     `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type ContainerRegistryHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  ContainerRegistry `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type ContainerRegistryHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []ContainerRegistryHit `json:"hits"`
}

type ContainerRegistrySearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  ContainerRegistryHits `json:"hits"`
}

type ContainerRegistryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewContainerRegistryPaginator(filters []essdk.BoolFilter, limit *int64) (ContainerRegistryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_containerregistry_registries", filters, limit)
	if err != nil {
		return ContainerRegistryPaginator{}, err
	}

	p := ContainerRegistryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ContainerRegistryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ContainerRegistryPaginator) NextPage(ctx context.Context) ([]ContainerRegistry, error) {
	var response ContainerRegistrySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ContainerRegistry
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listContainerRegistryFilters = map[string]string{
	"admin_user_enabled":           "description.Registry.RegistryProperties.AdminUserEnabled",
	"akas":                         "description.Registry.ID",
	"creation_date":                "description.Registry.RegistryProperties.CreationDate",
	"data_endpoint_enabled":        "description.Registry.RegistryProperties.DataEndpointEnabled",
	"data_endpoint_host_names":     "description.Registry.RegistryProperties.DataEndpointHostNames",
	"encryption":                   "description.Registry.RegistryProperties.Encryption",
	"id":                           "description.Registry.ID",
	"identity":                     "description.Registry.Identity",
	"kaytu_account_id":             "metadata.SourceID",
	"login_credentials":            "description.RegistryListCredentialsResult",
	"login_server":                 "description.Registry.RegistryProperties.LoginServer",
	"name":                         "description.Registry.Name",
	"network_rule_bypass_options":  "description.Registry.RegistryProperties.NetworkRuleBypassOptions",
	"network_rule_set":             "description.Registry.RegistryProperties.NetworkRuleSet",
	"policies":                     "description.Registry.RegistryProperties.Policies",
	"private_endpoint_connections": "description.Registry.RegistryProperties.PrivateEndpointConnections",
	"provisioning_state":           "description.Registry.RegistryProperties.ProvisioningState",
	"public_network_access":        "description.Registry.RegistryProperties.PublicNetworkAccess",
	"region":                       "description.Registry.Location",
	"resource_group":               "description.ResourceGroup",
	"sku_name":                     "description.Registry.Sku.Name",
	"sku_tier":                     "description.Registry.Sku.Tier",
	"status":                       "description.Registry.RegistryProperties.Status.DisplayStatus",
	"status_message":               "description.Registry.RegistryProperties.Status.Message",
	"status_timestamp":             "description.Registry.RegistryProperties.Status.Timestamp",
	"storage_account_id":           "description.Registry.RegistryProperties.StorageAccount.ID",
	"system_data":                  "description.Registry.SystemData",
	"tags":                         "description.Registry.Tags",
	"title":                        "description.Registry.Name",
	"type":                         "description.Registry.Type",
	"usages":                       "description.RegistryUsages",
	"zone_redundancy":              "description.Registry.RegistryProperties.ZoneRedundancy",
}

func ListContainerRegistry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListContainerRegistry")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewContainerRegistryPaginator(essdk.BuildFilter(d.KeyColumnQuals, listContainerRegistryFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getContainerRegistryFilters = map[string]string{
	"admin_user_enabled":           "description.Registry.RegistryProperties.AdminUserEnabled",
	"akas":                         "description.Registry.ID",
	"creation_date":                "description.Registry.RegistryProperties.CreationDate",
	"data_endpoint_enabled":        "description.Registry.RegistryProperties.DataEndpointEnabled",
	"data_endpoint_host_names":     "description.Registry.RegistryProperties.DataEndpointHostNames",
	"encryption":                   "description.Registry.RegistryProperties.Encryption",
	"id":                           "description.Registry.ID",
	"identity":                     "description.Registry.Identity",
	"kaytu_account_id":             "metadata.SourceID",
	"login_credentials":            "description.RegistryListCredentialsResult",
	"login_server":                 "description.Registry.RegistryProperties.LoginServer",
	"name":                         "description.Registry.name",
	"network_rule_bypass_options":  "description.Registry.RegistryProperties.NetworkRuleBypassOptions",
	"network_rule_set":             "description.Registry.RegistryProperties.NetworkRuleSet",
	"policies":                     "description.Registry.RegistryProperties.Policies",
	"private_endpoint_connections": "description.Registry.RegistryProperties.PrivateEndpointConnections",
	"provisioning_state":           "description.Registry.RegistryProperties.ProvisioningState",
	"public_network_access":        "description.Registry.RegistryProperties.PublicNetworkAccess",
	"region":                       "description.Registry.Location",
	"resource_group":               "description.ResourceGroup",
	"sku_name":                     "description.Registry.Sku.Name",
	"sku_tier":                     "description.Registry.Sku.Tier",
	"status":                       "description.Registry.RegistryProperties.Status.DisplayStatus",
	"status_message":               "description.Registry.RegistryProperties.Status.Message",
	"status_timestamp":             "description.Registry.RegistryProperties.Status.Timestamp",
	"storage_account_id":           "description.Registry.RegistryProperties.StorageAccount.ID",
	"system_data":                  "description.Registry.SystemData",
	"tags":                         "description.Registry.Tags",
	"title":                        "description.Registry.Name",
	"type":                         "description.Registry.Type",
	"usages":                       "description.RegistryUsages",
	"zone_redundancy":              "description.Registry.RegistryProperties.ZoneRedundancy",
}

func GetContainerRegistry(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetContainerRegistry")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewContainerRegistryPaginator(essdk.BuildFilter(d.KeyColumnQuals, getContainerRegistryFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ContainerRegistry =============================

// ==========================  START: CosmosdbAccount =============================

type CosmosdbAccount struct {
	Description   azure.CosmosdbAccountDescription `json:"description"`
	Metadata      azure.Metadata                   `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type CosmosdbAccountHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  CosmosdbAccount `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type CosmosdbAccountHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []CosmosdbAccountHit `json:"hits"`
}

type CosmosdbAccountSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  CosmosdbAccountHits `json:"hits"`
}

type CosmosdbAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCosmosdbAccountPaginator(filters []essdk.BoolFilter, limit *int64) (CosmosdbAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_documentdb_databaseaccounts", filters, limit)
	if err != nil {
		return CosmosdbAccountPaginator{}, err
	}

	p := CosmosdbAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CosmosdbAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CosmosdbAccountPaginator) NextPage(ctx context.Context) ([]CosmosdbAccount, error) {
	var response CosmosdbAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CosmosdbAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCosmosdbAccountFilters = map[string]string{
	"akas":                            "description.DatabaseAccountGetResults.ID",
	"capabilities":                    "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.Capabilities",
	"connector_offer":                 "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.ConnectorOffer",
	"consistency_policy_max_interval": "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.ConsistencyPolicy.MaxIntervalInSeconds",
	"consistency_policy_max_staleness_prefix": "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.ConsistencyPolicy.MaxStalenessPrefix",
	"cors":                                    "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.Cors",
	"database_account_offer_type":             "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.DatabaseAccountOfferType",
	"default_consistency_level":               "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.ConsistencyPolicy.DefaultConsistencyLevel",
	"disable_key_based_metadata_write_access": "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.DisableKeyBasedMetadataWriteAccess",
	"document_endpoint":                       "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.DocumentEndpoint",
	"enable_analytical_storage":               "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.EnableAnalyticalStorage",
	"enable_automatic_failover":               "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.EnableAutomaticFailover",
	"enable_cassandra_connector":              "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.EnableCassandraConnector",
	"enable_free_tier":                        "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.EnableFreeTier",
	"enable_multiple_write_locations":         "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.EnableMultipleWriteLocations",
	"failover_policies":                       "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.FailoverPolicies",
	"id":                                      "databaseAccount.ID",
	"ip_rules":                                "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.IPRules",
	"is_virtual_network_filter_enabled":       "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.IsVirtualNetworkFilterEnabled",
	"kaytu_account_id":                        "metadata.SourceID",
	"key_vault_key_uri":                       "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.KeyVaultKeyURI",
	"kind":                                    "description.DatabaseAccountGetResults.Kind",
	"locations":                               "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.Locations",
	"name":                                    "description.DatabaseAccountGetResults.Name",
	"private_endpoint_connections":            "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.PrivateEndpointConnections",
	"provisioning_state":                      "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.ProvisioningState",
	"public_network_access":                   "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.PublicNetworkAccess",
	"read_locations":                          "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.ReadLocations",
	"region":                                  "description.DatabaseAccountGetResults.Location",
	"resource_group":                          "description.ResourceGroup",
	"server_version":                          "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.APIProperties.ServerVersion",
	"tags":                                    "description.DatabaseAccountGetResults.Tags",
	"title":                                   "description.DatabaseAccountGetResults.Name",
	"type":                                    "description.DatabaseAccountGetResults.Type",
	"virtual_network_rules":                   "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.VirtualNetworkRules",
	"write_locations":                         "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.WriteLocations",
}

func ListCosmosdbAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCosmosdbAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCosmosdbAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCosmosdbAccountFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCosmosdbAccountFilters = map[string]string{
	"akas":                            "description.DatabaseAccountGetResults.ID",
	"capabilities":                    "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.Capabilities",
	"connector_offer":                 "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.ConnectorOffer",
	"consistency_policy_max_interval": "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.ConsistencyPolicy.MaxIntervalInSeconds",
	"consistency_policy_max_staleness_prefix": "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.ConsistencyPolicy.MaxStalenessPrefix",
	"cors":                                    "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.Cors",
	"database_account_offer_type":             "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.DatabaseAccountOfferType",
	"default_consistency_level":               "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.ConsistencyPolicy.DefaultConsistencyLevel",
	"disable_key_based_metadata_write_access": "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.DisableKeyBasedMetadataWriteAccess",
	"document_endpoint":                       "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.DocumentEndpoint",
	"enable_analytical_storage":               "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.EnableAnalyticalStorage",
	"enable_automatic_failover":               "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.EnableAutomaticFailover",
	"enable_cassandra_connector":              "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.EnableCassandraConnector",
	"enable_free_tier":                        "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.EnableFreeTier",
	"enable_multiple_write_locations":         "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.EnableMultipleWriteLocations",
	"failover_policies":                       "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.FailoverPolicies",
	"id":                                      "databaseAccount.ID",
	"ip_rules":                                "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.IPRules",
	"is_virtual_network_filter_enabled":       "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.IsVirtualNetworkFilterEnabled",
	"kaytu_account_id":                        "metadata.SourceID",
	"key_vault_key_uri":                       "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.KeyVaultKeyURI",
	"kind":                                    "description.DatabaseAccountGetResults.Kind",
	"locations":                               "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.Locations",
	"name":                                    "description.DatabaseAccountGetResults.name",
	"private_endpoint_connections":            "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.PrivateEndpointConnections",
	"provisioning_state":                      "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.ProvisioningState",
	"public_network_access":                   "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.PublicNetworkAccess",
	"read_locations":                          "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.ReadLocations",
	"region":                                  "description.DatabaseAccountGetResults.Location",
	"resource_group":                          "description.ResourceGroup",
	"server_version":                          "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.APIProperties.ServerVersion",
	"tags":                                    "description.DatabaseAccountGetResults.Tags",
	"title":                                   "description.DatabaseAccountGetResults.Name",
	"type":                                    "description.DatabaseAccountGetResults.Type",
	"virtual_network_rules":                   "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.VirtualNetworkRules",
	"write_locations":                         "description.DatabaseAccountGetResults.DatabaseAccountGetProperties.WriteLocations",
}

func GetCosmosdbAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCosmosdbAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCosmosdbAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCosmosdbAccountFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CosmosdbAccount =============================

// ==========================  START: CosmosdbMongoDatabase =============================

type CosmosdbMongoDatabase struct {
	Description   azure.CosmosdbMongoDatabaseDescription `json:"description"`
	Metadata      azure.Metadata                         `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type CosmosdbMongoDatabaseHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  CosmosdbMongoDatabase `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type CosmosdbMongoDatabaseHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []CosmosdbMongoDatabaseHit `json:"hits"`
}

type CosmosdbMongoDatabaseSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  CosmosdbMongoDatabaseHits `json:"hits"`
}

type CosmosdbMongoDatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCosmosdbMongoDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (CosmosdbMongoDatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_documentdb_mongodatabases", filters, limit)
	if err != nil {
		return CosmosdbMongoDatabasePaginator{}, err
	}

	p := CosmosdbMongoDatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CosmosdbMongoDatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CosmosdbMongoDatabasePaginator) NextPage(ctx context.Context) ([]CosmosdbMongoDatabase, error) {
	var response CosmosdbMongoDatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CosmosdbMongoDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCosmosdbMongoDatabaseFilters = map[string]string{
	"account_name":                      "description.Account.Name",
	"akas":                              "description.MongoDatabase.ID",
	"autoscale_settings_max_throughput": "description.MongoDatabase.MongoDBDatabaseGetProperties.Options.AutoscaleSettings.MaxThroughput",
	"database_etag":                     "description.MongoDatabase.MongoDBDatabaseGetProperties.Resource.Etag",
	"database_id":                       "description.MongoDatabase.MongoDBDatabaseGetProperties.Resource.ID",
	"database_rid":                      "description.MongoDatabase.MongoDBDatabaseGetProperties.Resource.Rid",
	"database_ts":                       "description.MongoDatabase.MongoDBDatabaseGetProperties.Resource.Ts",
	"id":                                "description.MongoDatabase.ID",
	"kaytu_account_id":                  "metadata.SourceID",
	"name":                              "description.MongoDatabase.Name",
	"region":                            "description.MongoDatabase.Location",
	"resource_group":                    "description.ResourceGroup",
	"tags":                              "description.MongoDatabase.Tags",
	"throughput":                        "description.MongoDatabase.MongoDBDatabaseGetProperties.Options.Throughput",
	"title":                             "description.MongoDatabase.Name",
	"type":                              "description.MongoDatabase.Type",
}

func ListCosmosdbMongoDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCosmosdbMongoDatabase")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCosmosdbMongoDatabasePaginator(essdk.BuildFilter(d.KeyColumnQuals, listCosmosdbMongoDatabaseFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCosmosdbMongoDatabaseFilters = map[string]string{
	"account_name":                      "description.Account.name",
	"akas":                              "description.MongoDatabase.ID",
	"autoscale_settings_max_throughput": "description.MongoDatabase.MongoDBDatabaseGetProperties.Options.AutoscaleSettings.MaxThroughput",
	"database_etag":                     "description.MongoDatabase.MongoDBDatabaseGetProperties.Resource.Etag",
	"database_id":                       "description.MongoDatabase.MongoDBDatabaseGetProperties.Resource.ID",
	"database_rid":                      "description.MongoDatabase.MongoDBDatabaseGetProperties.Resource.Rid",
	"database_ts":                       "description.MongoDatabase.MongoDBDatabaseGetProperties.Resource.Ts",
	"id":                                "description.MongoDatabase.ID",
	"kaytu_account_id":                  "metadata.SourceID",
	"name":                              "description.MongoDatabase.name",
	"region":                            "description.MongoDatabase.Location",
	"resource_group":                    "description.ResourceGroup",
	"tags":                              "description.MongoDatabase.Tags",
	"throughput":                        "description.MongoDatabase.MongoDBDatabaseGetProperties.Options.Throughput",
	"title":                             "description.MongoDatabase.Name",
	"type":                              "description.MongoDatabase.Type",
}

func GetCosmosdbMongoDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCosmosdbMongoDatabase")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCosmosdbMongoDatabasePaginator(essdk.BuildFilter(d.KeyColumnQuals, getCosmosdbMongoDatabaseFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CosmosdbMongoDatabase =============================

// ==========================  START: CosmosdbSqlDatabase =============================

type CosmosdbSqlDatabase struct {
	Description   azure.CosmosdbSqlDatabaseDescription `json:"description"`
	Metadata      azure.Metadata                       `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type CosmosdbSqlDatabaseHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  CosmosdbSqlDatabase `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type CosmosdbSqlDatabaseHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []CosmosdbSqlDatabaseHit `json:"hits"`
}

type CosmosdbSqlDatabaseSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  CosmosdbSqlDatabaseHits `json:"hits"`
}

type CosmosdbSqlDatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCosmosdbSqlDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (CosmosdbSqlDatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_documentdb_sqldatabases", filters, limit)
	if err != nil {
		return CosmosdbSqlDatabasePaginator{}, err
	}

	p := CosmosdbSqlDatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CosmosdbSqlDatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CosmosdbSqlDatabasePaginator) NextPage(ctx context.Context) ([]CosmosdbSqlDatabase, error) {
	var response CosmosdbSqlDatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CosmosdbSqlDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCosmosdbSqlDatabaseFilters = map[string]string{
	"account_name":                      "description.Account.Name",
	"akas":                              "description.SqlDatabase.ID",
	"autoscale_settings_max_throughput": "description.SqlDatabase.SQLDatabaseGetProperties.Options.AutoscaleSettings.MaxThroughput",
	"database_colls":                    "description.SqlDatabase.SQLDatabaseGetProperties.Resource.Colls",
	"database_etag":                     "description.SqlDatabase.SQLDatabaseGetProperties.Resource.Etag",
	"database_id":                       "description.SqlDatabase.SQLDatabaseGetProperties.Resource.ID",
	"database_rid":                      "description.SqlDatabase.SQLDatabaseGetProperties.Resource.Rid",
	"database_ts":                       "description.SqlDatabase.SQLDatabaseGetProperties.Resource.Ts",
	"database_users":                    "description.SqlDatabase.SQLDatabaseGetProperties.Resource.Users",
	"id":                                "description.SqlDatabase.ID",
	"kaytu_account_id":                  "metadata.SourceID",
	"name":                              "description.SqlDatabase.Name",
	"region":                            "description.SqlDatabase.Location",
	"resource_group":                    "description.ResourceGroup",
	"tags":                              "description.SqlDatabase.Tags",
	"throughput":                        "description.SqlDatabase.SQLDatabaseGetProperties.Options.Throughput",
	"title":                             "description.SqlDatabase.Name",
	"type":                              "description.SqlDatabase.Type",
}

func ListCosmosdbSqlDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCosmosdbSqlDatabase")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCosmosdbSqlDatabasePaginator(essdk.BuildFilter(d.KeyColumnQuals, listCosmosdbSqlDatabaseFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCosmosdbSqlDatabaseFilters = map[string]string{
	"account_name":                      "description.Account.name",
	"akas":                              "description.SqlDatabase.ID",
	"autoscale_settings_max_throughput": "description.SqlDatabase.SQLDatabaseGetProperties.Options.AutoscaleSettings.MaxThroughput",
	"database_colls":                    "description.SqlDatabase.SQLDatabaseGetProperties.Resource.Colls",
	"database_etag":                     "description.SqlDatabase.SQLDatabaseGetProperties.Resource.Etag",
	"database_id":                       "description.SqlDatabase.SQLDatabaseGetProperties.Resource.ID",
	"database_rid":                      "description.SqlDatabase.SQLDatabaseGetProperties.Resource.Rid",
	"database_ts":                       "description.SqlDatabase.SQLDatabaseGetProperties.Resource.Ts",
	"database_users":                    "description.SqlDatabase.SQLDatabaseGetProperties.Resource.Users",
	"id":                                "description.SqlDatabase.ID",
	"kaytu_account_id":                  "metadata.SourceID",
	"name":                              "description.SqlDatabase.name",
	"region":                            "description.SqlDatabase.Location",
	"resource_group":                    "description.ResourceGroup",
	"tags":                              "description.SqlDatabase.Tags",
	"throughput":                        "description.SqlDatabase.SQLDatabaseGetProperties.Options.Throughput",
	"title":                             "description.SqlDatabase.Name",
	"type":                              "description.SqlDatabase.Type",
}

func GetCosmosdbSqlDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCosmosdbSqlDatabase")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCosmosdbSqlDatabasePaginator(essdk.BuildFilter(d.KeyColumnQuals, getCosmosdbSqlDatabaseFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CosmosdbSqlDatabase =============================

// ==========================  START: DatabricksWorkspace =============================

type DatabricksWorkspace struct {
	Description   azure.DatabricksWorkspaceDescription `json:"description"`
	Metadata      azure.Metadata                       `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type DatabricksWorkspaceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  DatabricksWorkspace `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type DatabricksWorkspaceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []DatabricksWorkspaceHit `json:"hits"`
}

type DatabricksWorkspaceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  DatabricksWorkspaceHits `json:"hits"`
}

type DatabricksWorkspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDatabricksWorkspacePaginator(filters []essdk.BoolFilter, limit *int64) (DatabricksWorkspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_databricks_workspaces", filters, limit)
	if err != nil {
		return DatabricksWorkspacePaginator{}, err
	}

	p := DatabricksWorkspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DatabricksWorkspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DatabricksWorkspacePaginator) NextPage(ctx context.Context) ([]DatabricksWorkspace, error) {
	var response DatabricksWorkspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DatabricksWorkspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDatabricksWorkspaceFilters = map[string]string{
	"akas":             "description.Workspaces.ID",
	"id":               "description.Workspaces.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Workspaces.Name",
	"tags":             "description.Workspaces.Tags",
	"title":            "description.Workspaces.Name",
}

func ListDatabricksWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDatabricksWorkspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDatabricksWorkspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, listDatabricksWorkspaceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDatabricksWorkspaceFilters = map[string]string{
	"akas":             "description.Workspaces.ID",
	"id":               "description.Workspaces.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Workspaces.Name",
	"tags":             "description.Workspaces.Tags",
	"title":            "description.Workspaces.Name",
}

func GetDatabricksWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDatabricksWorkspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDatabricksWorkspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, getDatabricksWorkspaceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DatabricksWorkspace =============================

// ==========================  START: DataMigrationService =============================

type DataMigrationService struct {
	Description   azure.DataMigrationServiceDescription `json:"description"`
	Metadata      azure.Metadata                        `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type DataMigrationServiceHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  DataMigrationService `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type DataMigrationServiceHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []DataMigrationServiceHit `json:"hits"`
}

type DataMigrationServiceSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  DataMigrationServiceHits `json:"hits"`
}

type DataMigrationServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataMigrationServicePaginator(filters []essdk.BoolFilter, limit *int64) (DataMigrationServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_datamigration_services", filters, limit)
	if err != nil {
		return DataMigrationServicePaginator{}, err
	}

	p := DataMigrationServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataMigrationServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataMigrationServicePaginator) NextPage(ctx context.Context) ([]DataMigrationService, error) {
	var response DataMigrationServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataMigrationService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataMigrationServiceFilters = map[string]string{
	"akas":             "description.Services.ID",
	"id":               "description.Services.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Services.Name",
	"tags":             "description.Services.Tags",
	"title":            "description.Services.Name",
}

func ListDataMigrationService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataMigrationService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDataMigrationServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, listDataMigrationServiceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDataMigrationServiceFilters = map[string]string{
	"akas":             "description.Services.ID",
	"id":               "description.Services.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Services.Name",
	"tags":             "description.Services.Tags",
	"title":            "description.Services.Name",
}

func GetDataMigrationService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataMigrationService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDataMigrationServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, getDataMigrationServiceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DataMigrationService =============================

// ==========================  START: DataProtectionBackupVaults =============================

type DataProtectionBackupVaults struct {
	Description   azure.DataProtectionBackupVaultsDescription `json:"description"`
	Metadata      azure.Metadata                              `json:"metadata"`
	ResourceJobID int                                         `json:"resource_job_id"`
	SourceJobID   int                                         `json:"source_job_id"`
	ResourceType  string                                      `json:"resource_type"`
	SourceType    string                                      `json:"source_type"`
	ID            string                                      `json:"id"`
	ARN           string                                      `json:"arn"`
	SourceID      string                                      `json:"source_id"`
}

type DataProtectionBackupVaultsHit struct {
	ID      string                     `json:"_id"`
	Score   float64                    `json:"_score"`
	Index   string                     `json:"_index"`
	Type    string                     `json:"_type"`
	Version int64                      `json:"_version,omitempty"`
	Source  DataProtectionBackupVaults `json:"_source"`
	Sort    []interface{}              `json:"sort"`
}

type DataProtectionBackupVaultsHits struct {
	Total essdk.SearchTotal               `json:"total"`
	Hits  []DataProtectionBackupVaultsHit `json:"hits"`
}

type DataProtectionBackupVaultsSearchResponse struct {
	PitID string                         `json:"pit_id"`
	Hits  DataProtectionBackupVaultsHits `json:"hits"`
}

type DataProtectionBackupVaultsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataProtectionBackupVaultsPaginator(filters []essdk.BoolFilter, limit *int64) (DataProtectionBackupVaultsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dataprotection_backupvaults", filters, limit)
	if err != nil {
		return DataProtectionBackupVaultsPaginator{}, err
	}

	p := DataProtectionBackupVaultsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataProtectionBackupVaultsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataProtectionBackupVaultsPaginator) NextPage(ctx context.Context) ([]DataProtectionBackupVaults, error) {
	var response DataProtectionBackupVaultsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataProtectionBackupVaults
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataProtectionBackupVaultsFilters = map[string]string{
	"akas":             "description.BackupVaults.ID",
	"id":               "description.BackupVaults.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.BackupVaults.Name",
	"tags":             "description.BackupVaults.Tags",
	"title":            "description.BackupVaults.Name",
}

func ListDataProtectionBackupVaults(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataProtectionBackupVaults")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDataProtectionBackupVaultsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDataProtectionBackupVaultsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDataProtectionBackupVaultsFilters = map[string]string{
	"akas":             "description.BackupVaults.ID",
	"id":               "description.BackupVaults.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.BackupVaults.Name",
	"tags":             "description.BackupVaults.Tags",
	"title":            "description.BackupVaults.Name",
}

func GetDataProtectionBackupVaults(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataProtectionBackupVaults")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDataProtectionBackupVaultsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDataProtectionBackupVaultsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DataProtectionBackupVaults =============================

// ==========================  START: DataProtectionBackupVaultsBackupPolicies =============================

type DataProtectionBackupVaultsBackupPolicies struct {
	Description   azure.DataProtectionBackupVaultsBackupPoliciesDescription `json:"description"`
	Metadata      azure.Metadata                                            `json:"metadata"`
	ResourceJobID int                                                       `json:"resource_job_id"`
	SourceJobID   int                                                       `json:"source_job_id"`
	ResourceType  string                                                    `json:"resource_type"`
	SourceType    string                                                    `json:"source_type"`
	ID            string                                                    `json:"id"`
	ARN           string                                                    `json:"arn"`
	SourceID      string                                                    `json:"source_id"`
}

type DataProtectionBackupVaultsBackupPoliciesHit struct {
	ID      string                                   `json:"_id"`
	Score   float64                                  `json:"_score"`
	Index   string                                   `json:"_index"`
	Type    string                                   `json:"_type"`
	Version int64                                    `json:"_version,omitempty"`
	Source  DataProtectionBackupVaultsBackupPolicies `json:"_source"`
	Sort    []interface{}                            `json:"sort"`
}

type DataProtectionBackupVaultsBackupPoliciesHits struct {
	Total essdk.SearchTotal                             `json:"total"`
	Hits  []DataProtectionBackupVaultsBackupPoliciesHit `json:"hits"`
}

type DataProtectionBackupVaultsBackupPoliciesSearchResponse struct {
	PitID string                                       `json:"pit_id"`
	Hits  DataProtectionBackupVaultsBackupPoliciesHits `json:"hits"`
}

type DataProtectionBackupVaultsBackupPoliciesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataProtectionBackupVaultsBackupPoliciesPaginator(filters []essdk.BoolFilter, limit *int64) (DataProtectionBackupVaultsBackupPoliciesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dataprotection_backupvaults_backuppolicies", filters, limit)
	if err != nil {
		return DataProtectionBackupVaultsBackupPoliciesPaginator{}, err
	}

	p := DataProtectionBackupVaultsBackupPoliciesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataProtectionBackupVaultsBackupPoliciesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataProtectionBackupVaultsBackupPoliciesPaginator) NextPage(ctx context.Context) ([]DataProtectionBackupVaultsBackupPolicies, error) {
	var response DataProtectionBackupVaultsBackupPoliciesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataProtectionBackupVaultsBackupPolicies
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataProtectionBackupVaultsBackupPoliciesFilters = map[string]string{
	"akas":             "description.BackupPolicies.ID",
	"id":               "description.BackupPolicies.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.BackupPolicies.Name",
	"tags":             "description.BackupPolicies.Tags",
	"title":            "description.BackupPolicies.Name",
}

func ListDataProtectionBackupVaultsBackupPolicies(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataProtectionBackupVaultsBackupPolicies")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDataProtectionBackupVaultsBackupPoliciesPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDataProtectionBackupVaultsBackupPoliciesFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDataProtectionBackupVaultsBackupPoliciesFilters = map[string]string{
	"akas":             "description.BackupPolicies.ID",
	"id":               "description.BackupPolicies.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.BackupPolicies.Name",
	"tags":             "description.BackupPolicies.Tags",
	"title":            "description.BackupPolicies.Name",
}

func GetDataProtectionBackupVaultsBackupPolicies(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataProtectionBackupVaultsBackupPolicies")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDataProtectionBackupVaultsBackupPoliciesPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDataProtectionBackupVaultsBackupPoliciesFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DataProtectionBackupVaultsBackupPolicies =============================

// ==========================  START: DataFactory =============================

type DataFactory struct {
	Description   azure.DataFactoryDescription `json:"description"`
	Metadata      azure.Metadata               `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type DataFactoryHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DataFactory   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DataFactoryHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DataFactoryHit  `json:"hits"`
}

type DataFactorySearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  DataFactoryHits `json:"hits"`
}

type DataFactoryPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataFactoryPaginator(filters []essdk.BoolFilter, limit *int64) (DataFactoryPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_datafactory_factories", filters, limit)
	if err != nil {
		return DataFactoryPaginator{}, err
	}

	p := DataFactoryPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataFactoryPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataFactoryPaginator) NextPage(ctx context.Context) ([]DataFactory, error) {
	var response DataFactorySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataFactory
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataFactoryFilters = map[string]string{
	"additional_properties":        "description.Factory.AdditionalProperties",
	"akas":                         "description.Factory.ID",
	"create_time":                  "description.Factory.FactoryProperties.CreateTime",
	"encryption":                   "description.Factory.FactoryProperties.Encryption.KeyVersion",
	"etag":                         "description.Factory.ETag",
	"global_parameters":            "description.Factory.FactoryProperties.GlobalParameters",
	"id":                           "description.Factory.ID",
	"identity":                     "description.Factory.Identity",
	"kaytu_account_id":             "metadata.SourceID",
	"name":                         "description.Factory.Name",
	"private_endpoint_connections": "description.PrivateEndPointConnections",
	"provisioning_state":           "description.Factory.FactoryProperties.ProvisioningState",
	"public_network_access":        "description.Factory.FactoryProperties.PublicNetworkAccess",
	"region":                       "description.Factory.Location",
	"repo_configuration":           "description.Factory.FactoryProperties.RepoConfiguration",
	"resource_group":               "description.ResourceGroup",
	"tags":                         "description.Factory.Tags",
	"title":                        "description.Factory.Name",
	"type":                         "description.Factory.Type",
	"version":                      "description.Factory.FactoryProperties.Version",
}

func ListDataFactory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataFactory")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDataFactoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDataFactoryFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDataFactoryFilters = map[string]string{
	"additional_properties":        "description.Factory.AdditionalProperties",
	"akas":                         "description.Factory.ID",
	"create_time":                  "description.Factory.FactoryProperties.CreateTime",
	"encryption":                   "description.Factory.FactoryProperties.Encryption.KeyVersion",
	"etag":                         "description.Factory.ETag",
	"global_parameters":            "description.Factory.FactoryProperties.GlobalParameters",
	"id":                           "description.Factory.ID",
	"identity":                     "description.Factory.Identity",
	"kaytu_account_id":             "metadata.SourceID",
	"name":                         "description.Factory.name",
	"private_endpoint_connections": "description.PrivateEndPointConnections",
	"provisioning_state":           "description.Factory.FactoryProperties.ProvisioningState",
	"public_network_access":        "description.Factory.FactoryProperties.PublicNetworkAccess",
	"region":                       "description.Factory.Location",
	"repo_configuration":           "description.Factory.FactoryProperties.RepoConfiguration",
	"resource_group":               "description.ResourceGroup",
	"tags":                         "description.Factory.Tags",
	"title":                        "description.Factory.Name",
	"type":                         "description.Factory.Type",
	"version":                      "description.Factory.FactoryProperties.Version",
}

func GetDataFactory(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataFactory")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDataFactoryPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDataFactoryFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DataFactory =============================

// ==========================  START: DataFactoryDataset =============================

type DataFactoryDataset struct {
	Description   azure.DataFactoryDatasetDescription `json:"description"`
	Metadata      azure.Metadata                      `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type DataFactoryDatasetHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  DataFactoryDataset `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type DataFactoryDatasetHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []DataFactoryDatasetHit `json:"hits"`
}

type DataFactoryDatasetSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  DataFactoryDatasetHits `json:"hits"`
}

type DataFactoryDatasetPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataFactoryDatasetPaginator(filters []essdk.BoolFilter, limit *int64) (DataFactoryDatasetPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_datafactory_factoriesdatasets", filters, limit)
	if err != nil {
		return DataFactoryDatasetPaginator{}, err
	}

	p := DataFactoryDatasetPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataFactoryDatasetPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataFactoryDatasetPaginator) NextPage(ctx context.Context) ([]DataFactoryDataset, error) {
	var response DataFactoryDatasetSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataFactoryDataset
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataFactoryDatasetFilters = map[string]string{
	"akas":             "description.Dataset.ID",
	"etag":             "description.Dataset.Etag",
	"factory_name":     "description.Factory.Name",
	"id":               "description.Dataset.ID",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Dataset.Name",
	"properties":       "description.Dataset.Properties",
	"resource_group":   "description.ResourceGroup",
	"title":            "description.Dataset.Name",
	"type":             "description.Dataset.Type",
}

func ListDataFactoryDataset(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataFactoryDataset")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDataFactoryDatasetPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDataFactoryDatasetFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDataFactoryDatasetFilters = map[string]string{
	"akas":             "description.Dataset.ID",
	"etag":             "description.Dataset.Etag",
	"factory_name":     "description.Factory.name",
	"id":               "description.Dataset.ID",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Dataset.name",
	"properties":       "description.Dataset.Properties",
	"resource_group":   "description.ResourceGroup",
	"title":            "description.Dataset.Name",
	"type":             "description.Dataset.Type",
}

func GetDataFactoryDataset(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataFactoryDataset")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDataFactoryDatasetPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDataFactoryDatasetFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DataFactoryDataset =============================

// ==========================  START: DataFactoryPipeline =============================

type DataFactoryPipeline struct {
	Description   azure.DataFactoryPipelineDescription `json:"description"`
	Metadata      azure.Metadata                       `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type DataFactoryPipelineHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  DataFactoryPipeline `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type DataFactoryPipelineHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []DataFactoryPipelineHit `json:"hits"`
}

type DataFactoryPipelineSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  DataFactoryPipelineHits `json:"hits"`
}

type DataFactoryPipelinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataFactoryPipelinePaginator(filters []essdk.BoolFilter, limit *int64) (DataFactoryPipelinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_datafactory_factoriespipelines", filters, limit)
	if err != nil {
		return DataFactoryPipelinePaginator{}, err
	}

	p := DataFactoryPipelinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataFactoryPipelinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataFactoryPipelinePaginator) NextPage(ctx context.Context) ([]DataFactoryPipeline, error) {
	var response DataFactoryPipelineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataFactoryPipeline
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataFactoryPipelineFilters = map[string]string{
	"activities":       "description.Pipeline.Pipeline.Activities",
	"akas":             "description.Factory.Tags",
	"annotations":      "description.Pipeline.Pipeline.Annotations",
	"concurrency":      "description.Pipeline.Pipeline.Concurrency",
	"description":      "description.Pipeline.Pipeline.Description",
	"etag":             "description.Pipeline.ETag",
	"factory_name":     "description.Factory.Name",
	"id":               "description.Pipeline.ID",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Factory.Name",
	"parameters":       "description.Pipeline.Pipeline.Parameters",
	"pipeline_folder":  "description.Pipeline.Pipeline.Folder",
	"pipeline_policy":  "description.Pipeline.Pipeline.Policy",
	"resource_group":   "description.ResourceGroup",
	"run_dimensions":   "description.Pipeline.Pipeline.RunDimensions",
	"title":            "description.Factory.Name",
	"type":             "description.Pipeline.Type",
	"variables":        "description.Pipeline.Pipeline.Variables",
}

func ListDataFactoryPipeline(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataFactoryPipeline")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDataFactoryPipelinePaginator(essdk.BuildFilter(d.KeyColumnQuals, listDataFactoryPipelineFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDataFactoryPipelineFilters = map[string]string{
	"activities":       "description.Pipeline.Pipeline.Activities",
	"akas":             "description.Factory.Tags",
	"annotations":      "description.Pipeline.Pipeline.Annotations",
	"concurrency":      "description.Pipeline.Pipeline.Concurrency",
	"description":      "description.Pipeline.Pipeline.Description",
	"etag":             "description.Pipeline.ETag",
	"factory_name":     "description.Factory.name",
	"id":               "description.Pipeline.ID",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Pipeline.name",
	"parameters":       "description.Pipeline.Pipeline.Parameters",
	"pipeline_folder":  "description.Pipeline.Pipeline.Folder",
	"pipeline_policy":  "description.Pipeline.Pipeline.Policy",
	"resource_group":   "description.ResourceGroup",
	"run_dimensions":   "description.Pipeline.Pipeline.RunDimensions",
	"title":            "description.Factory.Name",
	"type":             "description.Pipeline.Type",
	"variables":        "description.Pipeline.Pipeline.Variables",
}

func GetDataFactoryPipeline(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataFactoryPipeline")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDataFactoryPipelinePaginator(essdk.BuildFilter(d.KeyColumnQuals, getDataFactoryPipelineFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DataFactoryPipeline =============================

// ==========================  START: DataLakeAnalyticsAccount =============================

type DataLakeAnalyticsAccount struct {
	Description   azure.DataLakeAnalyticsAccountDescription `json:"description"`
	Metadata      azure.Metadata                            `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type DataLakeAnalyticsAccountHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  DataLakeAnalyticsAccount `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type DataLakeAnalyticsAccountHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []DataLakeAnalyticsAccountHit `json:"hits"`
}

type DataLakeAnalyticsAccountSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  DataLakeAnalyticsAccountHits `json:"hits"`
}

type DataLakeAnalyticsAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataLakeAnalyticsAccountPaginator(filters []essdk.BoolFilter, limit *int64) (DataLakeAnalyticsAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_datalakeanalytics_accounts", filters, limit)
	if err != nil {
		return DataLakeAnalyticsAccountPaginator{}, err
	}

	p := DataLakeAnalyticsAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataLakeAnalyticsAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataLakeAnalyticsAccountPaginator) NextPage(ctx context.Context) ([]DataLakeAnalyticsAccount, error) {
	var response DataLakeAnalyticsAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataLakeAnalyticsAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataLakeAnalyticsAccountFilters = map[string]string{
	"account_id":                        "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.AccountID",
	"akas":                              "description.DataLakeAnalyticsAccount.ID",
	"compute_policies":                  "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.ComputePolicies",
	"creation_time":                     "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.CreationTime",
	"current_tier":                      "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.CurrentTier",
	"data_lake_store_accounts":          "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.DataLakeStoreAccounts",
	"default_data_lake_store_account":   "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.DefaultDataLakeStoreAccount",
	"diagnostic_settings":               "description.DiagnosticSettingsResource",
	"endpoint":                          "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.Endpoint",
	"firewall_allow_azure_ips":          "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.FirewallAllowAzureIps",
	"firewall_rules":                    "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.FirewallRules",
	"firewall_state":                    "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.FirewallState",
	"id":                                "description.DataLakeAnalyticsAccount.ID",
	"kaytu_account_id":                  "metadata.SourceID",
	"last_modified_time":                "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.LastModifiedTime",
	"max_degree_of_parallelism":         "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.MaxDegreeOfParallelism",
	"max_degree_of_parallelism_per_job": "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.MaxDegreeOfParallelismPerJob",
	"max_job_count":                     "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.MaxJobCount",
	"min_priority_per_job":              "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.MinPriorityPerJob",
	"name":                              "description.DataLakeAnalyticsAccount.Name",
	"new_tier":                          "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.NewTier",
	"provisioning_state":                "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.ProvisioningState",
	"query_store_retention":             "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.QueryStoreRetention",
	"region":                            "description.DataLakeAnalyticsAccount.Location",
	"resource_group":                    "description.ResourceGroup",
	"state":                             "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.State",
	"storage_accounts":                  "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.StorageAccounts",
	"system_max_degree_of_parallelism":  "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.SystemMaxDegreeOfParallelism",
	"system_max_job_count":              "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.SystemMaxJobCount",
	"tags":                              "description.DataLakeAnalyticsAccount.Tags",
	"title":                             "description.DataLakeAnalyticsAccount.Name",
	"type":                              "description.DataLakeAnalyticsAccount.Type",
}

func ListDataLakeAnalyticsAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataLakeAnalyticsAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDataLakeAnalyticsAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDataLakeAnalyticsAccountFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDataLakeAnalyticsAccountFilters = map[string]string{
	"account_id":                        "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.AccountID",
	"akas":                              "description.DataLakeAnalyticsAccount.ID",
	"compute_policies":                  "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.ComputePolicies",
	"creation_time":                     "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.CreationTime",
	"current_tier":                      "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.CurrentTier",
	"data_lake_store_accounts":          "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.DataLakeStoreAccounts",
	"default_data_lake_store_account":   "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.DefaultDataLakeStoreAccount",
	"diagnostic_settings":               "description.DiagnosticSettingsResource",
	"endpoint":                          "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.Endpoint",
	"firewall_allow_azure_ips":          "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.FirewallAllowAzureIps",
	"firewall_rules":                    "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.FirewallRules",
	"firewall_state":                    "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.FirewallState",
	"id":                                "description.DataLakeAnalyticsAccount.ID",
	"kaytu_account_id":                  "metadata.SourceID",
	"last_modified_time":                "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.LastModifiedTime",
	"max_degree_of_parallelism":         "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.MaxDegreeOfParallelism",
	"max_degree_of_parallelism_per_job": "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.MaxDegreeOfParallelismPerJob",
	"max_job_count":                     "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.MaxJobCount",
	"min_priority_per_job":              "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.MinPriorityPerJob",
	"name":                              "description.DataLakeAnalyticsAccount.name",
	"new_tier":                          "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.NewTier",
	"provisioning_state":                "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.ProvisioningState",
	"query_store_retention":             "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.QueryStoreRetention",
	"region":                            "description.DataLakeAnalyticsAccount.Location",
	"resource_group":                    "description.ResourceGroup",
	"state":                             "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.State",
	"storage_accounts":                  "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.StorageAccounts",
	"system_max_degree_of_parallelism":  "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.SystemMaxDegreeOfParallelism",
	"system_max_job_count":              "description.DataLakeAnalyticsAccount.DataLakeAnalyticsAccountProperties.SystemMaxJobCount",
	"tags":                              "description.DataLakeAnalyticsAccount.Tags",
	"title":                             "description.DataLakeAnalyticsAccount.Name",
	"type":                              "description.DataLakeAnalyticsAccount.Type",
}

func GetDataLakeAnalyticsAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataLakeAnalyticsAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDataLakeAnalyticsAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDataLakeAnalyticsAccountFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DataLakeAnalyticsAccount =============================

// ==========================  START: DataLakeStore =============================

type DataLakeStore struct {
	Description   azure.DataLakeStoreDescription `json:"description"`
	Metadata      azure.Metadata                 `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type DataLakeStoreHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DataLakeStore `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DataLakeStoreHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []DataLakeStoreHit `json:"hits"`
}

type DataLakeStoreSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  DataLakeStoreHits `json:"hits"`
}

type DataLakeStorePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDataLakeStorePaginator(filters []essdk.BoolFilter, limit *int64) (DataLakeStorePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_datalakestore_accounts", filters, limit)
	if err != nil {
		return DataLakeStorePaginator{}, err
	}

	p := DataLakeStorePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DataLakeStorePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DataLakeStorePaginator) NextPage(ctx context.Context) ([]DataLakeStore, error) {
	var response DataLakeStoreSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DataLakeStore
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDataLakeStoreFilters = map[string]string{
	"account_id":                    "description.DataLakeStoreAccount.Identity.TenantID",
	"akas":                          "description.DataLakeStoreAccount.ID",
	"creation_time":                 "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.CreationTime",
	"current_tier":                  "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.CurrentTier",
	"default_group":                 "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.DefaultGroup",
	"diagnostic_settings":           "description.DiagnosticSettingsResource",
	"encryption_config":             "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.EncryptionConfig",
	"encryption_provisioning_state": "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.EncryptionProvisioningState",
	"encryption_state":              "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.EncryptionState",
	"endpoint":                      "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.Endpoint",
	"firewall_allow_azure_ips":      "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.FirewallAllowAzureIps",
	"firewall_rules":                "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.FirewallRules",
	"firewall_state":                "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.FirewallState",
	"id":                            "description.DataLakeStoreAccount.ID",
	"identity":                      "description.DataLakeStoreAccount.Identity",
	"kaytu_account_id":              "metadata.SourceID",
	"last_modified_time":            "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.LastModifiedTime",
	"name":                          "description.DataLakeStoreAccount.Name",
	"new_tier":                      "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.NewTier",
	"provisioning_state":            "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.ProvisioningState",
	"region":                        "description.DataLakeStoreAccount.Location",
	"resource_group":                "description.ResourceGroup",
	"state":                         "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.State",
	"tags":                          "description.DataLakeStoreAccount.Tags",
	"title":                         "description.DataLakeStoreAccount.Name",
	"trusted_id_provider_state":     "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.TrustedIDProviderState",
	"trusted_id_providers":          "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.TrustedIDProviders",
	"type":                          "description.DataLakeStoreAccount.Type",
	"virtual_network_rules":         "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.VirtualNetworkRules",
}

func ListDataLakeStore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDataLakeStore")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDataLakeStorePaginator(essdk.BuildFilter(d.KeyColumnQuals, listDataLakeStoreFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDataLakeStoreFilters = map[string]string{
	"account_id":                    "description.DataLakeStoreAccount.Identity.TenantID",
	"akas":                          "description.DataLakeStoreAccount.ID",
	"creation_time":                 "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.CreationTime",
	"current_tier":                  "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.CurrentTier",
	"default_group":                 "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.DefaultGroup",
	"diagnostic_settings":           "description.DiagnosticSettingsResource",
	"encryption_config":             "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.EncryptionConfig",
	"encryption_provisioning_state": "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.EncryptionProvisioningState",
	"encryption_state":              "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.EncryptionState",
	"endpoint":                      "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.Endpoint",
	"firewall_allow_azure_ips":      "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.FirewallAllowAzureIps",
	"firewall_rules":                "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.FirewallRules",
	"firewall_state":                "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.FirewallState",
	"id":                            "description.DataLakeStoreAccount.ID",
	"identity":                      "description.DataLakeStoreAccount.Identity",
	"kaytu_account_id":              "metadata.SourceID",
	"last_modified_time":            "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.LastModifiedTime",
	"name":                          "description.DataLakeStoreAccount.name",
	"new_tier":                      "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.NewTier",
	"provisioning_state":            "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.ProvisioningState",
	"region":                        "description.DataLakeStoreAccount.Location",
	"resource_group":                "description.ResourceGroup",
	"state":                         "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.State",
	"tags":                          "description.DataLakeStoreAccount.Tags",
	"title":                         "description.DataLakeStoreAccount.Name",
	"trusted_id_provider_state":     "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.TrustedIDProviderState",
	"trusted_id_providers":          "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.TrustedIDProviders",
	"type":                          "description.DataLakeStoreAccount.Type",
	"virtual_network_rules":         "description.DataLakeStoreAccount.DataLakeStoreAccountProperties.VirtualNetworkRules",
}

func GetDataLakeStore(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDataLakeStore")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDataLakeStorePaginator(essdk.BuildFilter(d.KeyColumnQuals, getDataLakeStoreFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DataLakeStore =============================

// ==========================  START: DiagnosticSetting =============================

type DiagnosticSetting struct {
	Description   azure.DiagnosticSettingDescription `json:"description"`
	Metadata      azure.Metadata                     `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type DiagnosticSettingHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  DiagnosticSetting `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type DiagnosticSettingHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []DiagnosticSettingHit `json:"hits"`
}

type DiagnosticSettingSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  DiagnosticSettingHits `json:"hits"`
}

type DiagnosticSettingPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDiagnosticSettingPaginator(filters []essdk.BoolFilter, limit *int64) (DiagnosticSettingPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_insights_guestdiagnosticsettings", filters, limit)
	if err != nil {
		return DiagnosticSettingPaginator{}, err
	}

	p := DiagnosticSettingPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DiagnosticSettingPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DiagnosticSettingPaginator) NextPage(ctx context.Context) ([]DiagnosticSetting, error) {
	var response DiagnosticSettingSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DiagnosticSetting
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDiagnosticSettingFilters = map[string]string{
	"akas":                            "description.DiagnosticSettingsResource.ID",
	"event_hub_authorization_rule_id": "description.DiagnosticSettingsResource.DiagnosticSettings.EventHubAuthorizationRuleID",
	"event_hub_name":                  "description.DiagnosticSettingsResource.DiagnosticSettings.EventHubName",
	"id":                              "description.DiagnosticSettingsResource.ID",
	"kaytu_account_id":                "metadata.SourceID",
	"log_analytics_destination_type":  "description.DiagnosticSettingsResource.DiagnosticSettings.LogAnalyticsDestinationType",
	"logs":                            "description.DiagnosticSettingsResource.DiagnosticSettings.Logs",
	"metrics":                         "description.DiagnosticSettingsResource.DiagnosticSettings.Metrics",
	"name":                            "description.DiagnosticSettingsResource.Name",
	"service_bus_rule_id":             "description.DiagnosticSettingsResource.DiagnosticSettings.ServiceBusRuleID",
	"storage_account_id":              "description.DiagnosticSettingsResource.DiagnosticSettings.StorageAccountID",
	"title":                           "description.DiagnosticSettingsResource.Name",
	"type":                            "description.DiagnosticSettingsResource.Type",
	"workspace_id":                    "description.DiagnosticSettingsResource.DiagnosticSettings.WorkspaceID",
}

func ListDiagnosticSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDiagnosticSetting")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewDiagnosticSettingPaginator(essdk.BuildFilter(d.KeyColumnQuals, listDiagnosticSettingFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getDiagnosticSettingFilters = map[string]string{
	"akas":                            "description.DiagnosticSettingsResource.ID",
	"event_hub_authorization_rule_id": "description.DiagnosticSettingsResource.DiagnosticSettings.EventHubAuthorizationRuleID",
	"event_hub_name":                  "description.DiagnosticSettingsResource.DiagnosticSettings.EventHubName",
	"id":                              "description.DiagnosticSettingsResource.ID",
	"kaytu_account_id":                "metadata.SourceID",
	"log_analytics_destination_type":  "description.DiagnosticSettingsResource.DiagnosticSettings.LogAnalyticsDestinationType",
	"logs":                            "description.DiagnosticSettingsResource.DiagnosticSettings.Logs",
	"metrics":                         "description.DiagnosticSettingsResource.DiagnosticSettings.Metrics",
	"name":                            "description.DiagnosticSettingsResource.name",
	"resource_group":                  "description.ResourceGroup",
	"service_bus_rule_id":             "description.DiagnosticSettingsResource.DiagnosticSettings.ServiceBusRuleID",
	"storage_account_id":              "description.DiagnosticSettingsResource.DiagnosticSettings.StorageAccountID",
	"title":                           "description.DiagnosticSettingsResource.Name",
	"type":                            "description.DiagnosticSettingsResource.Type",
	"workspace_id":                    "description.DiagnosticSettingsResource.DiagnosticSettings.WorkspaceID",
}

func GetDiagnosticSetting(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDiagnosticSetting")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewDiagnosticSettingPaginator(essdk.BuildFilter(d.KeyColumnQuals, getDiagnosticSettingFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: DiagnosticSetting =============================

// ==========================  START: EventGridDomain =============================

type EventGridDomain struct {
	Description   azure.EventGridDomainDescription `json:"description"`
	Metadata      azure.Metadata                   `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type EventGridDomainHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  EventGridDomain `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type EventGridDomainHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []EventGridDomainHit `json:"hits"`
}

type EventGridDomainSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  EventGridDomainHits `json:"hits"`
}

type EventGridDomainPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEventGridDomainPaginator(filters []essdk.BoolFilter, limit *int64) (EventGridDomainPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_eventgrid_domains", filters, limit)
	if err != nil {
		return EventGridDomainPaginator{}, err
	}

	p := EventGridDomainPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EventGridDomainPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EventGridDomainPaginator) NextPage(ctx context.Context) ([]EventGridDomain, error) {
	var response EventGridDomainSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EventGridDomain
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEventGridDomainFilters = map[string]string{
	"akas": "description.Domain.ID",
	"auto_create_topic_with_first_subscription": "description.Domain.DomainProperties.AutoCreateTopicWithFirstSubscription",
	"auto_delete_topic_with_last_subscription":  "description.Domain.DomainProperties.AutoDeleteTopicWithLastSubscription",
	"created_at":               "description.Domain.SystemData.CreatedAt",
	"created_by":               "description.Domain.SystemData.CreatedBy",
	"created_by_type":          "description.Domain.SystemData.CreatedByType",
	"diagnostic_settings":      "description.DiagnosticSettingsResources",
	"disable_local_auth":       "description.Domain.DomainProperties.DisableLocalAuth",
	"endpoint":                 "description.Domain.DomainProperties.Endpoint",
	"id":                       "description.Domain.ID",
	"identity_type":            "description.Domain.Identity.Type",
	"inbound_ip_rules":         "description.Domain.DomainProperties.InboundIPRules",
	"input_schema":             "description.Domain.DomainProperties.InputSchema",
	"input_schema_mapping":     "description.Domain.DomainProperties.InputSchemaMapping",
	"kaytu_account_id":         "metadata.SourceID",
	"last_modified_at":         "description.Domain.SystemData.LastModifiedAt",
	"last_modified_by":         "description.Domain.SystemData.LastModifiedBy",
	"last_modified_by_type":    "description.Domain.SystemData.LastModifiedByType",
	"location":                 "description.Domain.Location",
	"name":                     "description.Domain.Name",
	"principal_id":             "description.Domain.Identity.PrincipalID",
	"provisioning_state":       "description.Domain.DomainProperties.ProvisioningState",
	"public_network_access":    "description.Domain.DomainProperties.PublicNetworkAccess",
	"region":                   "description.Domain.Location",
	"resource_group":           "description.ResourceGroup",
	"sku_name":                 "description.Domain.Sku.Name",
	"tags":                     "description.Domain.Tags",
	"title":                    "description.Domain.Name",
	"type":                     "description.Domain.Type",
	"user_assigned_identities": "description.Domain.Identity.UserAssignedIdentities",
}

func ListEventGridDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEventGridDomain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEventGridDomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEventGridDomainFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEventGridDomainFilters = map[string]string{
	"akas": "description.Domain.ID",
	"auto_create_topic_with_first_subscription": "description.Domain.DomainProperties.AutoCreateTopicWithFirstSubscription",
	"auto_delete_topic_with_last_subscription":  "description.Domain.DomainProperties.AutoDeleteTopicWithLastSubscription",
	"created_at":               "description.Domain.SystemData.CreatedAt",
	"created_by":               "description.Domain.SystemData.CreatedBy",
	"created_by_type":          "description.Domain.SystemData.CreatedByType",
	"diagnostic_settings":      "description.DiagnosticSettingsResources",
	"disable_local_auth":       "description.Domain.DomainProperties.DisableLocalAuth",
	"endpoint":                 "description.Domain.DomainProperties.Endpoint",
	"id":                       "description.Domain.ID",
	"identity_type":            "description.Domain.Identity.Type",
	"inbound_ip_rules":         "description.Domain.DomainProperties.InboundIPRules",
	"input_schema":             "description.Domain.DomainProperties.InputSchema",
	"input_schema_mapping":     "description.Domain.DomainProperties.InputSchemaMapping",
	"kaytu_account_id":         "metadata.SourceID",
	"last_modified_at":         "description.Domain.SystemData.LastModifiedAt",
	"last_modified_by":         "description.Domain.SystemData.LastModifiedBy",
	"last_modified_by_type":    "description.Domain.SystemData.LastModifiedByType",
	"location":                 "description.Domain.Location",
	"name":                     "description.Domain.name",
	"principal_id":             "description.Domain.Identity.PrincipalID",
	"provisioning_state":       "description.Domain.DomainProperties.ProvisioningState",
	"public_network_access":    "description.Domain.DomainProperties.PublicNetworkAccess",
	"region":                   "description.Domain.Location",
	"resource_group":           "description.ResourceGroup",
	"sku_name":                 "description.Domain.Sku.Name",
	"tags":                     "description.Domain.Tags",
	"title":                    "description.Domain.Name",
	"type":                     "description.Domain.Type",
	"user_assigned_identities": "description.Domain.Identity.UserAssignedIdentities",
}

func GetEventGridDomain(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEventGridDomain")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEventGridDomainPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEventGridDomainFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EventGridDomain =============================

// ==========================  START: EventGridTopic =============================

type EventGridTopic struct {
	Description   azure.EventGridTopicDescription `json:"description"`
	Metadata      azure.Metadata                  `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type EventGridTopicHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  EventGridTopic `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type EventGridTopicHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []EventGridTopicHit `json:"hits"`
}

type EventGridTopicSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  EventGridTopicHits `json:"hits"`
}

type EventGridTopicPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEventGridTopicPaginator(filters []essdk.BoolFilter, limit *int64) (EventGridTopicPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_eventgrid_topics", filters, limit)
	if err != nil {
		return EventGridTopicPaginator{}, err
	}

	p := EventGridTopicPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EventGridTopicPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EventGridTopicPaginator) NextPage(ctx context.Context) ([]EventGridTopic, error) {
	var response EventGridTopicSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EventGridTopic
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEventGridTopicFilters = map[string]string{
	"akas":                  "description.Topic.ID",
	"created_at":            "description.Topic.SystemData.CreatedAt",
	"created_by":            "description.Topic.SystemData.CreatedBy",
	"created_by_type":       "description.Topic.SystemData.CreatedByType",
	"diagnostic_settings":   "description.DiagnosticSettingsResources",
	"disable_local_auth":    "description.Topic.TopicProperties.DisableLocalAuth",
	"endpoint":              "description.Topic.TopicProperties.Endpoint",
	"extended_location":     "description.Topic.ExtendedLocation",
	"id":                    "description.Topic.ID",
	"identity":              "description.Topic.Identity",
	"inbound_ip_rules":      "description.Topic.TopicProperties.InboundIPRules",
	"input_schema":          "description.Topic.TopicProperties.InputSchema",
	"input_schema_mapping":  "description.Topic.TopicProperties.InputSchemaMapping",
	"kaytu_account_id":      "metadata.SourceID",
	"kind":                  "description.Topic.Kind",
	"last_modified_at":      "description.Topic.SystemData.LastModifiedAt",
	"last_modified_by":      "description.Topic.SystemData.LastModifiedBy",
	"last_modified_by_type": "description.Topic.SystemData.LastModifiedByType",
	"location":              "description.Topic.Location",
	"name":                  "description.Topic.Name",
	"provisioning_state":    "description.Topic.TopicProperties.ProvisioningState",
	"public_network_access": "description.Topic.TopicProperties.PublicNetworkAccess",
	"region":                "description.Topic.Location",
	"resource_group":        "description.ResourceGroup",
	"sku_name":              "description.Topic.Sku.Name",
	"tags":                  "description.Topic.Tags",
	"title":                 "description.Topic.Name",
	"type":                  "description.Topic.Type",
}

func ListEventGridTopic(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEventGridTopic")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEventGridTopicPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEventGridTopicFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEventGridTopicFilters = map[string]string{
	"akas":                  "description.Topic.ID",
	"created_at":            "description.Topic.SystemData.CreatedAt",
	"created_by":            "description.Topic.SystemData.CreatedBy",
	"created_by_type":       "description.Topic.SystemData.CreatedByType",
	"diagnostic_settings":   "description.DiagnosticSettingsResources",
	"disable_local_auth":    "description.Topic.TopicProperties.DisableLocalAuth",
	"endpoint":              "description.Topic.TopicProperties.Endpoint",
	"extended_location":     "description.Topic.ExtendedLocation",
	"id":                    "description.Topic.ID",
	"identity":              "description.Topic.Identity",
	"inbound_ip_rules":      "description.Topic.TopicProperties.InboundIPRules",
	"input_schema":          "description.Topic.TopicProperties.InputSchema",
	"input_schema_mapping":  "description.Topic.TopicProperties.InputSchemaMapping",
	"kaytu_account_id":      "metadata.SourceID",
	"kind":                  "description.Topic.Kind",
	"last_modified_at":      "description.Topic.SystemData.LastModifiedAt",
	"last_modified_by":      "description.Topic.SystemData.LastModifiedBy",
	"last_modified_by_type": "description.Topic.SystemData.LastModifiedByType",
	"location":              "description.Topic.Location",
	"name":                  "description.Topic.name",
	"provisioning_state":    "description.Topic.TopicProperties.ProvisioningState",
	"public_network_access": "description.Topic.TopicProperties.PublicNetworkAccess",
	"region":                "description.Topic.Location",
	"resource_group":        "description.ResourceGroup",
	"sku_name":              "description.Topic.Sku.Name",
	"tags":                  "description.Topic.Tags",
	"title":                 "description.Topic.Name",
	"type":                  "description.Topic.Type",
}

func GetEventGridTopic(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEventGridTopic")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEventGridTopicPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEventGridTopicFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EventGridTopic =============================

// ==========================  START: EventhubNamespace =============================

type EventhubNamespace struct {
	Description   azure.EventhubNamespaceDescription `json:"description"`
	Metadata      azure.Metadata                     `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type EventhubNamespaceHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  EventhubNamespace `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type EventhubNamespaceHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []EventhubNamespaceHit `json:"hits"`
}

type EventhubNamespaceSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  EventhubNamespaceHits `json:"hits"`
}

type EventhubNamespacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEventhubNamespacePaginator(filters []essdk.BoolFilter, limit *int64) (EventhubNamespacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_eventhub_namespaces", filters, limit)
	if err != nil {
		return EventhubNamespacePaginator{}, err
	}

	p := EventhubNamespacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EventhubNamespacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EventhubNamespacePaginator) NextPage(ctx context.Context) ([]EventhubNamespace, error) {
	var response EventhubNamespaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EventhubNamespace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEventhubNamespaceFilters = map[string]string{
	"akas":                         "description.EHNamespace.ID",
	"cluster_arm_id":               "description.EHNamespace.EHNamespaceProperties.ClusterArmID",
	"created_at":                   "description.EHNamespace.EHNamespaceProperties.CreatedAt",
	"diagnostic_settings":          "description.DiagnosticSettingsResources",
	"encryption":                   "description.EHNamespace.EHNamespaceProperties.Encryption",
	"id":                           "description.EHNamespace.ID",
	"identity":                     "description.EHNamespace.EHNamespaceProperties.Encryption",
	"is_auto_inflate_enabled":      "description.EHNamespace.EHNamespaceProperties.IsAutoInflateEnabled",
	"kafka_enabled":                "description.EHNamespace.EHNamespaceProperties.KafkaEnabled",
	"kaytu_account_id":             "metadata.SourceID",
	"maximum_throughput_units":     "description.EHNamespace.EHNamespaceProperties.MaximumThroughputUnits",
	"metric_id":                    "description.EHNamespace.EHNamespaceProperties.MetricID",
	"name":                         "description.EHNamespace.Name",
	"network_rule_set":             "description.NetworkRuleSet",
	"private_endpoint_connections": "description.PrivateEndpointConnection",
	"provisioning_state":           "description.EHNamespace.EHNamespaceProperties.ProvisioningState",
	"region":                       "description.EHNamespace.Location",
	"resource_group":               "description.ResourceGroup",
	"service_bus_endpoint":         "description.EHNamespace.EHNamespaceProperties.ServiceBusEndpoint",
	"sku_capacity":                 "description.EHNamespace.Sku.Capacity",
	"sku_name":                     "description.EHNamespace.Sku.Name",
	"sku_tier":                     "description.EHNamespace.Sku.Tier",
	"tags":                         "description.EHNamespace.Tags",
	"title":                        "description.EHNamespace",
	"type":                         "description.EHNamespace.Type",
	"updated_at":                   "description.EHNamespace.EHNamespaceProperties.UpdatedAt",
	"zone_redundant":               "description.EHNamespace.EHNamespaceProperties.ZoneRedundant",
}

func ListEventhubNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEventhubNamespace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEventhubNamespacePaginator(essdk.BuildFilter(d.KeyColumnQuals, listEventhubNamespaceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEventhubNamespaceFilters = map[string]string{
	"akas":                         "description.EHNamespace.ID",
	"cluster_arm_id":               "description.EHNamespace.EHNamespaceProperties.ClusterArmID",
	"created_at":                   "description.EHNamespace.EHNamespaceProperties.CreatedAt",
	"diagnostic_settings":          "description.DiagnosticSettingsResources",
	"encryption":                   "description.EHNamespace.EHNamespaceProperties.Encryption",
	"id":                           "description.EHNamespace.ID",
	"identity":                     "description.EHNamespace.EHNamespaceProperties.Encryption",
	"is_auto_inflate_enabled":      "description.EHNamespace.EHNamespaceProperties.IsAutoInflateEnabled",
	"kafka_enabled":                "description.EHNamespace.EHNamespaceProperties.KafkaEnabled",
	"kaytu_account_id":             "metadata.SourceID",
	"maximum_throughput_units":     "description.EHNamespace.EHNamespaceProperties.MaximumThroughputUnits",
	"metric_id":                    "description.EHNamespace.EHNamespaceProperties.MetricID",
	"name":                         "description.EHNamespace.name",
	"network_rule_set":             "description.NetworkRuleSet",
	"private_endpoint_connections": "description.PrivateEndpointConnection",
	"provisioning_state":           "description.EHNamespace.EHNamespaceProperties.ProvisioningState",
	"region":                       "description.EHNamespace.Location",
	"resource_group":               "description.ResourceGroup",
	"service_bus_endpoint":         "description.EHNamespace.EHNamespaceProperties.ServiceBusEndpoint",
	"sku_capacity":                 "description.EHNamespace.Sku.Capacity",
	"sku_name":                     "description.EHNamespace.Sku.Name",
	"sku_tier":                     "description.EHNamespace.Sku.Tier",
	"tags":                         "description.EHNamespace.Tags",
	"title":                        "description.EHNamespace",
	"type":                         "description.EHNamespace.Type",
	"updated_at":                   "description.EHNamespace.EHNamespaceProperties.UpdatedAt",
	"zone_redundant":               "description.EHNamespace.EHNamespaceProperties.ZoneRedundant",
}

func GetEventhubNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEventhubNamespace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEventhubNamespacePaginator(essdk.BuildFilter(d.KeyColumnQuals, getEventhubNamespaceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EventhubNamespace =============================

// ==========================  START: EventhubNamespaceEventhub =============================

type EventhubNamespaceEventhub struct {
	Description   azure.EventhubNamespaceEventhubDescription `json:"description"`
	Metadata      azure.Metadata                             `json:"metadata"`
	ResourceJobID int                                        `json:"resource_job_id"`
	SourceJobID   int                                        `json:"source_job_id"`
	ResourceType  string                                     `json:"resource_type"`
	SourceType    string                                     `json:"source_type"`
	ID            string                                     `json:"id"`
	ARN           string                                     `json:"arn"`
	SourceID      string                                     `json:"source_id"`
}

type EventhubNamespaceEventhubHit struct {
	ID      string                    `json:"_id"`
	Score   float64                   `json:"_score"`
	Index   string                    `json:"_index"`
	Type    string                    `json:"_type"`
	Version int64                     `json:"_version,omitempty"`
	Source  EventhubNamespaceEventhub `json:"_source"`
	Sort    []interface{}             `json:"sort"`
}

type EventhubNamespaceEventhubHits struct {
	Total essdk.SearchTotal              `json:"total"`
	Hits  []EventhubNamespaceEventhubHit `json:"hits"`
}

type EventhubNamespaceEventhubSearchResponse struct {
	PitID string                        `json:"pit_id"`
	Hits  EventhubNamespaceEventhubHits `json:"hits"`
}

type EventhubNamespaceEventhubPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewEventhubNamespaceEventhubPaginator(filters []essdk.BoolFilter, limit *int64) (EventhubNamespaceEventhubPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_eventhub_namespaces_eventhubs", filters, limit)
	if err != nil {
		return EventhubNamespaceEventhubPaginator{}, err
	}

	p := EventhubNamespaceEventhubPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p EventhubNamespaceEventhubPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p EventhubNamespaceEventhubPaginator) NextPage(ctx context.Context) ([]EventhubNamespaceEventhub, error) {
	var response EventhubNamespaceEventhubSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []EventhubNamespaceEventhub
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listEventhubNamespaceEventhubFilters = map[string]string{
	"akas":             "description.NamespaceEventhubs.ID",
	"id":               "description.NamespaceEventhubs.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.NamespaceEventhubs.Name",
	"tags":             "description.NamespaceEventhubs.Tags",
	"title":            "description.NamespaceEventhubs.Name",
}

func ListEventhubNamespaceEventhub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListEventhubNamespaceEventhub")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewEventhubNamespaceEventhubPaginator(essdk.BuildFilter(d.KeyColumnQuals, listEventhubNamespaceEventhubFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getEventhubNamespaceEventhubFilters = map[string]string{
	"akas":             "description.NamespaceEventhubs.ID",
	"id":               "description.NamespaceEventhubs.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.NamespaceEventhubs.Name",
	"tags":             "description.NamespaceEventhubs.Tags",
	"title":            "description.NamespaceEventhubs.Name",
}

func GetEventhubNamespaceEventhub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetEventhubNamespaceEventhub")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewEventhubNamespaceEventhubPaginator(essdk.BuildFilter(d.KeyColumnQuals, getEventhubNamespaceEventhubFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: EventhubNamespaceEventhub =============================

// ==========================  START: Frontdoor =============================

type Frontdoor struct {
	Description   azure.FrontdoorDescription `json:"description"`
	Metadata      azure.Metadata             `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type FrontdoorHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Frontdoor     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FrontdoorHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []FrontdoorHit    `json:"hits"`
}

type FrontdoorSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  FrontdoorHits `json:"hits"`
}

type FrontdoorPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFrontdoorPaginator(filters []essdk.BoolFilter, limit *int64) (FrontdoorPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_frontdoors", filters, limit)
	if err != nil {
		return FrontdoorPaginator{}, err
	}

	p := FrontdoorPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FrontdoorPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FrontdoorPaginator) NextPage(ctx context.Context) ([]Frontdoor, error) {
	var response FrontdoorSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Frontdoor
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFrontdoorFilters = map[string]string{
	"akas":                    "description.FrontDoor.ID",
	"backend_pools":           "description.FrontDoor.Properties.BackendPools",
	"backend_pools_settings":  "description.FrontDoor.Properties.BackendPoolsSettings",
	"cname":                   "description.FrontDoor.Properties.Cname",
	"diagnostic_settings":     "description.DiagnosticSettingsResources",
	"enabled_state":           "description.FrontDoor.Properties.EnabledState",
	"friendly_name":           "description.FrontDoor.Properties.FriendlyName",
	"front_door_id":           "description.FrontDoor.Properties.FrontdoorID",
	"frontend_endpoints":      "description.FrontDoor.Properties.FrontendEndpoints",
	"health_probe_settings":   "description.FrontDoor.Properties.HealthProbeSettings",
	"id":                      "description.FrontDoor.ID",
	"kaytu_account_id":        "metadata.SourceID",
	"load_balancing_settings": "description.FrontDoor.Properties.LoadBalancingSettings",
	"name":                    "description.FrontDoor.Name",
	"provisioning_state":      "description.FrontDoor.Properties.ProvisioningState",
	"region":                  "description.FrontDoor.Location",
	"resource_group":          "description.ResourceGroup",
	"resource_state":          "description.FrontDoor.Properties.ResourceState",
	"routing_rules":           "description.FrontDoor.Properties.RoutingRules",
	"rules_engines":           "description.FrontDoor.Properties.RulesEngines",
	"tags":                    "description.FrontDoor.Tags",
	"title":                   "description.FrontDoor.Name",
	"type":                    "description.FrontDoor.Type",
}

func ListFrontdoor(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFrontdoor")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewFrontdoorPaginator(essdk.BuildFilter(d.KeyColumnQuals, listFrontdoorFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getFrontdoorFilters = map[string]string{
	"akas":                    "description.FrontDoor.ID",
	"backend_pools":           "description.FrontDoor.Properties.BackendPools",
	"backend_pools_settings":  "description.FrontDoor.Properties.BackendPoolsSettings",
	"cname":                   "description.FrontDoor.Properties.Cname",
	"diagnostic_settings":     "description.DiagnosticSettingsResources",
	"enabled_state":           "description.FrontDoor.Properties.EnabledState",
	"friendly_name":           "description.FrontDoor.Properties.FriendlyName",
	"front_door_id":           "description.FrontDoor.Properties.FrontdoorID",
	"frontend_endpoints":      "description.FrontDoor.Properties.FrontendEndpoints",
	"health_probe_settings":   "description.FrontDoor.Properties.HealthProbeSettings",
	"id":                      "description.FrontDoor.ID",
	"kaytu_account_id":        "metadata.SourceID",
	"load_balancing_settings": "description.FrontDoor.Properties.LoadBalancingSettings",
	"name":                    "description.FrontDoor.name",
	"provisioning_state":      "description.FrontDoor.Properties.ProvisioningState",
	"region":                  "description.FrontDoor.Location",
	"resource_group":          "description.ResourceGroup",
	"resource_state":          "description.FrontDoor.Properties.ResourceState",
	"routing_rules":           "description.FrontDoor.Properties.RoutingRules",
	"rules_engines":           "description.FrontDoor.Properties.RulesEngines",
	"tags":                    "description.FrontDoor.Tags",
	"title":                   "description.FrontDoor.Name",
	"type":                    "description.FrontDoor.Type",
}

func GetFrontdoor(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFrontdoor")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewFrontdoorPaginator(essdk.BuildFilter(d.KeyColumnQuals, getFrontdoorFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Frontdoor =============================

// ==========================  START: HdinsightCluster =============================

type HdinsightCluster struct {
	Description   azure.HdinsightClusterDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type HdinsightClusterHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  HdinsightCluster `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type HdinsightClusterHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []HdinsightClusterHit `json:"hits"`
}

type HdinsightClusterSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  HdinsightClusterHits `json:"hits"`
}

type HdinsightClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHdinsightClusterPaginator(filters []essdk.BoolFilter, limit *int64) (HdinsightClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_hdinsight_clusters", filters, limit)
	if err != nil {
		return HdinsightClusterPaginator{}, err
	}

	p := HdinsightClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HdinsightClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HdinsightClusterPaginator) NextPage(ctx context.Context) ([]HdinsightCluster, error) {
	var response HdinsightClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HdinsightCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHdinsightClusterFilters = map[string]string{
	"akas":                             "description.Cluster.ID",
	"cluster_definition":               "description.Cluster.Properties.ClusterDefinition",
	"cluster_hdp_version":              "description.Cluster.Properties.ClusterHdpVersion",
	"cluster_id":                       "description.Cluster.Properties.ClusterID",
	"cluster_state":                    "description.Cluster.Properties.ClusterState",
	"cluster_version":                  "description.Cluster.Properties.ClusterVersion",
	"compute_isolation_properties":     "description.Cluster.Properties.ComputeIsolationProperties",
	"compute_profile":                  "description.Cluster.Properties.ComputeProfile",
	"connectivity_endpoints":           "description.Cluster.Properties.ConnectivityEndpoints",
	"created_date":                     "description.Cluster.Properties.CreatedDate",
	"diagnostic_settings":              "description.DiagnosticSettingsResources",
	"disk_encryption_properties":       "description.Cluster.Properties.DiskEncryptionProperties",
	"encryption_in_transit_properties": "description.Cluster.Properties.EncryptionInTransitProperties",
	"errors":                           "description.Cluster.Properties.Errors",
	"etag":                             "description.Cluster.Etag",
	"excluded_services_config":         "description.Cluster.Properties.ExcludedServicesConfig",
	"id":                               "description.Cluster.ID",
	"identity":                         "description.Cluster.Identity",
	"kafka_rest_properties":            "description.Cluster.Properties.KafkaRestProperties",
	"kaytu_account_id":                 "metadata.SourceID",
	"min_supported_tls_version":        "description.Cluster.Properties.MinSupportedTLSVersion",
	"name":                             "description.Cluster.Name",
	"network_properties":               "description.Cluster.Properties.NetworkProperties",
	"os_type":                          "description.Cluster.Properties.OsType",
	"provisioning_state":               "description.Cluster.Properties.ProvisioningState",
	"quota_info":                       "description.Cluster.Properties.QuotaInfo",
	"region":                           "description.Cluster.Location",
	"resource_group":                   "description.ResourceGroup",
	"security_profile":                 "description.Cluster.Properties.SecurityProfile",
	"storage_profile":                  "description.Cluster.Properties.StorageProfile",
	"tags":                             "description.Cluster.Tags",
	"tier":                             "description.Cluster.Properties.Tier",
	"title":                            "description.Cluster.Name",
	"type":                             "description.Cluster.Type",
}

func ListHdinsightCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHdinsightCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewHdinsightClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listHdinsightClusterFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getHdinsightClusterFilters = map[string]string{
	"akas":                             "description.Cluster.ID",
	"cluster_definition":               "description.Cluster.Properties.ClusterDefinition",
	"cluster_hdp_version":              "description.Cluster.Properties.ClusterHdpVersion",
	"cluster_id":                       "description.Cluster.Properties.ClusterID",
	"cluster_state":                    "description.Cluster.Properties.ClusterState",
	"cluster_version":                  "description.Cluster.Properties.ClusterVersion",
	"compute_isolation_properties":     "description.Cluster.Properties.ComputeIsolationProperties",
	"compute_profile":                  "description.Cluster.Properties.ComputeProfile",
	"connectivity_endpoints":           "description.Cluster.Properties.ConnectivityEndpoints",
	"created_date":                     "description.Cluster.Properties.CreatedDate",
	"diagnostic_settings":              "description.DiagnosticSettingsResources",
	"disk_encryption_properties":       "description.Cluster.Properties.DiskEncryptionProperties",
	"encryption_in_transit_properties": "description.Cluster.Properties.EncryptionInTransitProperties",
	"errors":                           "description.Cluster.Properties.Errors",
	"etag":                             "description.Cluster.Etag",
	"excluded_services_config":         "description.Cluster.Properties.ExcludedServicesConfig",
	"id":                               "description.Cluster.ID",
	"identity":                         "description.Cluster.Identity",
	"kafka_rest_properties":            "description.Cluster.Properties.KafkaRestProperties",
	"kaytu_account_id":                 "metadata.SourceID",
	"min_supported_tls_version":        "description.Cluster.Properties.MinSupportedTLSVersion",
	"name":                             "description.Cluster.name",
	"network_properties":               "description.Cluster.Properties.NetworkProperties",
	"os_type":                          "description.Cluster.Properties.OsType",
	"provisioning_state":               "description.Cluster.Properties.ProvisioningState",
	"quota_info":                       "description.Cluster.Properties.QuotaInfo",
	"region":                           "description.Cluster.Location",
	"resource_group":                   "description.ResourceGroup",
	"security_profile":                 "description.Cluster.Properties.SecurityProfile",
	"storage_profile":                  "description.Cluster.Properties.StorageProfile",
	"tags":                             "description.Cluster.Tags",
	"tier":                             "description.Cluster.Properties.Tier",
	"title":                            "description.Cluster.Name",
	"type":                             "description.Cluster.Type",
}

func GetHdinsightCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHdinsightCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewHdinsightClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getHdinsightClusterFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: HdinsightCluster =============================

// ==========================  START: HybridComputeMachine =============================

type HybridComputeMachine struct {
	Description   azure.HybridComputeMachineDescription `json:"description"`
	Metadata      azure.Metadata                        `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type HybridComputeMachineHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  HybridComputeMachine `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type HybridComputeMachineHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []HybridComputeMachineHit `json:"hits"`
}

type HybridComputeMachineSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  HybridComputeMachineHits `json:"hits"`
}

type HybridComputeMachinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHybridComputeMachinePaginator(filters []essdk.BoolFilter, limit *int64) (HybridComputeMachinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_hybridcompute_machines", filters, limit)
	if err != nil {
		return HybridComputeMachinePaginator{}, err
	}

	p := HybridComputeMachinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HybridComputeMachinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HybridComputeMachinePaginator) NextPage(ctx context.Context) ([]HybridComputeMachine, error) {
	var response HybridComputeMachineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HybridComputeMachine
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHybridComputeMachineFilters = map[string]string{
	"ad_fqdn":                       "description.Machine.MachinePropertiesModel.AdFqdn",
	"agent_version":                 "description.Machine.MachinePropertiesModel.AgentVersion",
	"akas":                          "description.Machine.ID",
	"client_public_key":             "description.Machine.MachinePropertiesModel.ClientPublicKey",
	"display_name":                  "description.Machine.MachinePropertiesModel.DisplayName",
	"dns_fqdn":                      "description.Machine.MachinePropertiesModel.DNSFqdn",
	"domain_name":                   "description.Machine.MachinePropertiesModel.DomainName",
	"error_details":                 "description.Machine.MachinePropertiesModel.ErrorDetails",
	"extensions":                    "description.MachineExtensions",
	"id":                            "description.Machine.ID",
	"identity":                      "description.Machine.Identity",
	"kaytu_account_id":              "metadata.SourceID",
	"last_status_change":            "description.Machine.MachinePropertiesModel.LastStatusChange",
	"location_data":                 "description.Machine.MachinePropertiesModel.LocationData",
	"machine_fqdn":                  "description.Machine.MachinePropertiesModel.MachineFqdn",
	"machine_properties_extensions": "description.Machine.MachinePropertiesModel.Extensions",
	"name":                          "description.Machine.Name",
	"os_name":                       "description.Machine.MachinePropertiesModel.OsName",
	"os_profile":                    "description.Machine.MachinePropertiesModel.OsProfile",
	"os_sku":                        "description.Machine.MachinePropertiesModel.OsSku",
	"os_version":                    "description.Machine.MachinePropertiesModel.OsVersion",
	"provisioning_state":            "description.Machine.MachinePropertiesModel.ProvisioningState",
	"region":                        "description.Machine.Location",
	"resource_group":                "description.ResourceGroup",
	"status":                        "description.Machine.MachinePropertiesModel.Status",
	"tags":                          "description.Machine.Tags",
	"title":                         "description.Machine.Name",
	"type":                          "description.Machine.Type",
	"vm_id":                         "description.Machine.MachinePropertiesModel.VMID",
	"vm_uuid":                       "description.Machine.MachinePropertiesModel.VMUUID",
}

func ListHybridComputeMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHybridComputeMachine")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewHybridComputeMachinePaginator(essdk.BuildFilter(d.KeyColumnQuals, listHybridComputeMachineFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getHybridComputeMachineFilters = map[string]string{
	"ad_fqdn":                       "description.Machine.MachinePropertiesModel.AdFqdn",
	"agent_version":                 "description.Machine.MachinePropertiesModel.AgentVersion",
	"akas":                          "description.Machine.ID",
	"client_public_key":             "description.Machine.MachinePropertiesModel.ClientPublicKey",
	"display_name":                  "description.Machine.MachinePropertiesModel.DisplayName",
	"dns_fqdn":                      "description.Machine.MachinePropertiesModel.DNSFqdn",
	"domain_name":                   "description.Machine.MachinePropertiesModel.DomainName",
	"error_details":                 "description.Machine.MachinePropertiesModel.ErrorDetails",
	"extensions":                    "description.MachineExtensions",
	"id":                            "description.Machine.ID",
	"identity":                      "description.Machine.Identity",
	"kaytu_account_id":              "metadata.SourceID",
	"last_status_change":            "description.Machine.MachinePropertiesModel.LastStatusChange",
	"location_data":                 "description.Machine.MachinePropertiesModel.LocationData",
	"machine_fqdn":                  "description.Machine.MachinePropertiesModel.MachineFqdn",
	"machine_properties_extensions": "description.Machine.MachinePropertiesModel.Extensions",
	"name":                          "description.Machine.name",
	"os_name":                       "description.Machine.MachinePropertiesModel.OsName",
	"os_profile":                    "description.Machine.MachinePropertiesModel.OsProfile",
	"os_sku":                        "description.Machine.MachinePropertiesModel.OsSku",
	"os_version":                    "description.Machine.MachinePropertiesModel.OsVersion",
	"provisioning_state":            "description.Machine.MachinePropertiesModel.ProvisioningState",
	"region":                        "description.Machine.Location",
	"resource_group":                "description.ResourceGroup",
	"status":                        "description.Machine.MachinePropertiesModel.Status",
	"tags":                          "description.Machine.Tags",
	"title":                         "description.Machine.Name",
	"type":                          "description.Machine.Type",
	"vm_id":                         "description.Machine.MachinePropertiesModel.VMID",
	"vm_uuid":                       "description.Machine.MachinePropertiesModel.VMUUID",
}

func GetHybridComputeMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHybridComputeMachine")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewHybridComputeMachinePaginator(essdk.BuildFilter(d.KeyColumnQuals, getHybridComputeMachineFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: HybridComputeMachine =============================

// ==========================  START: IOTHub =============================

type IOTHub struct {
	Description   azure.IOTHubDescription `json:"description"`
	Metadata      azure.Metadata          `json:"metadata"`
	ResourceJobID int                     `json:"resource_job_id"`
	SourceJobID   int                     `json:"source_job_id"`
	ResourceType  string                  `json:"resource_type"`
	SourceType    string                  `json:"source_type"`
	ID            string                  `json:"id"`
	ARN           string                  `json:"arn"`
	SourceID      string                  `json:"source_id"`
}

type IOTHubHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IOTHub        `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IOTHubHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IOTHubHit       `json:"hits"`
}

type IOTHubSearchResponse struct {
	PitID string     `json:"pit_id"`
	Hits  IOTHubHits `json:"hits"`
}

type IOTHubPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIOTHubPaginator(filters []essdk.BoolFilter, limit *int64) (IOTHubPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_devices_iothubs", filters, limit)
	if err != nil {
		return IOTHubPaginator{}, err
	}

	p := IOTHubPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IOTHubPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IOTHubPaginator) NextPage(ctx context.Context) ([]IOTHub, error) {
	var response IOTHubSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IOTHub
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIOTHubFilters = map[string]string{
	"akas":                             "description.IotHubDescription.ID",
	"authorization_policies":           "description.IotHubDescription.Properties.AuthorizationPolicies",
	"cloud_to_device":                  "description.IotHubDescription.Properties.CloudToDevice",
	"comments":                         "description.IotHubDescription.Properties.Comments",
	"diagnostic_settings":              "description.DiagnosticSettingsResources",
	"enable_file_upload_notifications": "description.IotHubDescription.Properties.EnableFileUploadNotifications",
	"etag":                             "description.IotHubDescription.Etag",
	"event_hub_endpoints":              "description.IotHubDescription.Properties.EventHubEndpoints",
	"features":                         "description.IotHubDescription.Properties.Features",
	"host_name":                        "description.IotHubDescription.Properties.HostName",
	"id":                               "description.IotHubDescription.ID",
	"ip_filter_rules":                  "description.IotHubDescription.Properties.IPFilterRules",
	"kaytu_account_id":                 "metadata.SourceID",
	"locations":                        "description.IotHubDescription.Properties.Locations",
	"messaging_endpoints":              "description.IotHubDescription.Properties.MessagingEndpoints",
	"min_tls_version":                  "description.IotHubDescription.Properties.MinTLSVersion",
	"name":                             "description.IotHubDescription.Name",
	"private_endpoint_connections":     "description.IotHubDescription.Properties.PrivateEndpointConnections",
	"provisioning_state":               "description.IotHubDescription.Properties.ProvisioningState",
	"public_network_access":            "description.IotHubDescription.Properties.PublicNetworkAccess",
	"region":                           "description.IotHubDescription.Location",
	"resource_group":                   "description.ResourceGroup",
	"routing":                          "description.IotHubDescription.Properties.Routing",
	"sku_capacity":                     "description.IotHubDescription.Sku.Capacity",
	"sku_name":                         "description.IotHubDescription.Sku.Name",
	"sku_tier":                         "description.IotHubDescription.Sku.Tier",
	"state":                            "description.IotHubDescription.Properties.State",
	"storage_endpoints":                "description.IotHubDescription.Properties.StorageEndpoints",
	"tags":                             "description.IotHubDescription.Tags",
	"title":                            "description.IotHubDescription.Name",
	"type":                             "description.IotHubDescription.Type",
}

func ListIOTHub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIOTHub")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIOTHubPaginator(essdk.BuildFilter(d.KeyColumnQuals, listIOTHubFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIOTHubFilters = map[string]string{
	"akas":                             "description.IotHubDescription.ID",
	"authorization_policies":           "description.IotHubDescription.Properties.AuthorizationPolicies",
	"cloud_to_device":                  "description.IotHubDescription.Properties.CloudToDevice",
	"comments":                         "description.IotHubDescription.Properties.Comments",
	"diagnostic_settings":              "description.DiagnosticSettingsResources",
	"enable_file_upload_notifications": "description.IotHubDescription.Properties.EnableFileUploadNotifications",
	"etag":                             "description.IotHubDescription.Etag",
	"event_hub_endpoints":              "description.IotHubDescription.Properties.EventHubEndpoints",
	"features":                         "description.IotHubDescription.Properties.Features",
	"host_name":                        "description.IotHubDescription.Properties.HostName",
	"id":                               "description.IotHubDescription.ID",
	"ip_filter_rules":                  "description.IotHubDescription.Properties.IPFilterRules",
	"kaytu_account_id":                 "metadata.SourceID",
	"locations":                        "description.IotHubDescription.Properties.Locations",
	"messaging_endpoints":              "description.IotHubDescription.Properties.MessagingEndpoints",
	"min_tls_version":                  "description.IotHubDescription.Properties.MinTLSVersion",
	"name":                             "description.IotHubDescription.name",
	"private_endpoint_connections":     "description.IotHubDescription.Properties.PrivateEndpointConnections",
	"provisioning_state":               "description.IotHubDescription.Properties.ProvisioningState",
	"public_network_access":            "description.IotHubDescription.Properties.PublicNetworkAccess",
	"region":                           "description.IotHubDescription.Location",
	"resource_group":                   "description.ResourceGroup",
	"routing":                          "description.IotHubDescription.Properties.Routing",
	"sku_capacity":                     "description.IotHubDescription.Sku.Capacity",
	"sku_name":                         "description.IotHubDescription.Sku.Name",
	"sku_tier":                         "description.IotHubDescription.Sku.Tier",
	"state":                            "description.IotHubDescription.Properties.State",
	"storage_endpoints":                "description.IotHubDescription.Properties.StorageEndpoints",
	"tags":                             "description.IotHubDescription.Tags",
	"title":                            "description.IotHubDescription.Name",
	"type":                             "description.IotHubDescription.Type",
}

func GetIOTHub(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIOTHub")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIOTHubPaginator(essdk.BuildFilter(d.KeyColumnQuals, getIOTHubFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IOTHub =============================

// ==========================  START: IOTHubDps =============================

type IOTHubDps struct {
	Description   azure.IOTHubDpsDescription `json:"description"`
	Metadata      azure.Metadata             `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type IOTHubDpsHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  IOTHubDps     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type IOTHubDpsHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []IOTHubDpsHit    `json:"hits"`
}

type IOTHubDpsSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  IOTHubDpsHits `json:"hits"`
}

type IOTHubDpsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewIOTHubDpsPaginator(filters []essdk.BoolFilter, limit *int64) (IOTHubDpsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_devices_iothubdpses", filters, limit)
	if err != nil {
		return IOTHubDpsPaginator{}, err
	}

	p := IOTHubDpsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p IOTHubDpsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p IOTHubDpsPaginator) NextPage(ctx context.Context) ([]IOTHubDps, error) {
	var response IOTHubDpsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []IOTHubDps
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listIOTHubDpsFilters = map[string]string{
	"akas":                          "description.IotHubDps.ID",
	"allocation_policy":             "description.IotHubDps.Properties.AllocationPolicy",
	"authorization_policies":        "description.IotHubDps.Properties.AuthorizationPolicies",
	"device_provisioning_host_name": "description.IotHubDps.Properties.DeviceProvisioningHostName",
	"diagnostic_settings":           "description.DiagnosticSettingsResources",
	"etag":                          "description.IotHubDps.Etag",
	"id":                            "description.IotHubDps.ID",
	"id_scope":                      "description.IotHubDps.Properties.IDScope",
	"iot_hubs":                      "description.IotHubDps.Properties.IotHubs",
	"kaytu_account_id":              "metadata.SourceID",
	"name":                          "description.IotHubDps.Name",
	"provisioning_state":            "description.IotHubDps.Properties.ProvisioningState",
	"region":                        "description.IotHubDps.Location",
	"resource_group":                "description.ResourceGroup",
	"service_operations_host_name":  "description.IotHubDps.Properties.ServiceOperationsHostName",
	"sku_capacity":                  "description.IotHubDps.Sku.Capacity",
	"sku_name":                      "description.IotHubDps.Sku.Name",
	"sku_tier":                      "description.IotHubDps.Sku.Tier",
	"state":                         "description.IotHubDps.Properties.State",
	"tags":                          "description.IotHubDps.Tags",
	"title":                         "description.IotHubDps.Name",
	"type":                          "description.IotHubDps.Type",
}

func ListIOTHubDps(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListIOTHubDps")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewIOTHubDpsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listIOTHubDpsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getIOTHubDpsFilters = map[string]string{
	"akas":                          "description.IotHubDps.ID",
	"allocation_policy":             "description.IotHubDps.Properties.AllocationPolicy",
	"authorization_policies":        "description.IotHubDps.Properties.AuthorizationPolicies",
	"device_provisioning_host_name": "description.IotHubDps.Properties.DeviceProvisioningHostName",
	"diagnostic_settings":           "description.DiagnosticSettingsResources",
	"etag":                          "description.IotHubDps.Etag",
	"id":                            "description.IotHubDps.ID",
	"id_scope":                      "description.IotHubDps.Properties.IDScope",
	"iot_hubs":                      "description.IotHubDps.Properties.IotHubs",
	"kaytu_account_id":              "metadata.SourceID",
	"name":                          "description.IotHubDps.name",
	"provisioning_state":            "description.IotHubDps.Properties.ProvisioningState",
	"region":                        "description.IotHubDps.Location",
	"resource_group":                "description.ResourceGroup",
	"service_operations_host_name":  "description.IotHubDps.Properties.ServiceOperationsHostName",
	"sku_capacity":                  "description.IotHubDps.Sku.Capacity",
	"sku_name":                      "description.IotHubDps.Sku.Name",
	"sku_tier":                      "description.IotHubDps.Sku.Tier",
	"state":                         "description.IotHubDps.Properties.State",
	"tags":                          "description.IotHubDps.Tags",
	"title":                         "description.IotHubDps.Name",
	"type":                          "description.IotHubDps.Type",
}

func GetIOTHubDps(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetIOTHubDps")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewIOTHubDpsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getIOTHubDpsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: IOTHubDps =============================

// ==========================  START: KeyVault =============================

type KeyVault struct {
	Description   azure.KeyVaultDescription `json:"description"`
	Metadata      azure.Metadata            `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type KeyVaultHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KeyVault      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KeyVaultHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []KeyVaultHit     `json:"hits"`
}

type KeyVaultSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  KeyVaultHits `json:"hits"`
}

type KeyVaultPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyVaultPaginator(filters []essdk.BoolFilter, limit *int64) (KeyVaultPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_keyvault_vaults", filters, limit)
	if err != nil {
		return KeyVaultPaginator{}, err
	}

	p := KeyVaultPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyVaultPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyVaultPaginator) NextPage(ctx context.Context) ([]KeyVault, error) {
	var response KeyVaultSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVault
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultFilters = map[string]string{
	"akas":                            "description.Vault.ID",
	"create_mode":                     "description.Vault.Properties.CreateMode",
	"diagnostic_settings":             "description.DiagnosticSettingsResources",
	"enable_rbac_authorization":       "description.Vault.Properties.EnableRbacAuthorization",
	"enabled_for_deployment":          "description.Vault.Properties.EnabledForDeployment",
	"enabled_for_disk_encryption":     "description.Vault.Properties.EnabledForDiskEncryption",
	"enabled_for_template_deployment": "description.Vault.Properties.EnabledForTemplateDeployment",
	"id":                              "description.Vault.ID",
	"kaytu_account_id":                "metadata.SourceID",
	"name":                            "description.Vault.Name",
	"network_acls":                    "description.Vault.Properties.NetworkAcls",
	"purge_protection_enabled":        "description.Vault.Properties.EnablePurgeProtection",
	"region":                          "description.Vault.Location",
	"resource_group":                  "description.ResourceGroup",
	"sku_family":                      "description.Vault.Properties.Sku.Family",
	"sku_name":                        "description.Vault.Properties.Sku.Name",
	"soft_delete_enabled":             "description.Vault.Properties.EnableSoftDelete",
	"soft_delete_retention_in_days":   "description.Vault.Properties.SoftDeleteRetentionInDays",
	"tags":                            "description.Vault.Tags",
	"tenant_id":                       "description.Vault.Properties.TenantID",
	"title":                           "description.Vault.Name",
	"type":                            "description.Vault.Type",
	"vault_uri":                       "description.Vault.Properties.VaultURI",
}

func ListKeyVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVault")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKeyVaultPaginator(essdk.BuildFilter(d.KeyColumnQuals, listKeyVaultFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKeyVaultFilters = map[string]string{
	"akas":                            "description.Vault.ID",
	"create_mode":                     "description.Vault.Properties.CreateMode",
	"diagnostic_settings":             "description.DiagnosticSettingsResources",
	"enable_rbac_authorization":       "description.Vault.Properties.EnableRbacAuthorization",
	"enabled_for_deployment":          "description.Vault.Properties.EnabledForDeployment",
	"enabled_for_disk_encryption":     "description.Vault.Properties.EnabledForDiskEncryption",
	"enabled_for_template_deployment": "description.Vault.Properties.EnabledForTemplateDeployment",
	"id":                              "description.Vault.ID",
	"kaytu_account_id":                "metadata.SourceID",
	"name":                            "description.Resource.name",
	"network_acls":                    "description.Vault.Properties.NetworkAcls",
	"purge_protection_enabled":        "description.Vault.Properties.EnablePurgeProtection",
	"region":                          "description.Vault.Location",
	"resource_group":                  "description.ResourceGroup",
	"sku_family":                      "description.Vault.Properties.Sku.Family",
	"sku_name":                        "description.Vault.Properties.Sku.Name",
	"soft_delete_enabled":             "description.Vault.Properties.EnableSoftDelete",
	"soft_delete_retention_in_days":   "description.Vault.Properties.SoftDeleteRetentionInDays",
	"tags":                            "description.Vault.Tags",
	"tenant_id":                       "description.Vault.Properties.TenantID",
	"title":                           "description.Vault.Name",
	"type":                            "description.Vault.Type",
	"vault_uri":                       "description.Vault.Properties.VaultURI",
}

func GetKeyVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVault")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKeyVaultPaginator(essdk.BuildFilter(d.KeyColumnQuals, getKeyVaultFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KeyVault =============================

// ==========================  START: KeyVaultDeletedVault =============================

type KeyVaultDeletedVault struct {
	Description   azure.KeyVaultDeletedVaultDescription `json:"description"`
	Metadata      azure.Metadata                        `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type KeyVaultDeletedVaultHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  KeyVaultDeletedVault `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type KeyVaultDeletedVaultHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []KeyVaultDeletedVaultHit `json:"hits"`
}

type KeyVaultDeletedVaultSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  KeyVaultDeletedVaultHits `json:"hits"`
}

type KeyVaultDeletedVaultPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyVaultDeletedVaultPaginator(filters []essdk.BoolFilter, limit *int64) (KeyVaultDeletedVaultPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_keyvault_deletedvaults", filters, limit)
	if err != nil {
		return KeyVaultDeletedVaultPaginator{}, err
	}

	p := KeyVaultDeletedVaultPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyVaultDeletedVaultPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyVaultDeletedVaultPaginator) NextPage(ctx context.Context) ([]KeyVaultDeletedVault, error) {
	var response KeyVaultDeletedVaultSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVaultDeletedVault
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultDeletedVaultFilters = map[string]string{
	"akas":                 "description.Vault.ID",
	"deletion_date":        "description.Vault.Properties.DeletionDate",
	"id":                   "description.Vault.ID",
	"kaytu_account_id":     "metadata.SourceID",
	"name":                 "description.Vault.Name",
	"region":               "description.Vault.Properties.Location",
	"resource_group":       "description.ResourceGroup",
	"scheduled_purge_date": "description.Vault.Properties.ScheduledPurgeDate",
	"tags":                 "description.Vault.Properties.Tags",
	"title":                "description.Vault.Name",
	"type":                 "description.Vault.Type",
	"vault_id":             "description.Vault.Properties.VaultID",
}

func ListKeyVaultDeletedVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVaultDeletedVault")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKeyVaultDeletedVaultPaginator(essdk.BuildFilter(d.KeyColumnQuals, listKeyVaultDeletedVaultFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKeyVaultDeletedVaultFilters = map[string]string{
	"akas":                 "description.Vault.ID",
	"deletion_date":        "description.Vault.Properties.DeletionDate",
	"id":                   "description.Vault.ID",
	"kaytu_account_id":     "metadata.SourceID",
	"name":                 "description.Vault.name",
	"region":               "description.Vault.Properties.Location",
	"resource_group":       "description.ResourceGroup",
	"scheduled_purge_date": "description.Vault.Properties.ScheduledPurgeDate",
	"tags":                 "description.Vault.Properties.Tags",
	"title":                "description.Vault.Name",
	"type":                 "description.Vault.Type",
	"vault_id":             "description.Vault.Properties.VaultID",
}

func GetKeyVaultDeletedVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVaultDeletedVault")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKeyVaultDeletedVaultPaginator(essdk.BuildFilter(d.KeyColumnQuals, getKeyVaultDeletedVaultFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KeyVaultDeletedVault =============================

// ==========================  START: KeyVaultManagedHardwareSecurityModule =============================

type KeyVaultManagedHardwareSecurityModule struct {
	Description   azure.KeyVaultManagedHardwareSecurityModuleDescription `json:"description"`
	Metadata      azure.Metadata                                         `json:"metadata"`
	ResourceJobID int                                                    `json:"resource_job_id"`
	SourceJobID   int                                                    `json:"source_job_id"`
	ResourceType  string                                                 `json:"resource_type"`
	SourceType    string                                                 `json:"source_type"`
	ID            string                                                 `json:"id"`
	ARN           string                                                 `json:"arn"`
	SourceID      string                                                 `json:"source_id"`
}

type KeyVaultManagedHardwareSecurityModuleHit struct {
	ID      string                                `json:"_id"`
	Score   float64                               `json:"_score"`
	Index   string                                `json:"_index"`
	Type    string                                `json:"_type"`
	Version int64                                 `json:"_version,omitempty"`
	Source  KeyVaultManagedHardwareSecurityModule `json:"_source"`
	Sort    []interface{}                         `json:"sort"`
}

type KeyVaultManagedHardwareSecurityModuleHits struct {
	Total essdk.SearchTotal                          `json:"total"`
	Hits  []KeyVaultManagedHardwareSecurityModuleHit `json:"hits"`
}

type KeyVaultManagedHardwareSecurityModuleSearchResponse struct {
	PitID string                                    `json:"pit_id"`
	Hits  KeyVaultManagedHardwareSecurityModuleHits `json:"hits"`
}

type KeyVaultManagedHardwareSecurityModulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyVaultManagedHardwareSecurityModulePaginator(filters []essdk.BoolFilter, limit *int64) (KeyVaultManagedHardwareSecurityModulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_keyvault_managedhsms", filters, limit)
	if err != nil {
		return KeyVaultManagedHardwareSecurityModulePaginator{}, err
	}

	p := KeyVaultManagedHardwareSecurityModulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyVaultManagedHardwareSecurityModulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyVaultManagedHardwareSecurityModulePaginator) NextPage(ctx context.Context) ([]KeyVaultManagedHardwareSecurityModule, error) {
	var response KeyVaultManagedHardwareSecurityModuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVaultManagedHardwareSecurityModule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultManagedHardwareSecurityModuleFilters = map[string]string{
	"akas":                          "description.ManagedHsm.ID",
	"create_mode":                   "description.ManagedHsm.Properties.CreateMode",
	"diagnostic_settings":           "description.DiagnosticSettingsResources",
	"enable_purge_protection":       "description.ManagedHsm.Properties.EnablePurgeProtection",
	"enable_soft_delete":            "description.ManagedHsm.Properties.EnableSoftDelete",
	"hsm_uri":                       "description.ManagedHsm.Properties.HsmURI",
	"id":                            "description.ManagedHsm.ID",
	"kaytu_account_id":              "metadata.SourceID",
	"name":                          "description.ManagedHsm.Name",
	"provisioning_state":            "description.ManagedHsm.Properties.ProvisioningState",
	"region":                        "description.ManagedHsm.Location",
	"resource_group":                "description.ResourceGroup",
	"sku_family":                    "description.ManagedHsm.Sku.Family",
	"sku_name":                      "description.ManagedHsm.Sku.Name",
	"soft_delete_retention_in_days": "description.ManagedHsm.Properties.SoftDeleteRetentionInDays",
	"status_message":                "description.ManagedHsm.Properties.StatusMessage",
	"tags":                          "description.ManagedHsm.Tags",
	"tenant_id":                     "description.ManagedHsm.Properties.TenantID",
	"title":                         "description.ManagedHsm.Name",
	"type":                          "description.ManagedHsm.Type",
}

func ListKeyVaultManagedHardwareSecurityModule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVaultManagedHardwareSecurityModule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKeyVaultManagedHardwareSecurityModulePaginator(essdk.BuildFilter(d.KeyColumnQuals, listKeyVaultManagedHardwareSecurityModuleFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKeyVaultManagedHardwareSecurityModuleFilters = map[string]string{
	"akas":                          "description.ManagedHsm.ID",
	"create_mode":                   "description.ManagedHsm.Properties.CreateMode",
	"diagnostic_settings":           "description.DiagnosticSettingsResources",
	"enable_purge_protection":       "description.ManagedHsm.Properties.EnablePurgeProtection",
	"enable_soft_delete":            "description.ManagedHsm.Properties.EnableSoftDelete",
	"hsm_uri":                       "description.ManagedHsm.Properties.HsmURI",
	"id":                            "description.ManagedHsm.ID",
	"kaytu_account_id":              "metadata.SourceID",
	"name":                          "description.ManagedHsm.name",
	"provisioning_state":            "description.ManagedHsm.Properties.ProvisioningState",
	"region":                        "description.ManagedHsm.Location",
	"resource_group":                "description.ResourceGroup",
	"sku_family":                    "description.ManagedHsm.Sku.Family",
	"sku_name":                      "description.ManagedHsm.Sku.Name",
	"soft_delete_retention_in_days": "description.ManagedHsm.Properties.SoftDeleteRetentionInDays",
	"status_message":                "description.ManagedHsm.Properties.StatusMessage",
	"tags":                          "description.ManagedHsm.Tags",
	"tenant_id":                     "description.ManagedHsm.Properties.TenantID",
	"title":                         "description.ManagedHsm.Name",
	"type":                          "description.ManagedHsm.Type",
}

func GetKeyVaultManagedHardwareSecurityModule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVaultManagedHardwareSecurityModule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKeyVaultManagedHardwareSecurityModulePaginator(essdk.BuildFilter(d.KeyColumnQuals, getKeyVaultManagedHardwareSecurityModuleFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KeyVaultManagedHardwareSecurityModule =============================

// ==========================  START: KeyVaultSecret =============================

type KeyVaultSecret struct {
	Description   azure.KeyVaultSecretDescription `json:"description"`
	Metadata      azure.Metadata                  `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type KeyVaultSecretHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  KeyVaultSecret `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type KeyVaultSecretHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []KeyVaultSecretHit `json:"hits"`
}

type KeyVaultSecretSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  KeyVaultSecretHits `json:"hits"`
}

type KeyVaultSecretPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKeyVaultSecretPaginator(filters []essdk.BoolFilter, limit *int64) (KeyVaultSecretPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_keyvault_vaults_secrets", filters, limit)
	if err != nil {
		return KeyVaultSecretPaginator{}, err
	}

	p := KeyVaultSecretPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KeyVaultSecretPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KeyVaultSecretPaginator) NextPage(ctx context.Context) ([]KeyVaultSecret, error) {
	var response KeyVaultSecretSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KeyVaultSecret
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKeyVaultSecretFilters = map[string]string{
	"akas":             "description.SecretItem.ID",
	"content_type":     "description.SecretItem.ContentType",
	"created_at":       "description.SecretItem.Attributes.Created",
	"enabled":          "description.SecretItem.Attributes.Enabled",
	"expires_at":       "description.SecretItem.Attributes.Expires",
	"kaytu_account_id": "metadata.SourceID",
	"kid":              "description.SecretBundle.Kid",
	"managed":          "description.SecretItem.Managed",
	"not_before":       "description.SecretItem.Attributes.NotBefore",
	"recoverable_days": "description.SecretItem.Attributes.RecoverableDays",
	"recovery_level":   "description.SecretItem.Attributes.RecoveryLevel",
	"region":           "description.SecretBundle",
	"resource_group":   "description.ResourceGroup",
	"tags":             "description.SecretItem.Tags",
	"updated_at":       "description.SecretItem.Attributes.Updated",
	"value":            "description.SecretBundle.Value",
}

func ListKeyVaultSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKeyVaultSecret")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKeyVaultSecretPaginator(essdk.BuildFilter(d.KeyColumnQuals, listKeyVaultSecretFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKeyVaultSecretFilters = map[string]string{
	"akas":             "description.SecretItem.ID",
	"content_type":     "description.SecretItem.ContentType",
	"created_at":       "description.SecretItem.Attributes.Created",
	"enabled":          "description.SecretItem.Attributes.Enabled",
	"expires_at":       "description.SecretItem.Attributes.Expires",
	"kaytu_account_id": "metadata.SourceID",
	"kid":              "description.SecretBundle.Kid",
	"managed":          "description.SecretItem.Managed",
	"name":             "description.SecretItem.name",
	"not_before":       "description.SecretItem.Attributes.NotBefore",
	"recoverable_days": "description.SecretItem.Attributes.RecoverableDays",
	"recovery_level":   "description.SecretItem.Attributes.RecoveryLevel",
	"region":           "description.SecretBundle",
	"resource_group":   "description.ResourceGroup",
	"tags":             "description.SecretItem.Tags",
	"updated_at":       "description.SecretItem.Attributes.Updated",
	"value":            "description.SecretBundle.Value",
}

func GetKeyVaultSecret(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKeyVaultSecret")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKeyVaultSecretPaginator(essdk.BuildFilter(d.KeyColumnQuals, getKeyVaultSecretFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KeyVaultSecret =============================

// ==========================  START: KustoCluster =============================

type KustoCluster struct {
	Description   azure.KustoClusterDescription `json:"description"`
	Metadata      azure.Metadata                `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type KustoClusterHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  KustoCluster  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type KustoClusterHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []KustoClusterHit `json:"hits"`
}

type KustoClusterSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  KustoClusterHits `json:"hits"`
}

type KustoClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewKustoClusterPaginator(filters []essdk.BoolFilter, limit *int64) (KustoClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_kusto_clusters", filters, limit)
	if err != nil {
		return KustoClusterPaginator{}, err
	}

	p := KustoClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p KustoClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p KustoClusterPaginator) NextPage(ctx context.Context) ([]KustoCluster, error) {
	var response KustoClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []KustoCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listKustoClusterFilters = map[string]string{
	"akas":                          "description.Cluster.ID",
	"data_ingestion_uri":            "description.Cluster.ClusterProperties.DataIngestionURI",
	"enable_disk_encryption":        "description.Cluster.ClusterProperties.EnableDiskEncryption",
	"enable_double_encryption":      "description.Cluster.ClusterProperties.EnableDoubleEncryption",
	"enable_purge":                  "description.Cluster.ClusterProperties.EnablePurge",
	"enable_streaming_ingest":       "description.Cluster.ClusterProperties.EnableStreamingIngest",
	"engine_type":                   "description.Cluster.ClusterProperties.EngineType",
	"etag":                          "description.Cluster.Etag",
	"id":                            "description.Cluster.ID",
	"kaytu_account_id":              "metadata.SourceID",
	"key_vault_properties":          "description.Cluster.ClusterProperties.KeyVaultProperties",
	"language_extensions":           "description.Cluster.ClusterProperties.LanguageExtensions",
	"location":                      "description.Cluster.Location",
	"name":                          "description.Cluster.Name",
	"optimized_autoscale":           "description.Cluster.ClusterProperties.OptimizedAutoscale",
	"provisioning_state":            "description.Cluster.ClusterProperties.ProvisioningState",
	"region":                        "description.Cluster.Location",
	"resource_group":                "description.ResourceGroup",
	"sku_capacity":                  "description.Cluster.Sku.Capacity",
	"sku_name":                      "description.Cluster.Sku.Name",
	"sku_tier":                      "description.Cluster.Sku.Tier",
	"state":                         "description.Cluster.ClusterProperties.State",
	"state_reason":                  "description.Cluster.ClusterProperties.StateReason",
	"tags":                          "description.Cluster.Tags",
	"title":                         "description.Cluster.Name",
	"trusted_external_tenants":      "description.Cluster.ClusterProperties.TrustedExternalTenants",
	"type":                          "description.Cluster.Type",
	"uri":                           "clusterProperties.URI",
	"virtual_network_configuration": "description.Cluster.ClusterProperties.VirtualNetworkConfiguration",
}

func ListKustoCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListKustoCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewKustoClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listKustoClusterFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getKustoClusterFilters = map[string]string{
	"akas":                          "description.Cluster.ID",
	"data_ingestion_uri":            "description.Cluster.ClusterProperties.DataIngestionURI",
	"enable_disk_encryption":        "description.Cluster.ClusterProperties.EnableDiskEncryption",
	"enable_double_encryption":      "description.Cluster.ClusterProperties.EnableDoubleEncryption",
	"enable_purge":                  "description.Cluster.ClusterProperties.EnablePurge",
	"enable_streaming_ingest":       "description.Cluster.ClusterProperties.EnableStreamingIngest",
	"engine_type":                   "description.Cluster.ClusterProperties.EngineType",
	"etag":                          "description.Cluster.Etag",
	"id":                            "description.Cluster.ID",
	"kaytu_account_id":              "metadata.SourceID",
	"key_vault_properties":          "description.Cluster.ClusterProperties.KeyVaultProperties",
	"language_extensions":           "description.Cluster.ClusterProperties.LanguageExtensions",
	"location":                      "description.Cluster.Location",
	"name":                          "description.Cluster.name",
	"optimized_autoscale":           "description.Cluster.ClusterProperties.OptimizedAutoscale",
	"provisioning_state":            "description.Cluster.ClusterProperties.ProvisioningState",
	"region":                        "description.Cluster.Location",
	"resource_group":                "description.ResourceGroup",
	"sku_capacity":                  "description.Cluster.Sku.Capacity",
	"sku_name":                      "description.Cluster.Sku.Name",
	"sku_tier":                      "description.Cluster.Sku.Tier",
	"state":                         "description.Cluster.ClusterProperties.State",
	"state_reason":                  "description.Cluster.ClusterProperties.StateReason",
	"tags":                          "description.Cluster.Tags",
	"title":                         "description.Cluster.Name",
	"trusted_external_tenants":      "description.Cluster.ClusterProperties.TrustedExternalTenants",
	"type":                          "description.Cluster.Type",
	"uri":                           "clusterProperties.URI",
	"virtual_network_configuration": "description.Cluster.ClusterProperties.VirtualNetworkConfiguration",
}

func GetKustoCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetKustoCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewKustoClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getKustoClusterFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: KustoCluster =============================

// ==========================  START: LogAlert =============================

type LogAlert struct {
	Description   azure.LogAlertDescription `json:"description"`
	Metadata      azure.Metadata            `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type LogAlertHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  LogAlert      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LogAlertHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LogAlertHit     `json:"hits"`
}

type LogAlertSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  LogAlertHits `json:"hits"`
}

type LogAlertPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLogAlertPaginator(filters []essdk.BoolFilter, limit *int64) (LogAlertPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_insights_activitylogalerts", filters, limit)
	if err != nil {
		return LogAlertPaginator{}, err
	}

	p := LogAlertPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LogAlertPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LogAlertPaginator) NextPage(ctx context.Context) ([]LogAlert, error) {
	var response LogAlertSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LogAlert
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLogAlertFilters = map[string]string{
	"actions":          "description.ActivityLogAlertResource.ActivityLogAlert.Actions",
	"akas":             "description.ActivityLogAlertResource.ID",
	"condition":        "description.ActivityLogAlertResource.ActivityLogAlert.Condition",
	"description":      "description.ActivityLogAlertResource.ActivityLogAlert.Description",
	"enabled":          "description.ActivityLogAlertResource.ActivityLogAlert.Enabled",
	"id":               "description.ActivityLogAlertResource.ID",
	"kaytu_account_id": "metadata.SourceID",
	"location":         "description.ActivityLogAlertResource.Location",
	"name":             "description.ActivityLogAlertResource.Name",
	"region":           "description.ActivityLogAlertResource.Location",
	"resource_group":   "description.ResourceGroup",
	"scopes":           "description.ActivityLogAlertResource.ActivityLogAlert.Scopes",
	"tags":             "description.ActivityLogAlertResource.Tags",
	"title":            "description.ActivityLogAlertResource.Name",
	"type":             "description.ActivityLogAlertResource.Type",
}

func ListLogAlert(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLogAlert")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLogAlertPaginator(essdk.BuildFilter(d.KeyColumnQuals, listLogAlertFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLogAlertFilters = map[string]string{
	"actions":          "description.ActivityLogAlertResource.ActivityLogAlert.Actions",
	"akas":             "description.ActivityLogAlertResource.ID",
	"condition":        "description.ActivityLogAlertResource.ActivityLogAlert.Condition",
	"description":      "description.ActivityLogAlertResource.ActivityLogAlert.Description",
	"enabled":          "description.ActivityLogAlertResource.ActivityLogAlert.Enabled",
	"id":               "description.ActivityLogAlertResource.ID",
	"kaytu_account_id": "metadata.SourceID",
	"location":         "description.ActivityLogAlertResource.Location",
	"name":             "description.ActivityLogAlertResource.name",
	"region":           "description.ActivityLogAlertResource.Location",
	"resource_group":   "description.ResourceGroup",
	"scopes":           "description.ActivityLogAlertResource.ActivityLogAlert.Scopes",
	"tags":             "description.ActivityLogAlertResource.Tags",
	"title":            "description.ActivityLogAlertResource.Name",
	"type":             "description.ActivityLogAlertResource.Type",
}

func GetLogAlert(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLogAlert")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLogAlertPaginator(essdk.BuildFilter(d.KeyColumnQuals, getLogAlertFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LogAlert =============================

// ==========================  START: LogProfile =============================

type LogProfile struct {
	Description   azure.LogProfileDescription `json:"description"`
	Metadata      azure.Metadata              `json:"metadata"`
	ResourceJobID int                         `json:"resource_job_id"`
	SourceJobID   int                         `json:"source_job_id"`
	ResourceType  string                      `json:"resource_type"`
	SourceType    string                      `json:"source_type"`
	ID            string                      `json:"id"`
	ARN           string                      `json:"arn"`
	SourceID      string                      `json:"source_id"`
}

type LogProfileHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  LogProfile    `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LogProfileHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LogProfileHit   `json:"hits"`
}

type LogProfileSearchResponse struct {
	PitID string         `json:"pit_id"`
	Hits  LogProfileHits `json:"hits"`
}

type LogProfilePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLogProfilePaginator(filters []essdk.BoolFilter, limit *int64) (LogProfilePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_insights_logprofiles", filters, limit)
	if err != nil {
		return LogProfilePaginator{}, err
	}

	p := LogProfilePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LogProfilePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LogProfilePaginator) NextPage(ctx context.Context) ([]LogProfile, error) {
	var response LogProfileSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LogProfile
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLogProfileFilters = map[string]string{
	"akas":                "description.LogProfileResource.ID",
	"categories":          "description.LogProfileResource.LogProfileProperties.Categories",
	"id":                  "description.LogProfileResource.ID",
	"kaytu_account_id":    "metadata.SourceID",
	"location":            "description.LogProfileResource.Location",
	"log_event_location":  "description.LogProfileResource.LogProfileProperties.Locations",
	"name":                "description.LogProfileResource.Name",
	"region":              "description.LogProfileResource.Location",
	"resource_group":      "description.ResourceGroup",
	"retention_policy":    "description.LogProfileResource.LogProfileProperties.RetentionPolicy",
	"service_bus_rule_id": "description.LogProfileResource.LogProfileProperties.ServiceBusRuleID",
	"storage_account_id":  "description.LogProfileResource.LogProfileProperties.StorageAccountID",
	"tags":                "description.LogProfileResource.Tags",
	"title":               "description.LogProfileResource.Name",
	"type":                "description.LogProfileResource.Type",
}

func ListLogProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLogProfile")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLogProfilePaginator(essdk.BuildFilter(d.KeyColumnQuals, listLogProfileFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLogProfileFilters = map[string]string{
	"akas":                "description.LogProfileResource.ID",
	"categories":          "description.LogProfileResource.LogProfileProperties.Categories",
	"id":                  "description.LogProfileResource.ID",
	"kaytu_account_id":    "metadata.SourceID",
	"location":            "description.LogProfileResource.Location",
	"log_event_location":  "description.LogProfileResource.LogProfileProperties.Locations",
	"name":                "description.LogProfileResource.name",
	"region":              "description.LogProfileResource.Location",
	"resource_group":      "description.ResourceGroup",
	"retention_policy":    "description.LogProfileResource.LogProfileProperties.RetentionPolicy",
	"service_bus_rule_id": "description.LogProfileResource.LogProfileProperties.ServiceBusRuleID",
	"storage_account_id":  "description.LogProfileResource.LogProfileProperties.StorageAccountID",
	"tags":                "description.LogProfileResource.Tags",
	"title":               "description.LogProfileResource.Name",
	"type":                "description.LogProfileResource.Type",
}

func GetLogProfile(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLogProfile")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLogProfilePaginator(essdk.BuildFilter(d.KeyColumnQuals, getLogProfileFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LogProfile =============================

// ==========================  START: LogicAppWorkflow =============================

type LogicAppWorkflow struct {
	Description   azure.LogicAppWorkflowDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type LogicAppWorkflowHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  LogicAppWorkflow `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type LogicAppWorkflowHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []LogicAppWorkflowHit `json:"hits"`
}

type LogicAppWorkflowSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  LogicAppWorkflowHits `json:"hits"`
}

type LogicAppWorkflowPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLogicAppWorkflowPaginator(filters []essdk.BoolFilter, limit *int64) (LogicAppWorkflowPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_logic_workflows", filters, limit)
	if err != nil {
		return LogicAppWorkflowPaginator{}, err
	}

	p := LogicAppWorkflowPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LogicAppWorkflowPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LogicAppWorkflowPaginator) NextPage(ctx context.Context) ([]LogicAppWorkflow, error) {
	var response LogicAppWorkflowSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LogicAppWorkflow
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLogicAppWorkflowFilters = map[string]string{
	"access_control":                  "description.Workflow.WorkflowProperties.AccessControl",
	"access_endpoint":                 "description.Workflow.WorkflowProperties.AccessEndpoint",
	"akas":                            "description.Workflow.ID",
	"changed_time":                    "description.Workflow.WorkflowProperties.ChangedTime",
	"created_time":                    "description.Workflow.WorkflowProperties.CreatedTime",
	"definition":                      "description.Workflow.WorkflowProperties.Definition",
	"diagnostic_settings":             "description.DiagnosticSettingsResources",
	"endpoints_configuration":         "description.Workflow.WorkflowProperties.EndpointsConfiguration",
	"id":                              "description.Workflow.ID",
	"integration_account":             "description.Workflow.WorkflowProperties.IntegrationAccount",
	"integration_service_environment": "description.Workflow.WorkflowProperties.IntegrationServiceEnvironment",
	"kaytu_account_id":                "metadata.SourceID",
	"name":                            "description.Workflow.Name",
	"parameters":                      "description.Workflow.WorkflowProperties.Parameters",
	"provisioning_state":              "description.Workflow.WorkflowProperties.ProvisioningState",
	"region":                          "description.Workflow.Location",
	"resource_group":                  "description.ResourceGroup",
	"sku_name":                        "description.Workflow.WorkflowProperties.Sku.Name",
	"sku_plan":                        "description.Workflow.WorkflowProperties.Sku.Plan",
	"state":                           "description.Workflow.WorkflowProperties.State",
	"tags":                            "description.Workflow.Tags",
	"title":                           "description.Workflow.Name",
	"type":                            "description.Workflow.Type",
	"version":                         "description.Workflow.WorkflowProperties.Version",
}

func ListLogicAppWorkflow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLogicAppWorkflow")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLogicAppWorkflowPaginator(essdk.BuildFilter(d.KeyColumnQuals, listLogicAppWorkflowFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLogicAppWorkflowFilters = map[string]string{
	"access_control":                  "description.Workflow.WorkflowProperties.AccessControl",
	"access_endpoint":                 "description.Workflow.WorkflowProperties.AccessEndpoint",
	"akas":                            "description.Workflow.ID",
	"changed_time":                    "description.Workflow.WorkflowProperties.ChangedTime",
	"created_time":                    "description.Workflow.WorkflowProperties.CreatedTime",
	"definition":                      "description.Workflow.WorkflowProperties.Definition",
	"diagnostic_settings":             "description.DiagnosticSettingsResources",
	"endpoints_configuration":         "description.Workflow.WorkflowProperties.EndpointsConfiguration",
	"id":                              "description.Workflow.ID",
	"integration_account":             "description.Workflow.WorkflowProperties.IntegrationAccount",
	"integration_service_environment": "description.Workflow.WorkflowProperties.IntegrationServiceEnvironment",
	"kaytu_account_id":                "metadata.SourceID",
	"name":                            "description.Workflow.name",
	"parameters":                      "description.Workflow.WorkflowProperties.Parameters",
	"provisioning_state":              "description.Workflow.WorkflowProperties.ProvisioningState",
	"region":                          "description.Workflow.Location",
	"resource_group":                  "description.ResourceGroup",
	"sku_name":                        "description.Workflow.WorkflowProperties.Sku.Name",
	"sku_plan":                        "description.Workflow.WorkflowProperties.Sku.Plan",
	"state":                           "description.Workflow.WorkflowProperties.State",
	"tags":                            "description.Workflow.Tags",
	"title":                           "description.Workflow.Name",
	"type":                            "description.Workflow.Type",
	"version":                         "description.Workflow.WorkflowProperties.Version",
}

func GetLogicAppWorkflow(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLogicAppWorkflow")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLogicAppWorkflowPaginator(essdk.BuildFilter(d.KeyColumnQuals, getLogicAppWorkflowFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LogicAppWorkflow =============================

// ==========================  START: LogicIntegrationAccounts =============================

type LogicIntegrationAccounts struct {
	Description   azure.LogicIntegrationAccountsDescription `json:"description"`
	Metadata      azure.Metadata                            `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type LogicIntegrationAccountsHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  LogicIntegrationAccounts `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type LogicIntegrationAccountsHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []LogicIntegrationAccountsHit `json:"hits"`
}

type LogicIntegrationAccountsSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  LogicIntegrationAccountsHits `json:"hits"`
}

type LogicIntegrationAccountsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLogicIntegrationAccountsPaginator(filters []essdk.BoolFilter, limit *int64) (LogicIntegrationAccountsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_logic_integrationaccounts", filters, limit)
	if err != nil {
		return LogicIntegrationAccountsPaginator{}, err
	}

	p := LogicIntegrationAccountsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LogicIntegrationAccountsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LogicIntegrationAccountsPaginator) NextPage(ctx context.Context) ([]LogicIntegrationAccounts, error) {
	var response LogicIntegrationAccountsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LogicIntegrationAccounts
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLogicIntegrationAccountsFilters = map[string]string{
	"akas":             "description.IntegrationAccounts.ID",
	"id":               "description.IntegrationAccounts.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.IntegrationAccounts.Name",
	"tags":             "description.IntegrationAccounts.Tags",
	"title":            "description.IntegrationAccounts.Name",
}

func ListLogicIntegrationAccounts(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLogicIntegrationAccounts")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLogicIntegrationAccountsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listLogicIntegrationAccountsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLogicIntegrationAccountsFilters = map[string]string{
	"akas":             "description.IntegrationAccounts.ID",
	"id":               "description.IntegrationAccounts.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.IntegrationAccounts.Name",
	"tags":             "description.IntegrationAccounts.Tags",
	"title":            "description.IntegrationAccounts.Name",
}

func GetLogicIntegrationAccounts(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLogicIntegrationAccounts")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLogicIntegrationAccountsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getLogicIntegrationAccountsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LogicIntegrationAccounts =============================

// ==========================  START: MachineLearningWorkspace =============================

type MachineLearningWorkspace struct {
	Description   azure.MachineLearningWorkspaceDescription `json:"description"`
	Metadata      azure.Metadata                            `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type MachineLearningWorkspaceHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  MachineLearningWorkspace `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type MachineLearningWorkspaceHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []MachineLearningWorkspaceHit `json:"hits"`
}

type MachineLearningWorkspaceSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  MachineLearningWorkspaceHits `json:"hits"`
}

type MachineLearningWorkspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMachineLearningWorkspacePaginator(filters []essdk.BoolFilter, limit *int64) (MachineLearningWorkspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_machinelearningservices_workspaces", filters, limit)
	if err != nil {
		return MachineLearningWorkspacePaginator{}, err
	}

	p := MachineLearningWorkspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MachineLearningWorkspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MachineLearningWorkspacePaginator) NextPage(ctx context.Context) ([]MachineLearningWorkspace, error) {
	var response MachineLearningWorkspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MachineLearningWorkspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMachineLearningWorkspaceFilters = map[string]string{
	"akas":                               "description.Workspace.ID",
	"application_insights":               "description.Workspace.WorkspaceProperties.ApplicationInsights",
	"container_registry":                 "description.Workspace.WorkspaceProperties.ContainerRegistry",
	"creation_time":                      "description.Workspace.WorkspaceProperties.CreationTime",
	"description":                        "description.Workspace.WorkspaceProperties.Description",
	"diagnostic_settings":                "description.DiagnosticSettingsResources",
	"discovery_url":                      "description.Workspace.WorkspaceProperties.DiscoveryURL",
	"encryption":                         "description.Workspace.WorkspaceProperties.Encryption",
	"friendly_name":                      "description.Workspace.WorkspaceProperties.FriendlyName",
	"hbi_workspace":                      "description.Workspace.WorkspaceProperties.HbiWorkspace",
	"id":                                 "description.Workspace.ID",
	"identity":                           "description.Workspace.Identity",
	"kaytu_account_id":                   "metadata.SourceID",
	"key_vault":                          "description.Workspace.WorkspaceProperties.KeyVault",
	"location":                           "description.Workspace.Location",
	"name":                               "description.Workspace.Name",
	"provisioning_state":                 "description.Workspace.WorkspaceProperties.ProvisioningState",
	"region":                             "description.Workspace.Location",
	"resource_group":                     "description.ResourceGroup",
	"service_provisioned_resource_group": "description.Workspace.WorkspaceProperties.ServiceProvisionedResourceGroup",
	"sku_name":                           "description.Workspace.Sku.Name",
	"sku_tier":                           "description.Workspace.Sku.Tier",
	"storage_account":                    "description.Workspace.WorkspaceProperties.StorageAccount",
	"tags":                               "description.Workspace.Tags",
	"title":                              "description.Workspace.Name",
	"type":                               "description.Workspace.Type",
	"workspace_id":                       "description.Workspace.WorkspaceProperties.WorkspaceID",
}

func ListMachineLearningWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMachineLearningWorkspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewMachineLearningWorkspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, listMachineLearningWorkspaceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMachineLearningWorkspaceFilters = map[string]string{
	"akas":                               "description.Workspace.ID",
	"application_insights":               "description.Workspace.WorkspaceProperties.ApplicationInsights",
	"container_registry":                 "description.Workspace.WorkspaceProperties.ContainerRegistry",
	"creation_time":                      "description.Workspace.WorkspaceProperties.CreationTime",
	"description":                        "description.Workspace.WorkspaceProperties.Description",
	"diagnostic_settings":                "description.DiagnosticSettingsResources",
	"discovery_url":                      "description.Workspace.WorkspaceProperties.DiscoveryURL",
	"encryption":                         "description.Workspace.WorkspaceProperties.Encryption",
	"friendly_name":                      "description.Workspace.WorkspaceProperties.FriendlyName",
	"hbi_workspace":                      "description.Workspace.WorkspaceProperties.HbiWorkspace",
	"id":                                 "description.Workspace.ID",
	"identity":                           "description.Workspace.Identity",
	"kaytu_account_id":                   "metadata.SourceID",
	"key_vault":                          "description.Workspace.WorkspaceProperties.KeyVault",
	"location":                           "description.Workspace.Location",
	"name":                               "description.Workspace.name",
	"provisioning_state":                 "description.Workspace.WorkspaceProperties.ProvisioningState",
	"region":                             "description.Workspace.Location",
	"resource_group":                     "description.ResourceGroup",
	"service_provisioned_resource_group": "description.Workspace.WorkspaceProperties.ServiceProvisionedResourceGroup",
	"sku_name":                           "description.Workspace.Sku.Name",
	"sku_tier":                           "description.Workspace.Sku.Tier",
	"storage_account":                    "description.Workspace.WorkspaceProperties.StorageAccount",
	"tags":                               "description.Workspace.Tags",
	"title":                              "description.Workspace.Name",
	"type":                               "description.Workspace.Type",
	"workspace_id":                       "description.Workspace.WorkspaceProperties.WorkspaceID",
}

func GetMachineLearningWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMachineLearningWorkspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewMachineLearningWorkspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, getMachineLearningWorkspaceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MachineLearningWorkspace =============================

// ==========================  START: MariadbServer =============================

type MariadbServer struct {
	Description   azure.MariadbServerDescription `json:"description"`
	Metadata      azure.Metadata                 `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type MariadbServerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  MariadbServer `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type MariadbServerHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []MariadbServerHit `json:"hits"`
}

type MariadbServerSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  MariadbServerHits `json:"hits"`
}

type MariadbServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMariadbServerPaginator(filters []essdk.BoolFilter, limit *int64) (MariadbServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dbformariadb_servers", filters, limit)
	if err != nil {
		return MariadbServerPaginator{}, err
	}

	p := MariadbServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MariadbServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MariadbServerPaginator) NextPage(ctx context.Context) ([]MariadbServer, error) {
	var response MariadbServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MariadbServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMariadbServerFilters = map[string]string{
	"administrator_login":          "description.Server.ServerProperties.AdministratorLogin",
	"akas":                         "description.Server.ID",
	"auto_grow_enabled":            "description.Server.ServerProperties.StorageProfile.StorageAutogrow",
	"backup_retention_days":        "description.Server.ServerProperties.StorageProfile.BackupRetentionDays",
	"earliest_restore_date":        "description.Server.ServerProperties.EarliestRestoreDate",
	"fully_qualified_domain_name":  "description.Server.ServerProperties.FullyQualifiedDomainName",
	"geo_redundant_backup_enabled": "description.Server.ServerProperties.StorageProfile.GeoRedundantBackup",
	"id":                           "description.Server.ID",
	"kaytu_account_id":             "metadata.SourceID",
	"master_service_id":            "description.Server.ServerProperties.MasterServerID",
	"name":                         "description.Server.Name",
	"private_endpoint_connections": "description.Server.ServerProperties.PrivateEndpointConnections",
	"public_network_access":        "description.Server.ServerProperties.PublicNetworkAccess",
	"region":                       "description.Server.Location",
	"replica_capacity":             "description.Server.ServerProperties.ReplicaCapacity",
	"replication_role":             "description.Server.ServerProperties.ReplicationRole",
	"resource_group":               "description.ResourceGroup",
	"sku_capacity":                 "description.Server.Sku.Capacity",
	"sku_family":                   "description.Server.Sku.Family",
	"sku_name":                     "description.Server.Sku.Name",
	"sku_size":                     "description.Server.Sku.Size",
	"sku_tier":                     "description.Server.Sku.Tier",
	"ssl_enforcement":              "description.Server.ServerProperties.SslEnforcement",
	"storage_mb":                   "description.Server.ServerProperties.StorageProfile.StorageMB",
	"tags":                         "description.Server.Tags",
	"title":                        "description.Server.Name",
	"type":                         "description.Server.Type",
	"user_visible_state":           "description.Server.ServerProperties.UserVisibleState",
	"version":                      "description.Server.ServerProperties.Version",
}

func ListMariadbServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMariadbServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewMariadbServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listMariadbServerFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMariadbServerFilters = map[string]string{
	"administrator_login":          "description.Server.ServerProperties.AdministratorLogin",
	"akas":                         "description.Server.ID",
	"auto_grow_enabled":            "description.Server.ServerProperties.StorageProfile.StorageAutogrow",
	"backup_retention_days":        "description.Server.ServerProperties.StorageProfile.BackupRetentionDays",
	"earliest_restore_date":        "description.Server.ServerProperties.EarliestRestoreDate",
	"fully_qualified_domain_name":  "description.Server.ServerProperties.FullyQualifiedDomainName",
	"geo_redundant_backup_enabled": "description.Server.ServerProperties.StorageProfile.GeoRedundantBackup",
	"id":                           "description.Server.ID",
	"kaytu_account_id":             "metadata.SourceID",
	"master_service_id":            "description.Server.ServerProperties.MasterServerID",
	"name":                         "description.Server.name",
	"private_endpoint_connections": "description.Server.ServerProperties.PrivateEndpointConnections",
	"public_network_access":        "description.Server.ServerProperties.PublicNetworkAccess",
	"region":                       "description.Server.Location",
	"replica_capacity":             "description.Server.ServerProperties.ReplicaCapacity",
	"replication_role":             "description.Server.ServerProperties.ReplicationRole",
	"resource_group":               "description.ResourceGroup",
	"sku_capacity":                 "description.Server.Sku.Capacity",
	"sku_family":                   "description.Server.Sku.Family",
	"sku_name":                     "description.Server.Sku.Name",
	"sku_size":                     "description.Server.Sku.Size",
	"sku_tier":                     "description.Server.Sku.Tier",
	"ssl_enforcement":              "description.Server.ServerProperties.SslEnforcement",
	"storage_mb":                   "description.Server.ServerProperties.StorageProfile.StorageMB",
	"tags":                         "description.Server.Tags",
	"title":                        "description.Server.Name",
	"type":                         "description.Server.Type",
	"user_visible_state":           "description.Server.ServerProperties.UserVisibleState",
	"version":                      "description.Server.ServerProperties.Version",
}

func GetMariadbServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMariadbServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewMariadbServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getMariadbServerFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MariadbServer =============================

// ==========================  START: MariadbDatabase =============================

type MariadbDatabase struct {
	Description   azure.MariadbDatabaseDescription `json:"description"`
	Metadata      azure.Metadata                   `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type MariadbDatabaseHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  MariadbDatabase `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type MariadbDatabaseHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []MariadbDatabaseHit `json:"hits"`
}

type MariadbDatabaseSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  MariadbDatabaseHits `json:"hits"`
}

type MariadbDatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMariadbDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (MariadbDatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dbformariadb_servers_databases", filters, limit)
	if err != nil {
		return MariadbDatabasePaginator{}, err
	}

	p := MariadbDatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MariadbDatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MariadbDatabasePaginator) NextPage(ctx context.Context) ([]MariadbDatabase, error) {
	var response MariadbDatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MariadbDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMariadbDatabaseFilters = map[string]string{
	"akas":             "description.Databases.ID",
	"id":               "description.Databases.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Databases.Name",
	"tags":             "description.Databases.Tags",
	"title":            "description.Databases.Name",
}

func ListMariadbDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMariadbDatabase")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewMariadbDatabasePaginator(essdk.BuildFilter(d.KeyColumnQuals, listMariadbDatabaseFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMariadbDatabaseFilters = map[string]string{
	"akas":             "description.Databases.ID",
	"id":               "description.Databases.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Databases.Name",
	"tags":             "description.Databases.Tags",
	"title":            "description.Databases.Name",
}

func GetMariadbDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMariadbDatabase")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewMariadbDatabasePaginator(essdk.BuildFilter(d.KeyColumnQuals, getMariadbDatabaseFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MariadbDatabase =============================

// ==========================  START: MysqlServer =============================

type MysqlServer struct {
	Description   azure.MysqlServerDescription `json:"description"`
	Metadata      azure.Metadata               `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type MysqlServerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  MysqlServer   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type MysqlServerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []MysqlServerHit  `json:"hits"`
}

type MysqlServerSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  MysqlServerHits `json:"hits"`
}

type MysqlServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMysqlServerPaginator(filters []essdk.BoolFilter, limit *int64) (MysqlServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dbformysql_servers", filters, limit)
	if err != nil {
		return MysqlServerPaginator{}, err
	}

	p := MysqlServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MysqlServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MysqlServerPaginator) NextPage(ctx context.Context) ([]MysqlServer, error) {
	var response MysqlServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MysqlServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMysqlServerFilters = map[string]string{
	"administrator_login":         "description.Server.ServerProperties.AdministratorLogin",
	"akas":                        "description.Server.ID",
	"backup_retention_days":       "description.Server.ServerProperties.StorageProfile.BackupRetentionDays",
	"byok_enforcement":            "description.Server.ServerProperties.ByokEnforcement",
	"earliest_restore_date":       "description.Server.ServerProperties.EarliestRestoreDate",
	"fully_qualified_domain_name": "description.Server.ServerProperties.FullyQualifiedDomainName",
	"geo_redundant_backup":        "description.Server.ServerProperties.StorageProfile.GeoRedundantBackup",
	"id":                          "description.Server.ID",
	"infrastructure_encryption":   "description.Server.ServerProperties.InfrastructureEncryption",
	"kaytu_account_id":            "metadata.SourceID",
	"location":                    "description.Server.Location",
	"master_server_id":            "description.Server.ServerProperties.MasterServerID",
	"minimal_tls_version":         "description.Server.ServerProperties.MinimalTLSVersion",
	"name":                        "description.Server.Name",
	"public_network_access":       "description.Server.ServerProperties.PublicNetworkAccess",
	"region":                      "description.Server.Location",
	"replica_capacity":            "description.Server.ServerProperties.ReplicaCapacity",
	"replication_role":            "description.Server.ServerProperties.ReplicationRole",
	"resource_group":              "description.ResourceGroup",
	"server_configurations":       "description.Configurations",
	"server_keys":                 "description.ServerKeys",
	"sku_capacity":                "description.Server.Sku.Capacity",
	"sku_family":                  "description.Server.Sku.Family",
	"sku_name":                    "description.Server.Sku.Name",
	"sku_size":                    "description.Server.Sku.Size",
	"sku_tier":                    "description.Server.Sku.Tier",
	"ssl_enforcement":             "description.Server.ServerProperties.SslEnforcement",
	"state":                       "description.Server.ServerProperties.UserVisibleState",
	"storage_auto_grow":           "description.Server.ServerProperties.StorageProfile.StorageAutogrow",
	"storage_mb":                  "description.Server.ServerProperties.StorageProfile.StorageMB",
	"tags":                        "description.Server.Tags",
	"title":                       "description.Server.Name",
	"type":                        "description.Server.Type",
	"user_visible_state":          "description.Server.ServerProperties.UserVisibleState",
	"version":                     "description.Server.ServerProperties.Version",
}

func ListMysqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMysqlServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewMysqlServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listMysqlServerFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMysqlServerFilters = map[string]string{
	"administrator_login":         "description.Server.ServerProperties.AdministratorLogin",
	"akas":                        "description.Server.ID",
	"backup_retention_days":       "description.Server.ServerProperties.StorageProfile.BackupRetentionDays",
	"byok_enforcement":            "description.Server.ServerProperties.ByokEnforcement",
	"earliest_restore_date":       "description.Server.ServerProperties.EarliestRestoreDate",
	"fully_qualified_domain_name": "description.Server.ServerProperties.FullyQualifiedDomainName",
	"geo_redundant_backup":        "description.Server.ServerProperties.StorageProfile.GeoRedundantBackup",
	"id":                          "description.Server.ID",
	"infrastructure_encryption":   "description.Server.ServerProperties.InfrastructureEncryption",
	"kaytu_account_id":            "metadata.SourceID",
	"location":                    "description.Server.Location",
	"master_server_id":            "description.Server.ServerProperties.MasterServerID",
	"minimal_tls_version":         "description.Server.ServerProperties.MinimalTLSVersion",
	"name":                        "description.Server.name",
	"public_network_access":       "description.Server.ServerProperties.PublicNetworkAccess",
	"region":                      "description.Server.Location",
	"replica_capacity":            "description.Server.ServerProperties.ReplicaCapacity",
	"replication_role":            "description.Server.ServerProperties.ReplicationRole",
	"resource_group":              "description.ResourceGroup",
	"server_configurations":       "description.Configurations",
	"server_keys":                 "description.ServerKeys",
	"sku_capacity":                "description.Server.Sku.Capacity",
	"sku_family":                  "description.Server.Sku.Family",
	"sku_name":                    "description.Server.Sku.Name",
	"sku_size":                    "description.Server.Sku.Size",
	"sku_tier":                    "description.Server.Sku.Tier",
	"ssl_enforcement":             "description.Server.ServerProperties.SslEnforcement",
	"state":                       "description.Server.ServerProperties.UserVisibleState",
	"storage_auto_grow":           "description.Server.ServerProperties.StorageProfile.StorageAutogrow",
	"storage_mb":                  "description.Server.ServerProperties.StorageProfile.StorageMB",
	"tags":                        "description.Server.Tags",
	"title":                       "description.Server.Name",
	"type":                        "description.Server.Type",
	"user_visible_state":          "description.Server.ServerProperties.UserVisibleState",
	"version":                     "description.Server.ServerProperties.Version",
}

func GetMysqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMysqlServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewMysqlServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getMysqlServerFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MysqlServer =============================

// ==========================  START: MysqlFlexibleserver =============================

type MysqlFlexibleserver struct {
	Description   azure.MysqlFlexibleserverDescription `json:"description"`
	Metadata      azure.Metadata                       `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type MysqlFlexibleserverHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  MysqlFlexibleserver `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type MysqlFlexibleserverHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []MysqlFlexibleserverHit `json:"hits"`
}

type MysqlFlexibleserverSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  MysqlFlexibleserverHits `json:"hits"`
}

type MysqlFlexibleserverPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMysqlFlexibleserverPaginator(filters []essdk.BoolFilter, limit *int64) (MysqlFlexibleserverPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dbformysql_flexibleservers", filters, limit)
	if err != nil {
		return MysqlFlexibleserverPaginator{}, err
	}

	p := MysqlFlexibleserverPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MysqlFlexibleserverPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MysqlFlexibleserverPaginator) NextPage(ctx context.Context) ([]MysqlFlexibleserver, error) {
	var response MysqlFlexibleserverSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MysqlFlexibleserver
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMysqlFlexibleserverFilters = map[string]string{
	"akas":             "description.FlexibleServers.ID",
	"id":               "description.FlexibleServers.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.FlexibleServers.Name",
	"tags":             "description.FlexibleServers.Tags",
	"title":            "description.FlexibleServers.Name",
}

func ListMysqlFlexibleserver(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMysqlFlexibleserver")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewMysqlFlexibleserverPaginator(essdk.BuildFilter(d.KeyColumnQuals, listMysqlFlexibleserverFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMysqlFlexibleserverFilters = map[string]string{
	"akas":             "description.FlexibleServers.ID",
	"id":               "description.FlexibleServers.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.FlexibleServers.Name",
	"tags":             "description.FlexibleServers.Tags",
	"title":            "description.FlexibleServers.Name",
}

func GetMysqlFlexibleserver(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMysqlFlexibleserver")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewMysqlFlexibleserverPaginator(essdk.BuildFilter(d.KeyColumnQuals, getMysqlFlexibleserverFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MysqlFlexibleserver =============================

// ==========================  START: NetworkSecurityGroup =============================

type NetworkSecurityGroup struct {
	Description   azure.NetworkSecurityGroupDescription `json:"description"`
	Metadata      azure.Metadata                        `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type NetworkSecurityGroupHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  NetworkSecurityGroup `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type NetworkSecurityGroupHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []NetworkSecurityGroupHit `json:"hits"`
}

type NetworkSecurityGroupSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  NetworkSecurityGroupHits `json:"hits"`
}

type NetworkSecurityGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkSecurityGroupPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkSecurityGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_networksecuritygroups", filters, limit)
	if err != nil {
		return NetworkSecurityGroupPaginator{}, err
	}

	p := NetworkSecurityGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkSecurityGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkSecurityGroupPaginator) NextPage(ctx context.Context) ([]NetworkSecurityGroup, error) {
	var response NetworkSecurityGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkSecurityGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkSecurityGroupFilters = map[string]string{
	"akas":                   "description.SecurityGroup.ID",
	"default_security_rules": "description.SecurityGroup.SecurityGroupPropertiesFormat.DefaultSecurityRules",
	"diagnostic_settings":    "description.DiagnosticSettingsResources",
	"etag":                   "description.SecurityGroup.Etag",
	"flow_logs":              "description.SecurityGroup.SecurityGroupPropertiesFormat.FlowLogs",
	"id":                     "description.SecurityGroup.ID",
	"kaytu_account_id":       "metadata.SourceID",
	"name":                   "description.SecurityGroup.Name",
	"network_interfaces":     "description.SecurityGroup.SecurityGroupPropertiesFormat.NetworkInterfaces",
	"provisioning_state":     "description.SecurityGroup.SecurityGroupPropertiesFormat.ProvisioningState",
	"region":                 "description.SecurityGroup.Location",
	"resource_group":         "description.ResourceGroup",
	"resource_guid":          "description.SecurityGroup.SecurityGroupPropertiesFormat.ResourceGUID",
	"security_rules":         "description.SecurityGroup.SecurityGroupPropertiesFormat.SecurityRules",
	"subnets":                "description.SecurityGroup.SecurityGroupPropertiesFormat.Subnets",
	"tags":                   "description.SecurityGroup.Tags",
	"title":                  "description.SecurityGroup.Name",
	"type":                   "description.SecurityGroup.Type",
}

func ListNetworkSecurityGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkSecurityGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewNetworkSecurityGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listNetworkSecurityGroupFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNetworkSecurityGroupFilters = map[string]string{
	"akas":                   "description.SecurityGroup.ID",
	"default_security_rules": "description.SecurityGroup.SecurityGroupPropertiesFormat.DefaultSecurityRules",
	"diagnostic_settings":    "description.DiagnosticSettingsResources",
	"etag":                   "description.SecurityGroup.Etag",
	"flow_logs":              "description.SecurityGroup.SecurityGroupPropertiesFormat.FlowLogs",
	"id":                     "description.SecurityGroup.ID",
	"kaytu_account_id":       "metadata.SourceID",
	"name":                   "description.SecurityGroup.name",
	"network_interfaces":     "description.SecurityGroup.SecurityGroupPropertiesFormat.NetworkInterfaces",
	"provisioning_state":     "description.SecurityGroup.SecurityGroupPropertiesFormat.ProvisioningState",
	"region":                 "description.SecurityGroup.Location",
	"resource_group":         "description.ResourceGroup",
	"resource_guid":          "description.SecurityGroup.SecurityGroupPropertiesFormat.ResourceGUID",
	"security_rules":         "description.SecurityGroup.SecurityGroupPropertiesFormat.SecurityRules",
	"subnets":                "description.SecurityGroup.SecurityGroupPropertiesFormat.Subnets",
	"tags":                   "description.SecurityGroup.Tags",
	"title":                  "description.SecurityGroup.Name",
	"type":                   "description.SecurityGroup.Type",
}

func GetNetworkSecurityGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkSecurityGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewNetworkSecurityGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getNetworkSecurityGroupFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NetworkSecurityGroup =============================

// ==========================  START: NetworkWatcher =============================

type NetworkWatcher struct {
	Description   azure.NetworkWatcherDescription `json:"description"`
	Metadata      azure.Metadata                  `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type NetworkWatcherHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  NetworkWatcher `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type NetworkWatcherHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []NetworkWatcherHit `json:"hits"`
}

type NetworkWatcherSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  NetworkWatcherHits `json:"hits"`
}

type NetworkWatcherPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewNetworkWatcherPaginator(filters []essdk.BoolFilter, limit *int64) (NetworkWatcherPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_networkwatchers", filters, limit)
	if err != nil {
		return NetworkWatcherPaginator{}, err
	}

	p := NetworkWatcherPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p NetworkWatcherPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p NetworkWatcherPaginator) NextPage(ctx context.Context) ([]NetworkWatcher, error) {
	var response NetworkWatcherSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []NetworkWatcher
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listNetworkWatcherFilters = map[string]string{
	"akas":               "description.Watcher.ID",
	"etag":               "description.Watcher.Etag",
	"id":                 "description.Watcher.ID",
	"kaytu_account_id":   "metadata.SourceID",
	"name":               "description.Watcher.Name",
	"provisioning_state": "description.Watcher.WatcherPropertiesFormat.ProvisioningState",
	"region":             "description.Watcher.Location",
	"resource_group":     "description.ResourceGroup",
	"tags":               "description.Watcher.Tags",
	"title":              "description.Watcher.Name",
	"type":               "description.Watcher.Type",
}

func ListNetworkWatcher(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListNetworkWatcher")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewNetworkWatcherPaginator(essdk.BuildFilter(d.KeyColumnQuals, listNetworkWatcherFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getNetworkWatcherFilters = map[string]string{
	"akas":               "description.Watcher.ID",
	"etag":               "description.Watcher.Etag",
	"id":                 "description.Watcher.ID",
	"kaytu_account_id":   "metadata.SourceID",
	"name":               "description.Watcher.name",
	"provisioning_state": "description.Watcher.WatcherPropertiesFormat.ProvisioningState",
	"region":             "description.Watcher.Location",
	"resource_group":     "description.ResourceGroup",
	"tags":               "description.Watcher.Tags",
	"title":              "description.Watcher.Name",
	"type":               "description.Watcher.Type",
}

func GetNetworkWatcher(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetNetworkWatcher")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewNetworkWatcherPaginator(essdk.BuildFilter(d.KeyColumnQuals, getNetworkWatcherFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: NetworkWatcher =============================

// ==========================  START: SearchService =============================

type SearchService struct {
	Description   azure.SearchServiceDescription `json:"description"`
	Metadata      azure.Metadata                 `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type SearchServiceHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SearchService `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SearchServiceHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []SearchServiceHit `json:"hits"`
}

type SearchServiceSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  SearchServiceHits `json:"hits"`
}

type SearchServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSearchServicePaginator(filters []essdk.BoolFilter, limit *int64) (SearchServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_search_searchservices", filters, limit)
	if err != nil {
		return SearchServicePaginator{}, err
	}

	p := SearchServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SearchServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SearchServicePaginator) NextPage(ctx context.Context) ([]SearchService, error) {
	var response SearchServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SearchService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSearchServiceFilters = map[string]string{
	"akas":                          "description.Service.ID",
	"diagnostic_settings":           "description.DiagnosticSettingsResources",
	"hosting_mode":                  "description.Service.ServiceProperties.HostingMode",
	"id":                            "description.Service.ID",
	"identity":                      "description.Service.Identity",
	"kaytu_account_id":              "metadata.SourceID",
	"name":                          "description.Service.Name",
	"network_rule_set":              "description.Service.ServiceProperties.NetworkRuleSet",
	"partition_count":               "description.Service.ServiceProperties.PartitionCount",
	"private_endpoint_connections":  "description.Service.ServiceProperties.PrivateEndpointConnections",
	"provisioning_state":            "description.Service.ServiceProperties.ProvisioningState",
	"public_network_access":         "description.Service.ServiceProperties.PublicNetworkAccess",
	"region":                        "description.Service.Location",
	"replica_count":                 "description.Service.ServiceProperties.ReplicaCount",
	"resource_group":                "description.ResourceGroup",
	"shared_private_link_resources": "description.Service.ServiceProperties.SharedPrivateLinkResources",
	"sku_name":                      "description.Service.Sku.Name",
	"status":                        "description.Service.ServiceProperties.Status",
	"status_details":                "description.Service.ServiceProperties.StatusDetails",
	"tags":                          "description.Service.Tags",
	"title":                         "description.Service.Name",
	"type":                          "description.Service.Type",
}

func ListSearchService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSearchService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSearchServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, listSearchServiceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSearchServiceFilters = map[string]string{
	"akas":                          "description.Service.ID",
	"diagnostic_settings":           "description.DiagnosticSettingsResources",
	"hosting_mode":                  "description.Service.ServiceProperties.HostingMode",
	"id":                            "description.Service.ID",
	"identity":                      "description.Service.Identity",
	"kaytu_account_id":              "metadata.SourceID",
	"name":                          "description.Service.name",
	"network_rule_set":              "description.Service.ServiceProperties.NetworkRuleSet",
	"partition_count":               "description.Service.ServiceProperties.PartitionCount",
	"private_endpoint_connections":  "description.Service.ServiceProperties.PrivateEndpointConnections",
	"provisioning_state":            "description.Service.ServiceProperties.ProvisioningState",
	"public_network_access":         "description.Service.ServiceProperties.PublicNetworkAccess",
	"region":                        "description.Service.Location",
	"replica_count":                 "description.Service.ServiceProperties.ReplicaCount",
	"resource_group":                "description.ResourceGroup",
	"shared_private_link_resources": "description.Service.ServiceProperties.SharedPrivateLinkResources",
	"sku_name":                      "description.Service.Sku.Name",
	"status":                        "description.Service.ServiceProperties.Status",
	"status_details":                "description.Service.ServiceProperties.StatusDetails",
	"tags":                          "description.Service.Tags",
	"title":                         "description.Service.Name",
	"type":                          "description.Service.Type",
}

func GetSearchService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSearchService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSearchServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, getSearchServiceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SearchService =============================

// ==========================  START: ServiceFabricCluster =============================

type ServiceFabricCluster struct {
	Description   azure.ServiceFabricClusterDescription `json:"description"`
	Metadata      azure.Metadata                        `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type ServiceFabricClusterHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  ServiceFabricCluster `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type ServiceFabricClusterHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []ServiceFabricClusterHit `json:"hits"`
}

type ServiceFabricClusterSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  ServiceFabricClusterHits `json:"hits"`
}

type ServiceFabricClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServiceFabricClusterPaginator(filters []essdk.BoolFilter, limit *int64) (ServiceFabricClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_servicefabric_clusters", filters, limit)
	if err != nil {
		return ServiceFabricClusterPaginator{}, err
	}

	p := ServiceFabricClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServiceFabricClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServiceFabricClusterPaginator) NextPage(ctx context.Context) ([]ServiceFabricCluster, error) {
	var response ServiceFabricClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServiceFabricCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServiceFabricClusterFilters = map[string]string{
	"add_on_features":                        "description.Cluster.ClusterProperties.AddOnFeatures",
	"akas":                                   "description.Cluster.ID",
	"available_cluster_versions":             "description.Cluster.ClusterProperties.AvailableClusterVersions",
	"azure_active_directory":                 "description.Cluster.ClusterProperties.AzureActiveDirectory",
	"certificate":                            "description.Cluster.ClusterProperties.Certificate",
	"certificate_common_names":               "description.Cluster.ClusterProperties.CertificateCommonNames",
	"client_certificate_common_names":        "description.Cluster.ClusterProperties.ClientCertificateCommonNames",
	"client_certificate_thumbprints":         "description.Cluster.ClusterProperties.ClientCertificateThumbprints",
	"cluster_code_version":                   "description.Cluster.ClusterProperties.ClusterCodeVersion",
	"cluster_endpoint":                       "description.Cluster.ClusterProperties.ClusterEndpoint",
	"cluster_id":                             "description.Cluster.ClusterProperties.ClusterID",
	"cluster_state":                          "description.Cluster.ClusterProperties.ClusterState",
	"diagnostics_storage_account_config":     "description.Cluster.ClusterProperties.DiagnosticsStorageAccountConfig",
	"etag":                                   "description.Cluster.Etag",
	"event_store_service_enabled":            "description.Cluster.ClusterProperties.EventStoreServiceEnabled",
	"fabric_settings":                        "description.Cluster.ClusterProperties.FabricSettings",
	"id":                                     "description.Cluster.ID",
	"kaytu_account_id":                       "metadata.SourceID",
	"management_endpoint":                    "description.Cluster.ClusterProperties.ManagementEndpoint",
	"name":                                   "description.Cluster.Name",
	"node_types":                             "description.Cluster.ClusterProperties.NodeTypes",
	"provisioning_state":                     "description.Cluster.ClusterProperties.ProvisioningState",
	"region":                                 "description.Cluster.Location",
	"reliability_level":                      "description.Cluster.ClusterProperties.ReliabilityLevel",
	"resource_group":                         "description.ResourceGroup",
	"reverse_proxy_certificate":              "description.Cluster.ClusterProperties.ReverseProxyCertificate",
	"reverse_proxy_certificate_common_names": "description.Cluster.ClusterProperties.ReverseProxyCertificateCommonNames",
	"tags":                                   "description.Cluster.Tags",
	"title":                                  "description.Cluster.Name",
	"type":                                   "description.Cluster.Type",
	"upgrade_description":                    "description.Cluster.ClusterProperties.UpgradeDescription",
	"upgrade_mode":                           "description.Cluster.ClusterProperties.UpgradeMode",
	"vm_image":                               "description.Cluster.ClusterProperties.VMImage",
}

func ListServiceFabricCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServiceFabricCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewServiceFabricClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listServiceFabricClusterFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getServiceFabricClusterFilters = map[string]string{
	"add_on_features":                        "description.Cluster.ClusterProperties.AddOnFeatures",
	"akas":                                   "description.Cluster.ID",
	"available_cluster_versions":             "description.Cluster.ClusterProperties.AvailableClusterVersions",
	"azure_active_directory":                 "description.Cluster.ClusterProperties.AzureActiveDirectory",
	"certificate":                            "description.Cluster.ClusterProperties.Certificate",
	"certificate_common_names":               "description.Cluster.ClusterProperties.CertificateCommonNames",
	"client_certificate_common_names":        "description.Cluster.ClusterProperties.ClientCertificateCommonNames",
	"client_certificate_thumbprints":         "description.Cluster.ClusterProperties.ClientCertificateThumbprints",
	"cluster_code_version":                   "description.Cluster.ClusterProperties.ClusterCodeVersion",
	"cluster_endpoint":                       "description.Cluster.ClusterProperties.ClusterEndpoint",
	"cluster_id":                             "description.Cluster.ClusterProperties.ClusterID",
	"cluster_state":                          "description.Cluster.ClusterProperties.ClusterState",
	"diagnostics_storage_account_config":     "description.Cluster.ClusterProperties.DiagnosticsStorageAccountConfig",
	"etag":                                   "description.Cluster.Etag",
	"event_store_service_enabled":            "description.Cluster.ClusterProperties.EventStoreServiceEnabled",
	"fabric_settings":                        "description.Cluster.ClusterProperties.FabricSettings",
	"id":                                     "description.Cluster.ID",
	"kaytu_account_id":                       "metadata.SourceID",
	"management_endpoint":                    "description.Cluster.ClusterProperties.ManagementEndpoint",
	"name":                                   "description.Cluster.name",
	"node_types":                             "description.Cluster.ClusterProperties.NodeTypes",
	"provisioning_state":                     "description.Cluster.ClusterProperties.ProvisioningState",
	"region":                                 "description.Cluster.Location",
	"reliability_level":                      "description.Cluster.ClusterProperties.ReliabilityLevel",
	"resource_group":                         "description.ResourceGroup",
	"reverse_proxy_certificate":              "description.Cluster.ClusterProperties.ReverseProxyCertificate",
	"reverse_proxy_certificate_common_names": "description.Cluster.ClusterProperties.ReverseProxyCertificateCommonNames",
	"tags":                                   "description.Cluster.Tags",
	"title":                                  "description.Cluster.Name",
	"type":                                   "description.Cluster.Type",
	"upgrade_description":                    "description.Cluster.ClusterProperties.UpgradeDescription",
	"upgrade_mode":                           "description.Cluster.ClusterProperties.UpgradeMode",
	"vm_image":                               "description.Cluster.ClusterProperties.VMImage",
}

func GetServiceFabricCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServiceFabricCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewServiceFabricClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getServiceFabricClusterFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ServiceFabricCluster =============================

// ==========================  START: ServicebusNamespace =============================

type ServicebusNamespace struct {
	Description   azure.ServicebusNamespaceDescription `json:"description"`
	Metadata      azure.Metadata                       `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type ServicebusNamespaceHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  ServicebusNamespace `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type ServicebusNamespaceHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []ServicebusNamespaceHit `json:"hits"`
}

type ServicebusNamespaceSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  ServicebusNamespaceHits `json:"hits"`
}

type ServicebusNamespacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewServicebusNamespacePaginator(filters []essdk.BoolFilter, limit *int64) (ServicebusNamespacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_servicebus_namespaces", filters, limit)
	if err != nil {
		return ServicebusNamespacePaginator{}, err
	}

	p := ServicebusNamespacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ServicebusNamespacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ServicebusNamespacePaginator) NextPage(ctx context.Context) ([]ServicebusNamespace, error) {
	var response ServicebusNamespaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ServicebusNamespace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listServicebusNamespaceFilters = map[string]string{
	"akas":                         "description.SBNamespace.ID",
	"created_at":                   "description.SBNamespace.SBNamespaceProperties.CreatedAt",
	"diagnostic_settings":          "description.DiagnosticSettingsResources",
	"encryption":                   "description.SBNamespace.SBNamespaceProperties.Encryption",
	"id":                           "description.SBNamespace.ID",
	"kaytu_account_id":             "metadata.SourceID",
	"metric_id":                    "description.SBNamespace.SBNamespaceProperties.MetricID",
	"name":                         "description.SBNamespace.Name",
	"network_rule_set":             "description.NetworkRuleSet",
	"private_endpoint_connections": "description.PrivateEndpointConnections",
	"provisioning_state":           "description.SBNamespace.SBNamespaceProperties.ProvisioningState",
	"region":                       "description.SBNamespace.Location",
	"resource_group":               "description.ResourceGroup",
	"servicebus_endpoint":          "description.SBNamespace.SBNamespaceProperties.ServiceBusEndpoint",
	"sku_capacity":                 "description.SBNamespace.Sku.Capacity",
	"sku_name":                     "description.SBNamespace.Sku.Name",
	"sku_tier":                     "description.SBNamespace.Sku.Tier",
	"tags":                         "description.SBNamespace.Tags",
	"title":                        "description.SBNamespace",
	"type":                         "description.SBNamespace.Type",
	"updated_at":                   "description.SBNamespace.SBNamespaceProperties.UpdatedAt",
	"zone_redundant":               "description.SBNamespace.SBNamespaceProperties.ZoneRedundant",
}

func ListServicebusNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListServicebusNamespace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewServicebusNamespacePaginator(essdk.BuildFilter(d.KeyColumnQuals, listServicebusNamespaceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getServicebusNamespaceFilters = map[string]string{
	"akas":                         "description.SBNamespace.ID",
	"created_at":                   "description.SBNamespace.SBNamespaceProperties.CreatedAt",
	"diagnostic_settings":          "description.DiagnosticSettingsResources",
	"encryption":                   "description.SBNamespace.SBNamespaceProperties.Encryption",
	"id":                           "description.SBNamespace.ID",
	"kaytu_account_id":             "metadata.SourceID",
	"metric_id":                    "description.SBNamespace.SBNamespaceProperties.MetricID",
	"name":                         "description.SBNamespace.name",
	"network_rule_set":             "description.NetworkRuleSet",
	"private_endpoint_connections": "description.PrivateEndpointConnections",
	"provisioning_state":           "description.SBNamespace.SBNamespaceProperties.ProvisioningState",
	"region":                       "description.SBNamespace.Location",
	"resource_group":               "description.ResourceGroup",
	"servicebus_endpoint":          "description.SBNamespace.SBNamespaceProperties.ServiceBusEndpoint",
	"sku_capacity":                 "description.SBNamespace.Sku.Capacity",
	"sku_name":                     "description.SBNamespace.Sku.Name",
	"sku_tier":                     "description.SBNamespace.Sku.Tier",
	"tags":                         "description.SBNamespace.Tags",
	"title":                        "description.SBNamespace",
	"type":                         "description.SBNamespace.Type",
	"updated_at":                   "description.SBNamespace.SBNamespaceProperties.UpdatedAt",
	"zone_redundant":               "description.SBNamespace.SBNamespaceProperties.ZoneRedundant",
}

func GetServicebusNamespace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetServicebusNamespace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewServicebusNamespacePaginator(essdk.BuildFilter(d.KeyColumnQuals, getServicebusNamespaceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ServicebusNamespace =============================

// ==========================  START: SignalrService =============================

type SignalrService struct {
	Description   azure.SignalrServiceDescription `json:"description"`
	Metadata      azure.Metadata                  `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type SignalrServiceHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  SignalrService `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type SignalrServiceHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []SignalrServiceHit `json:"hits"`
}

type SignalrServiceSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  SignalrServiceHits `json:"hits"`
}

type SignalrServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSignalrServicePaginator(filters []essdk.BoolFilter, limit *int64) (SignalrServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_signalrservice_signalr", filters, limit)
	if err != nil {
		return SignalrServicePaginator{}, err
	}

	p := SignalrServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SignalrServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SignalrServicePaginator) NextPage(ctx context.Context) ([]SignalrService, error) {
	var response SignalrServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SignalrService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSignalrServiceFilters = map[string]string{
	"akas":                "description.ResourceType.ID",
	"cors":                "description.ResourceType.Properties.Cors",
	"diagnostic_settings": "description.DiagnosticSettingsResources",
	"external_ip":         "description.ResourceType.Properties.ExternalIP",
	"features":            "description.ResourceType.Properties.Features",
	"host_name":           "description.ResourceType.Properties.HostName",
	"host_name_prefix":    "description.ResourceType.Properties.HostNamePrefix",
	"id":                  "description.ResourceType.ID",
	"kaytu_account_id":    "metadata.SourceID",
	"kind":                "description.ResourceType.Kind",
	"name":                "description.ResourceType.Name",
	"network_acls":        "description.ResourceType.Properties.NetworkACLs",
	"provisioning_state":  "description.ResourceType.Properties.ProvisioningState",
	"public_port":         "description.ResourceType.Properties.PublicPort",
	"region":              "description.ResourceType.Location",
	"resource_group":      "description.ResourceGroup",
	"server_port":         "description.ResourceType.Properties.ServerPort",
	"sku":                 "description.ResourceType.Sku",
	"tags":                "description.ResourceType.Tags",
	"title":               "description.ResourceType.Name",
	"type":                "description.ResourceType",
	"upstream":            "description.ResourceType.Properties.Upstream",
	"version":             "description.ResourceType.Properties.Version",
}

func ListSignalrService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSignalrService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSignalrServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, listSignalrServiceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSignalrServiceFilters = map[string]string{
	"akas":                "description.ResourceType.ID",
	"cors":                "description.ResourceType.Properties.Cors",
	"diagnostic_settings": "description.DiagnosticSettingsResources",
	"external_ip":         "description.ResourceType.Properties.ExternalIP",
	"features":            "description.ResourceType.Properties.Features",
	"host_name":           "description.ResourceType.Properties.HostName",
	"host_name_prefix":    "description.ResourceType.Properties.HostNamePrefix",
	"id":                  "description.ResourceType.ID",
	"kaytu_account_id":    "metadata.SourceID",
	"kind":                "description.ResourceType.Kind",
	"name":                "description.ResourceType.name",
	"network_acls":        "description.ResourceType.Properties.NetworkACLs",
	"provisioning_state":  "description.ResourceType.Properties.ProvisioningState",
	"public_port":         "description.ResourceType.Properties.PublicPort",
	"region":              "description.ResourceType.Location",
	"resource_group":      "description.ResourceGroup",
	"server_port":         "description.ResourceType.Properties.ServerPort",
	"sku":                 "description.ResourceType.Sku",
	"tags":                "description.ResourceType.Tags",
	"title":               "description.ResourceType.Name",
	"type":                "description.ResourceType",
	"upstream":            "description.ResourceType.Properties.Upstream",
	"version":             "description.ResourceType.Properties.Version",
}

func GetSignalrService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSignalrService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSignalrServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, getSignalrServiceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SignalrService =============================

// ==========================  START: SpringCloudService =============================

type SpringCloudService struct {
	Description   azure.SpringCloudServiceDescription `json:"description"`
	Metadata      azure.Metadata                      `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type SpringCloudServiceHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  SpringCloudService `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type SpringCloudServiceHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []SpringCloudServiceHit `json:"hits"`
}

type SpringCloudServiceSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  SpringCloudServiceHits `json:"hits"`
}

type SpringCloudServicePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSpringCloudServicePaginator(filters []essdk.BoolFilter, limit *int64) (SpringCloudServicePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_appplatform_spring", filters, limit)
	if err != nil {
		return SpringCloudServicePaginator{}, err
	}

	p := SpringCloudServicePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SpringCloudServicePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SpringCloudServicePaginator) NextPage(ctx context.Context) ([]SpringCloudService, error) {
	var response SpringCloudServiceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SpringCloudService
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSpringCloudServiceFilters = map[string]string{
	"akas":                "description.ServiceResource.ID",
	"diagnostic_settings": "description.DiagnosticSettingsResource",
	"id":                  "description.ServiceResource.ID",
	"kaytu_account_id":    "metadata.SourceID",
	"name":                "description.ServiceResource.Name",
	"provisioning_state":  "description.ServiceResource.Properties.ProvisioningState",
	"region":              "description.ServiceResource.Location",
	"resource_group":      "description.ResourceGroup",
	"service_id":          "description.ServiceResource.Properties.ServiceID",
	"sku_capacity":        "description.ServiceResource.Sku.Capacity",
	"sku_name":            "description.ServiceResource.Sku.Name",
	"sku_tier":            "description.ServiceResource.Sku.Tier",
	"tags":                "description.ServiceResource.Tags",
	"title":               "description.ServiceResource.Name",
	"type":                "description.ServiceResource.Type",
	"version":             "description.ServiceResource.Properties.Version",
}

func ListSpringCloudService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSpringCloudService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSpringCloudServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, listSpringCloudServiceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSpringCloudServiceFilters = map[string]string{
	"akas":                "description.ServiceResource.ID",
	"diagnostic_settings": "description.DiagnosticSettingsResource",
	"id":                  "description.ServiceResource.ID",
	"kaytu_account_id":    "metadata.SourceID",
	"name":                "description.ServiceResource.name",
	"provisioning_state":  "description.ServiceResource.Properties.ProvisioningState",
	"region":              "description.ServiceResource.Location",
	"resource_group":      "description.ResourceGroup",
	"service_id":          "description.ServiceResource.Properties.ServiceID",
	"sku_capacity":        "description.ServiceResource.Sku.Capacity",
	"sku_name":            "description.ServiceResource.Sku.Name",
	"sku_tier":            "description.ServiceResource.Sku.Tier",
	"tags":                "description.ServiceResource.Tags",
	"title":               "description.ServiceResource.Name",
	"type":                "description.ServiceResource.Type",
	"version":             "description.ServiceResource.Properties.Version",
}

func GetSpringCloudService(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSpringCloudService")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSpringCloudServicePaginator(essdk.BuildFilter(d.KeyColumnQuals, getSpringCloudServiceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SpringCloudService =============================

// ==========================  START: StreamAnalyticsJob =============================

type StreamAnalyticsJob struct {
	Description   azure.StreamAnalyticsJobDescription `json:"description"`
	Metadata      azure.Metadata                      `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type StreamAnalyticsJobHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  StreamAnalyticsJob `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type StreamAnalyticsJobHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []StreamAnalyticsJobHit `json:"hits"`
}

type StreamAnalyticsJobSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  StreamAnalyticsJobHits `json:"hits"`
}

type StreamAnalyticsJobPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStreamAnalyticsJobPaginator(filters []essdk.BoolFilter, limit *int64) (StreamAnalyticsJobPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_streamanalytics_streamingjobs", filters, limit)
	if err != nil {
		return StreamAnalyticsJobPaginator{}, err
	}

	p := StreamAnalyticsJobPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StreamAnalyticsJobPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StreamAnalyticsJobPaginator) NextPage(ctx context.Context) ([]StreamAnalyticsJob, error) {
	var response StreamAnalyticsJobSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StreamAnalyticsJob
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStreamAnalyticsJobFilters = map[string]string{
	"akas":                "description.StreamingJob.ID",
	"compatibility_level": "description.StreamingJob.StreamingJobProperties.CompatibilityLevel",
	"created_date":        "description.StreamingJob.StreamingJobProperties.CreatedDate",
	"data_locale":         "description.StreamingJob.StreamingJobProperties.DataLocale",
	"diagnostic_settings": "description.DiagnosticSettingsResources",
	"etag":                "description.StreamingJob.StreamingJobProperties.Etag",
	"events_late_arrival_max_delay_in_seconds": "description.StreamingJob.StreamingJobProperties.EventsLateArrivalMaxDelayInSeconds",
	"events_out_of_order_max_delay_in_seconds": "description.StreamingJob.StreamingJobProperties.EventsOutOfOrderMaxDelayInSeconds",
	"events_out_of_order_policy":               "description.StreamingJob.StreamingJobProperties.EventsOutOfOrderPolicy",
	"functions":                                "description.StreamingJob.StreamingJobProperties.Functions",
	"id":                                       "description.StreamingJob.ID",
	"inputs":                                   "description.StreamingJob.StreamingJobProperties.Inputs",
	"job_id":                                   "description.StreamingJob.StreamingJobProperties.JobID",
	"job_state":                                "description.StreamingJob.StreamingJobProperties.JobState",
	"kaytu_account_id":                         "metadata.SourceID",
	"last_output_event_time":                   "description.StreamingJob.StreamingJobProperties.LastOutputEventTime",
	"name":                                     "description.StreamingJob.Name",
	"output_error_policy":                      "description.StreamingJob.StreamingJobProperties.OutputErrorPolicy",
	"output_start_mode":                        "description.StreamingJob.StreamingJobProperties.OutputStartMode",
	"output_start_time":                        "description.StreamingJob.StreamingJobProperties.OutputStartTime",
	"outputs":                                  "description.StreamingJob.StreamingJobProperties.Outputs",
	"provisioning_state":                       "description.StreamingJob.StreamingJobProperties.ProvisioningState",
	"region":                                   "description.StreamingJob.Location",
	"resource_group":                           "description.ResourceGroup",
	"sku_name":                                 "description.StreamingJob.StreamingJobProperties.Sku.Name",
	"tags":                                     "description.StreamingJob.Tags",
	"title":                                    "description.StreamingJob.Name",
	"transformation":                           "description.StreamingJob.StreamingJobProperties.Transformation",
	"type":                                     "description.StreamingJob.Type",
}

func ListStreamAnalyticsJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStreamAnalyticsJob")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStreamAnalyticsJobPaginator(essdk.BuildFilter(d.KeyColumnQuals, listStreamAnalyticsJobFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStreamAnalyticsJobFilters = map[string]string{
	"akas":                "description.StreamingJob.ID",
	"compatibility_level": "description.StreamingJob.StreamingJobProperties.CompatibilityLevel",
	"created_date":        "description.StreamingJob.StreamingJobProperties.CreatedDate",
	"data_locale":         "description.StreamingJob.StreamingJobProperties.DataLocale",
	"diagnostic_settings": "description.DiagnosticSettingsResources",
	"etag":                "description.StreamingJob.StreamingJobProperties.Etag",
	"events_late_arrival_max_delay_in_seconds": "description.StreamingJob.StreamingJobProperties.EventsLateArrivalMaxDelayInSeconds",
	"events_out_of_order_max_delay_in_seconds": "description.StreamingJob.StreamingJobProperties.EventsOutOfOrderMaxDelayInSeconds",
	"events_out_of_order_policy":               "description.StreamingJob.StreamingJobProperties.EventsOutOfOrderPolicy",
	"functions":                                "description.StreamingJob.StreamingJobProperties.Functions",
	"id":                                       "description.StreamingJob.ID",
	"inputs":                                   "description.StreamingJob.StreamingJobProperties.Inputs",
	"job_id":                                   "description.StreamingJob.StreamingJobProperties.JobID",
	"job_state":                                "description.StreamingJob.StreamingJobProperties.JobState",
	"kaytu_account_id":                         "metadata.SourceID",
	"last_output_event_time":                   "description.StreamingJob.StreamingJobProperties.LastOutputEventTime",
	"name":                                     "description.StreamingJob.name",
	"output_error_policy":                      "description.StreamingJob.StreamingJobProperties.OutputErrorPolicy",
	"output_start_mode":                        "description.StreamingJob.StreamingJobProperties.OutputStartMode",
	"output_start_time":                        "description.StreamingJob.StreamingJobProperties.OutputStartTime",
	"outputs":                                  "description.StreamingJob.StreamingJobProperties.Outputs",
	"provisioning_state":                       "description.StreamingJob.StreamingJobProperties.ProvisioningState",
	"region":                                   "description.StreamingJob.Location",
	"resource_group":                           "description.ResourceGroup",
	"sku_name":                                 "description.StreamingJob.StreamingJobProperties.Sku.Name",
	"tags":                                     "description.StreamingJob.Tags",
	"title":                                    "description.StreamingJob.Name",
	"transformation":                           "description.StreamingJob.StreamingJobProperties.Transformation",
	"type":                                     "description.StreamingJob.Type",
}

func GetStreamAnalyticsJob(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStreamAnalyticsJob")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStreamAnalyticsJobPaginator(essdk.BuildFilter(d.KeyColumnQuals, getStreamAnalyticsJobFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StreamAnalyticsJob =============================

// ==========================  START: StreamAnalyticsCluster =============================

type StreamAnalyticsCluster struct {
	Description   azure.StreamAnalyticsClusterDescription `json:"description"`
	Metadata      azure.Metadata                          `json:"metadata"`
	ResourceJobID int                                     `json:"resource_job_id"`
	SourceJobID   int                                     `json:"source_job_id"`
	ResourceType  string                                  `json:"resource_type"`
	SourceType    string                                  `json:"source_type"`
	ID            string                                  `json:"id"`
	ARN           string                                  `json:"arn"`
	SourceID      string                                  `json:"source_id"`
}

type StreamAnalyticsClusterHit struct {
	ID      string                 `json:"_id"`
	Score   float64                `json:"_score"`
	Index   string                 `json:"_index"`
	Type    string                 `json:"_type"`
	Version int64                  `json:"_version,omitempty"`
	Source  StreamAnalyticsCluster `json:"_source"`
	Sort    []interface{}          `json:"sort"`
}

type StreamAnalyticsClusterHits struct {
	Total essdk.SearchTotal           `json:"total"`
	Hits  []StreamAnalyticsClusterHit `json:"hits"`
}

type StreamAnalyticsClusterSearchResponse struct {
	PitID string                     `json:"pit_id"`
	Hits  StreamAnalyticsClusterHits `json:"hits"`
}

type StreamAnalyticsClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStreamAnalyticsClusterPaginator(filters []essdk.BoolFilter, limit *int64) (StreamAnalyticsClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_streamanalytics_cluster", filters, limit)
	if err != nil {
		return StreamAnalyticsClusterPaginator{}, err
	}

	p := StreamAnalyticsClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StreamAnalyticsClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StreamAnalyticsClusterPaginator) NextPage(ctx context.Context) ([]StreamAnalyticsCluster, error) {
	var response StreamAnalyticsClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StreamAnalyticsCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStreamAnalyticsClusterFilters = map[string]string{
	"akas":             "description.Cluster.ID",
	"id":               "description.Cluster.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Cluster.Name",
	"tags":             "description.Cluster.Tags",
	"title":            "description.Cluster.Name",
}

func ListStreamAnalyticsCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStreamAnalyticsCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStreamAnalyticsClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listStreamAnalyticsClusterFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStreamAnalyticsClusterFilters = map[string]string{
	"akas":             "description.Cluster.ID",
	"id":               "description.Cluster.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Cluster.Name",
	"tags":             "description.Cluster.Tags",
	"title":            "description.Cluster.Name",
}

func GetStreamAnalyticsCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStreamAnalyticsCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStreamAnalyticsClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getStreamAnalyticsClusterFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StreamAnalyticsCluster =============================

// ==========================  START: VirtualMachineImagesImageTemplates =============================

type VirtualMachineImagesImageTemplates struct {
	Description   azure.VirtualMachineImagesImageTemplatesDescription `json:"description"`
	Metadata      azure.Metadata                                      `json:"metadata"`
	ResourceJobID int                                                 `json:"resource_job_id"`
	SourceJobID   int                                                 `json:"source_job_id"`
	ResourceType  string                                              `json:"resource_type"`
	SourceType    string                                              `json:"source_type"`
	ID            string                                              `json:"id"`
	ARN           string                                              `json:"arn"`
	SourceID      string                                              `json:"source_id"`
}

type VirtualMachineImagesImageTemplatesHit struct {
	ID      string                             `json:"_id"`
	Score   float64                            `json:"_score"`
	Index   string                             `json:"_index"`
	Type    string                             `json:"_type"`
	Version int64                              `json:"_version,omitempty"`
	Source  VirtualMachineImagesImageTemplates `json:"_source"`
	Sort    []interface{}                      `json:"sort"`
}

type VirtualMachineImagesImageTemplatesHits struct {
	Total essdk.SearchTotal                       `json:"total"`
	Hits  []VirtualMachineImagesImageTemplatesHit `json:"hits"`
}

type VirtualMachineImagesImageTemplatesSearchResponse struct {
	PitID string                                 `json:"pit_id"`
	Hits  VirtualMachineImagesImageTemplatesHits `json:"hits"`
}

type VirtualMachineImagesImageTemplatesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewVirtualMachineImagesImageTemplatesPaginator(filters []essdk.BoolFilter, limit *int64) (VirtualMachineImagesImageTemplatesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_virtualmachineimages_imagetemplates", filters, limit)
	if err != nil {
		return VirtualMachineImagesImageTemplatesPaginator{}, err
	}

	p := VirtualMachineImagesImageTemplatesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p VirtualMachineImagesImageTemplatesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p VirtualMachineImagesImageTemplatesPaginator) NextPage(ctx context.Context) ([]VirtualMachineImagesImageTemplates, error) {
	var response VirtualMachineImagesImageTemplatesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []VirtualMachineImagesImageTemplates
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listVirtualMachineImagesImageTemplatesFilters = map[string]string{
	"akas":             "description.ImageTemplates.ID",
	"id":               "description.ImageTemplates.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ImageTemplates.Name",
	"tags":             "description.ImageTemplates.Tags",
	"title":            "description.ImageTemplates.Name",
}

func ListVirtualMachineImagesImageTemplates(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListVirtualMachineImagesImageTemplates")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewVirtualMachineImagesImageTemplatesPaginator(essdk.BuildFilter(d.KeyColumnQuals, listVirtualMachineImagesImageTemplatesFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getVirtualMachineImagesImageTemplatesFilters = map[string]string{
	"akas":             "description.ImageTemplates.ID",
	"id":               "description.ImageTemplates.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ImageTemplates.Name",
	"tags":             "description.ImageTemplates.Tags",
	"title":            "description.ImageTemplates.Name",
}

func GetVirtualMachineImagesImageTemplates(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetVirtualMachineImagesImageTemplates")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewVirtualMachineImagesImageTemplatesPaginator(essdk.BuildFilter(d.KeyColumnQuals, getVirtualMachineImagesImageTemplatesFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: VirtualMachineImagesImageTemplates =============================

// ==========================  START: OperationalInsightsWorkspaces =============================

type OperationalInsightsWorkspaces struct {
	Description   azure.OperationalInsightsWorkspacesDescription `json:"description"`
	Metadata      azure.Metadata                                 `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type OperationalInsightsWorkspacesHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  OperationalInsightsWorkspaces `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type OperationalInsightsWorkspacesHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []OperationalInsightsWorkspacesHit `json:"hits"`
}

type OperationalInsightsWorkspacesSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  OperationalInsightsWorkspacesHits `json:"hits"`
}

type OperationalInsightsWorkspacesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewOperationalInsightsWorkspacesPaginator(filters []essdk.BoolFilter, limit *int64) (OperationalInsightsWorkspacesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_operationalinsights_workspaces", filters, limit)
	if err != nil {
		return OperationalInsightsWorkspacesPaginator{}, err
	}

	p := OperationalInsightsWorkspacesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p OperationalInsightsWorkspacesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p OperationalInsightsWorkspacesPaginator) NextPage(ctx context.Context) ([]OperationalInsightsWorkspaces, error) {
	var response OperationalInsightsWorkspacesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []OperationalInsightsWorkspaces
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listOperationalInsightsWorkspacesFilters = map[string]string{
	"akas":             "description.Workspaces.ID",
	"id":               "description.Workspaces.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Workspaces.Name",
	"tags":             "description.Workspaces.Tags",
	"title":            "description.Workspaces.Name",
}

func ListOperationalInsightsWorkspaces(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListOperationalInsightsWorkspaces")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewOperationalInsightsWorkspacesPaginator(essdk.BuildFilter(d.KeyColumnQuals, listOperationalInsightsWorkspacesFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getOperationalInsightsWorkspacesFilters = map[string]string{
	"akas":             "description.Workspaces.ID",
	"id":               "description.Workspaces.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Workspaces.Name",
	"tags":             "description.Workspaces.Tags",
	"title":            "description.Workspaces.Name",
}

func GetOperationalInsightsWorkspaces(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetOperationalInsightsWorkspaces")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewOperationalInsightsWorkspacesPaginator(essdk.BuildFilter(d.KeyColumnQuals, getOperationalInsightsWorkspacesFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: OperationalInsightsWorkspaces =============================

// ==========================  START: TimeSeriesInsightsEnvironments =============================

type TimeSeriesInsightsEnvironments struct {
	Description   azure.TimeSeriesInsightsEnvironmentsDescription `json:"description"`
	Metadata      azure.Metadata                                  `json:"metadata"`
	ResourceJobID int                                             `json:"resource_job_id"`
	SourceJobID   int                                             `json:"source_job_id"`
	ResourceType  string                                          `json:"resource_type"`
	SourceType    string                                          `json:"source_type"`
	ID            string                                          `json:"id"`
	ARN           string                                          `json:"arn"`
	SourceID      string                                          `json:"source_id"`
}

type TimeSeriesInsightsEnvironmentsHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  TimeSeriesInsightsEnvironments `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type TimeSeriesInsightsEnvironmentsHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []TimeSeriesInsightsEnvironmentsHit `json:"hits"`
}

type TimeSeriesInsightsEnvironmentsSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  TimeSeriesInsightsEnvironmentsHits `json:"hits"`
}

type TimeSeriesInsightsEnvironmentsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewTimeSeriesInsightsEnvironmentsPaginator(filters []essdk.BoolFilter, limit *int64) (TimeSeriesInsightsEnvironmentsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_timeseriesinsights_environments", filters, limit)
	if err != nil {
		return TimeSeriesInsightsEnvironmentsPaginator{}, err
	}

	p := TimeSeriesInsightsEnvironmentsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p TimeSeriesInsightsEnvironmentsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p TimeSeriesInsightsEnvironmentsPaginator) NextPage(ctx context.Context) ([]TimeSeriesInsightsEnvironments, error) {
	var response TimeSeriesInsightsEnvironmentsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []TimeSeriesInsightsEnvironments
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listTimeSeriesInsightsEnvironmentsFilters = map[string]string{
	"akas":             "description.Environments.ID",
	"id":               "description.Environments.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Environments.Name",
	"tags":             "description.Environments.Tags",
	"title":            "description.Environments.Name",
}

func ListTimeSeriesInsightsEnvironments(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListTimeSeriesInsightsEnvironments")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewTimeSeriesInsightsEnvironmentsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listTimeSeriesInsightsEnvironmentsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getTimeSeriesInsightsEnvironmentsFilters = map[string]string{
	"akas":             "description.Environments.ID",
	"id":               "description.Environments.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Environments.Name",
	"tags":             "description.Environments.Tags",
	"title":            "description.Environments.Name",
}

func GetTimeSeriesInsightsEnvironments(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetTimeSeriesInsightsEnvironments")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewTimeSeriesInsightsEnvironmentsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getTimeSeriesInsightsEnvironmentsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: TimeSeriesInsightsEnvironments =============================

// ==========================  START: SynapseWorkspace =============================

type SynapseWorkspace struct {
	Description   azure.SynapseWorkspaceDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type SynapseWorkspaceHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  SynapseWorkspace `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type SynapseWorkspaceHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []SynapseWorkspaceHit `json:"hits"`
}

type SynapseWorkspaceSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  SynapseWorkspaceHits `json:"hits"`
}

type SynapseWorkspacePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSynapseWorkspacePaginator(filters []essdk.BoolFilter, limit *int64) (SynapseWorkspacePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_synapse_workspaces", filters, limit)
	if err != nil {
		return SynapseWorkspacePaginator{}, err
	}

	p := SynapseWorkspacePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SynapseWorkspacePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SynapseWorkspacePaginator) NextPage(ctx context.Context) ([]SynapseWorkspace, error) {
	var response SynapseWorkspaceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SynapseWorkspace
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSynapseWorkspaceFilters = map[string]string{
	"adla_resource_id":                 "description.Workspace.WorkspaceProperties.AdlaResourceID",
	"akas":                             "description.Workspace.ID",
	"connectivity_endpoints":           "description.Workspace.WorkspaceProperties.ConnectivityEndpoints",
	"default_data_lake_storage":        "description.Workspace.WorkspaceProperties.DefaultDataLakeStorage",
	"diagnostic_settings":              "description.DiagnosticSettingsResources",
	"extra_properties":                 "description.Workspace.WorkspaceProperties.ExtraProperties",
	"id":                               "description.Workspace.ID",
	"identity":                         "description.Workspace.Identity",
	"kaytu_account_id":                 "metadata.SourceID",
	"managed_resource_group_name":      "description.Workspace.WorkspaceProperties.ManagedResourceGroupName",
	"managed_virtual_network":          "description.Workspace.WorkspaceProperties.ManagedVirtualNetwork",
	"managed_virtual_network_settings": "description.Workspace.WorkspaceProperties.ManagedVirtualNetworkSettings",
	"name":                             "description.Workspace.Name",
	"provisioning_state":               "description.Workspace.WorkspaceProperties.ProvisioningState",
	"public_network_access":            "description.Workspace.WorkspaceProperties.PublicNetworkAccess",
	"purview_configuration":            "description.Workspace.WorkspaceProperties.PurviewConfiguration",
	"region":                           "description.Workspace.Location",
	"resource_group":                   "description.ResourceGroup",
	"sql_administrator_login":          "description.Workspace.WorkspaceProperties.SQLAdministratorLogin",
	"sql_administrator_login_password": "description.Workspace.WorkspaceProperties.SQLAdministratorLoginPassword",
	"tags":                             "description.Workspace.Tags",
	"title":                            "description.Workspace.Name",
	"type":                             "description.Workspace.Type",
	"virtual_network_profile":          "description.Workspace.WorkspaceProperties.VirtualNetworkProfile",
	"workspace_managed_sql_server_vulnerability_assessments": "description.ServerVulnerabilityAssessments",
	"workspace_repository_configuration":                     "description.Workspace.WorkspaceProperties.WorkspaceRepositoryConfiguration",
	"workspace_uid":                                          "description.Workspace.WorkspaceProperties.WorkspaceUID",
}

func ListSynapseWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSynapseWorkspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSynapseWorkspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, listSynapseWorkspaceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSynapseWorkspaceFilters = map[string]string{
	"adla_resource_id":                 "description.Workspace.WorkspaceProperties.AdlaResourceID",
	"akas":                             "description.Workspace.ID",
	"connectivity_endpoints":           "description.Workspace.WorkspaceProperties.ConnectivityEndpoints",
	"default_data_lake_storage":        "description.Workspace.WorkspaceProperties.DefaultDataLakeStorage",
	"diagnostic_settings":              "description.DiagnosticSettingsResources",
	"extra_properties":                 "description.Workspace.WorkspaceProperties.ExtraProperties",
	"id":                               "description.Workspace.ID",
	"identity":                         "description.Workspace.Identity",
	"kaytu_account_id":                 "metadata.SourceID",
	"managed_resource_group_name":      "description.Workspace.WorkspaceProperties.ManagedResourceGroupName",
	"managed_virtual_network":          "description.Workspace.WorkspaceProperties.ManagedVirtualNetwork",
	"managed_virtual_network_settings": "description.Workspace.WorkspaceProperties.ManagedVirtualNetworkSettings",
	"name":                             "description.Workspace.name",
	"provisioning_state":               "description.Workspace.WorkspaceProperties.ProvisioningState",
	"public_network_access":            "description.Workspace.WorkspaceProperties.PublicNetworkAccess",
	"purview_configuration":            "description.Workspace.WorkspaceProperties.PurviewConfiguration",
	"region":                           "description.Workspace.Location",
	"resource_group":                   "description.ResourceGroup",
	"sql_administrator_login":          "description.Workspace.WorkspaceProperties.SQLAdministratorLogin",
	"sql_administrator_login_password": "description.Workspace.WorkspaceProperties.SQLAdministratorLoginPassword",
	"tags":                             "description.Workspace.Tags",
	"title":                            "description.Workspace.Name",
	"type":                             "description.Workspace.Type",
	"virtual_network_profile":          "description.Workspace.WorkspaceProperties.VirtualNetworkProfile",
	"workspace_managed_sql_server_vulnerability_assessments": "description.ServerVulnerabilityAssessments",
	"workspace_repository_configuration":                     "description.Workspace.WorkspaceProperties.WorkspaceRepositoryConfiguration",
	"workspace_uid":                                          "description.Workspace.WorkspaceProperties.WorkspaceUID",
}

func GetSynapseWorkspace(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSynapseWorkspace")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSynapseWorkspacePaginator(essdk.BuildFilter(d.KeyColumnQuals, getSynapseWorkspaceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SynapseWorkspace =============================

// ==========================  START: SynapseWorkspaceBigdatapools =============================

type SynapseWorkspaceBigdatapools struct {
	Description   azure.SynapseWorkspaceBigdatapoolsDescription `json:"description"`
	Metadata      azure.Metadata                                `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type SynapseWorkspaceBigdatapoolsHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  SynapseWorkspaceBigdatapools `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type SynapseWorkspaceBigdatapoolsHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []SynapseWorkspaceBigdatapoolsHit `json:"hits"`
}

type SynapseWorkspaceBigdatapoolsSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  SynapseWorkspaceBigdatapoolsHits `json:"hits"`
}

type SynapseWorkspaceBigdatapoolsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSynapseWorkspaceBigdatapoolsPaginator(filters []essdk.BoolFilter, limit *int64) (SynapseWorkspaceBigdatapoolsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_synapse_workspaces_bigdatapools", filters, limit)
	if err != nil {
		return SynapseWorkspaceBigdatapoolsPaginator{}, err
	}

	p := SynapseWorkspaceBigdatapoolsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SynapseWorkspaceBigdatapoolsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SynapseWorkspaceBigdatapoolsPaginator) NextPage(ctx context.Context) ([]SynapseWorkspaceBigdatapools, error) {
	var response SynapseWorkspaceBigdatapoolsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SynapseWorkspaceBigdatapools
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSynapseWorkspaceBigdatapoolsFilters = map[string]string{
	"akas":             "description.WorkspacesBigDataPools.ID",
	"id":               "description.WorkspacesBigDataPools.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.WorkspacesBigDataPools.Name",
	"tags":             "description.WorkspacesBigDataPools.Tags",
	"title":            "description.WorkspacesBigDataPools.Name",
}

func ListSynapseWorkspaceBigdatapools(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSynapseWorkspaceBigdatapools")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSynapseWorkspaceBigdatapoolsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSynapseWorkspaceBigdatapoolsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSynapseWorkspaceBigdatapoolsFilters = map[string]string{
	"akas":             "description.WorkspacesBigDataPools.ID",
	"id":               "description.WorkspacesBigDataPools.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.WorkspacesBigDataPools.Name",
	"tags":             "description.WorkspacesBigDataPools.Tags",
	"title":            "description.WorkspacesBigDataPools.Name",
}

func GetSynapseWorkspaceBigdatapools(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSynapseWorkspaceBigdatapools")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSynapseWorkspaceBigdatapoolsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSynapseWorkspaceBigdatapoolsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SynapseWorkspaceBigdatapools =============================

// ==========================  START: SynapseWorkspaceSqlpools =============================

type SynapseWorkspaceSqlpools struct {
	Description   azure.SynapseWorkspaceSqlpoolsDescription `json:"description"`
	Metadata      azure.Metadata                            `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type SynapseWorkspaceSqlpoolsHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  SynapseWorkspaceSqlpools `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type SynapseWorkspaceSqlpoolsHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []SynapseWorkspaceSqlpoolsHit `json:"hits"`
}

type SynapseWorkspaceSqlpoolsSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  SynapseWorkspaceSqlpoolsHits `json:"hits"`
}

type SynapseWorkspaceSqlpoolsPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSynapseWorkspaceSqlpoolsPaginator(filters []essdk.BoolFilter, limit *int64) (SynapseWorkspaceSqlpoolsPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_synapse_workspaces_sqlpools", filters, limit)
	if err != nil {
		return SynapseWorkspaceSqlpoolsPaginator{}, err
	}

	p := SynapseWorkspaceSqlpoolsPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SynapseWorkspaceSqlpoolsPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SynapseWorkspaceSqlpoolsPaginator) NextPage(ctx context.Context) ([]SynapseWorkspaceSqlpools, error) {
	var response SynapseWorkspaceSqlpoolsSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SynapseWorkspaceSqlpools
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSynapseWorkspaceSqlpoolsFilters = map[string]string{
	"akas":             "description.WorkspacesSqlPools.ID",
	"id":               "description.WorkspacesSqlPools.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.WorkspacesSqlPools.Name",
	"tags":             "description.WorkspacesSqlPools.Tags",
	"title":            "description.WorkspacesSqlPools.Name",
}

func ListSynapseWorkspaceSqlpools(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSynapseWorkspaceSqlpools")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSynapseWorkspaceSqlpoolsPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSynapseWorkspaceSqlpoolsFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSynapseWorkspaceSqlpoolsFilters = map[string]string{
	"akas":             "description.WorkspacesSqlPools.ID",
	"id":               "description.WorkspacesSqlPools.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.WorkspacesSqlPools.Name",
	"tags":             "description.WorkspacesSqlPools.Tags",
	"title":            "description.WorkspacesSqlPools.Name",
}

func GetSynapseWorkspaceSqlpools(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSynapseWorkspaceSqlpools")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSynapseWorkspaceSqlpoolsPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSynapseWorkspaceSqlpoolsFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SynapseWorkspaceSqlpools =============================

// ==========================  START: Location =============================

type Location struct {
	Description   azure.LocationDescription `json:"description"`
	Metadata      azure.Metadata            `json:"metadata"`
	ResourceJobID int                       `json:"resource_job_id"`
	SourceJobID   int                       `json:"source_job_id"`
	ResourceType  string                    `json:"resource_type"`
	SourceType    string                    `json:"source_type"`
	ID            string                    `json:"id"`
	ARN           string                    `json:"arn"`
	SourceID      string                    `json:"source_id"`
}

type LocationHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Location      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LocationHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LocationHit     `json:"hits"`
}

type LocationSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  LocationHits `json:"hits"`
}

type LocationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLocationPaginator(filters []essdk.BoolFilter, limit *int64) (LocationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_subscriptions_locations", filters, limit)
	if err != nil {
		return LocationPaginator{}, err
	}

	p := LocationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LocationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LocationPaginator) NextPage(ctx context.Context) ([]Location, error) {
	var response LocationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Location
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLocationFilters = map[string]string{
	"akas":             "description.Location.ID",
	"display_name":     "description.Location.DisplayName",
	"id":               "description.Location.ID",
	"kaytu_account_id": "metadata.SourceID",
	"latitude":         "description.Location.Latitude",
	"longitude":        "description.Location.Longitude",
	"name":             "description.Location.Name",
	"title":            "description.Location.Name",
}

func ListLocation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLocation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLocationPaginator(essdk.BuildFilter(d.KeyColumnQuals, listLocationFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLocationFilters = map[string]string{
	"akas":             "description.Location.ID",
	"display_name":     "description.Location.DisplayName",
	"id":               "description.Location.ID",
	"kaytu_account_id": "metadata.SourceID",
	"latitude":         "description.Location.Latitude",
	"longitude":        "description.Location.Longitude",
	"name":             "description.Location.name",
	"resource_group":   "description.ResourceGroup",
	"title":            "description.Location.Name",
}

func GetLocation(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLocation")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLocationPaginator(essdk.BuildFilter(d.KeyColumnQuals, getLocationFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: Location =============================

// ==========================  START: AdUsers =============================

type AdUsers struct {
	Description   azure.AdUsersDescription `json:"description"`
	Metadata      azure.Metadata           `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type AdUsersHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  AdUsers       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AdUsersHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AdUsersHit      `json:"hits"`
}

type AdUsersSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  AdUsersHits `json:"hits"`
}

type AdUsersPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAdUsersPaginator(filters []essdk.BoolFilter, limit *int64) (AdUsersPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_users", filters, limit)
	if err != nil {
		return AdUsersPaginator{}, err
	}

	p := AdUsersPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AdUsersPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AdUsersPaginator) NextPage(ctx context.Context) ([]AdUsers, error) {
	var response AdUsersSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AdUsers
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAdUsersFilters = map[string]string{
	"account_enabled":                       "description.AdUsers.accountEnabled",
	"additional_properties":                 "description.AdUsers.AdditionalProperties",
	"created_date_time":                     "description.AdUsers.CreatedDateTime",
	"display_name":                          "description.AdUsers.displayName",
	"filter":                                "description.AdUsers.filter",
	"given_name":                            "description.AdUsers.GivenName",
	"id":                                    "description.AdUsers.DirectoryObject.id",
	"im_addresses":                          "description.AdUsers.ImAddresses",
	"kaytu_account_id":                      "metadata.SourceID",
	"kaytu_resource_id":                     "iD",
	"mail":                                  "description.AdUsers.Mail",
	"mail_nickname":                         "description.AdUsers.MailNickname",
	"member_of":                             "description.AdUsers.MemberOf",
	"metadata":                              "metadata",
	"on_premises_immutable_id":              "description.AdUsers.OnPremisesImmutableId",
	"other_mails":                           "description.AdUsers.OtherMails",
	"password_policies":                     "description.AdUsers.PasswordPolicies",
	"password_profile":                      "description.AdUsers.PasswordProfile",
	"refresh_tokens_valid_from_date_time":   "description.AdUsers.RefreshTokensValidFromDateTime",
	"sign_in_sessions_valid_from_date_time": "description.AdUsers.SignInSessionsValidFromDateTime",
	"surname":                               "description.AdUsers.surname",
	"tenant_id":                             "description.TenantID",
	"title":                                 "description.AdUsers.DisplayName",
	"usage_location":                        "description.AdUsers.UsageLocation",
	"user_principal_name":                   "description.AdUsers.userPrincipalName",
	"user_type":                             "description.AdUsers.userType",
}

func ListAdUsers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAdUsers")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAdUsersPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAdUsersFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAdUsersFilters = map[string]string{
	"account_enabled":                       "description.AdUsers.AccountEnabled",
	"additional_properties":                 "description.AdUsers.AdditionalProperties",
	"created_date_time":                     "description.AdUsers.CreatedDateTime",
	"display_name":                          "description.AdUsers.DisplayName",
	"given_name":                            "description.AdUsers.GivenName",
	"id":                                    "description.AdUsers.DirectoryObject.id",
	"im_addresses":                          "description.AdUsers.ImAddresses",
	"kaytu_account_id":                      "metadata.SourceID",
	"kaytu_resource_id":                     "iD",
	"mail":                                  "description.AdUsers.Mail",
	"mail_nickname":                         "description.AdUsers.MailNickname",
	"member_of":                             "description.AdUsers.MemberOf",
	"metadata":                              "metadata",
	"on_premises_immutable_id":              "description.AdUsers.OnPremisesImmutableId",
	"other_mails":                           "description.AdUsers.OtherMails",
	"password_policies":                     "description.AdUsers.PasswordPolicies",
	"password_profile":                      "description.AdUsers.PasswordProfile",
	"refresh_tokens_valid_from_date_time":   "description.AdUsers.RefreshTokensValidFromDateTime",
	"sign_in_sessions_valid_from_date_time": "description.AdUsers.SignInSessionsValidFromDateTime",
	"surname":                               "description.AdUsers.Surname",
	"tenant_id":                             "description.TenantID",
	"title":                                 "description.AdUsers.DisplayName",
	"usage_location":                        "description.AdUsers.UsageLocation",
	"user_principal_name":                   "description.AdUsers.UserPrincipalName",
	"user_type":                             "description.AdUsers.UserType",
}

func GetAdUsers(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAdUsers")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAdUsersPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAdUsersFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AdUsers =============================

// ==========================  START: AdGroup =============================

type AdGroup struct {
	Description   azure.AdGroupDescription `json:"description"`
	Metadata      azure.Metadata           `json:"metadata"`
	ResourceJobID int                      `json:"resource_job_id"`
	SourceJobID   int                      `json:"source_job_id"`
	ResourceType  string                   `json:"resource_type"`
	SourceType    string                   `json:"source_type"`
	ID            string                   `json:"id"`
	ARN           string                   `json:"arn"`
	SourceID      string                   `json:"source_id"`
}

type AdGroupHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  AdGroup       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AdGroupHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AdGroupHit      `json:"hits"`
}

type AdGroupSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  AdGroupHits `json:"hits"`
}

type AdGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAdGroupPaginator(filters []essdk.BoolFilter, limit *int64) (AdGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_groups", filters, limit)
	if err != nil {
		return AdGroupPaginator{}, err
	}

	p := AdGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AdGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AdGroupPaginator) NextPage(ctx context.Context) ([]AdGroup, error) {
	var response AdGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AdGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAdGroupFilters = map[string]string{
	"assigned_labels":                  "description.AdGroup.GroupAssignedLabel",
	"classification":                   "description.AdGroup.Classification",
	"created_date_time":                "description.AdGroup.CreatedDateTime",
	"description":                      "description.AdGroup.Description",
	"display_name":                     "description.AdGroup.DisplayName",
	"expiration_date_time":             "description.AdGroup.ExpirationDateTime",
	"group_types":                      "description.AdGroup.GroupTypes",
	"id":                               "description.AdGroup.DirectoryObject.ID",
	"is_assignable_to_role":            "description.AdGroup.Classification",
	"is_subscribed_by_mail":            "description.AdGroup.IsAssignableToRole",
	"kaytu_account_id":                 "metadata.SourceID",
	"mail":                             "description.AdGroup.Mail",
	"mail_enabled":                     "description.AdGroup.MailEnabled",
	"mail_nickname":                    "description.AdGroup.MailNickname",
	"member_ids":                       "description.AdGroup.Members",
	"membership_rule":                  "description.AdGroup.MembershipRule",
	"membership_rule_processing_state": "description.AdGroup.MembershipRuleProcessingState",
	"on_premises_domain_name":          "description.AdGroup.OnPremisesDomainName",
	"on_premises_last_sync_date_time":  "description.AdGroup.OnPremisesLastSyncDateTime",
	"on_premises_net_bios_name":        "description.AdGroup.OnPremisesNetBiosName",
	"on_premises_sam_account_name":     "description.AdGroup.OnPremisesSamAccountName",
	"on_premises_security_identifier":  "description.AdGroup.OnPremisesSecurityIdentifier",
	"on_premises_sync_enabled":         "description.AdGroup.OnPremisesSyncEnabled",
	"owner_ids":                        "description.AdGroup.Owners",
	"proxy_addresses":                  "description.AdGroup.ProxyAddresses",
	"renewed_date_time":                "description.AdGroup.RenewedDateTime",
	"resource_behavior_options":        "description.AdGroup.ResourceBehaviorOptions",
	"resource_provisioning_options":    "description.AdGroup.ResourceProvisioningOptions",
	"security_enabled":                 "description.AdGroup.SecurityEnabled",
	"security_identifier":              "description.AdGroup.SecurityIdentifier",
	"tenant_id":                        "description.TenantID",
	"visibility":                       "description.AdGroup.Visibility",
}

func ListAdGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAdGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAdGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAdGroupFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAdGroupFilters = map[string]string{
	"assigned_labels":                  "description.AdGroup.GroupAssignedLabel",
	"classification":                   "description.AdGroup.Classification",
	"created_date_time":                "description.AdGroup.CreatedDateTime",
	"description":                      "description.AdGroup.Description",
	"display_name":                     "description.AdGroup.DisplayName",
	"expiration_date_time":             "description.AdGroup.ExpirationDateTime",
	"group_types":                      "description.AdGroup.GroupTypes",
	"id":                               "description.AdGroup.DirectoryObject.ID",
	"is_assignable_to_role":            "description.AdGroup.Classification",
	"is_subscribed_by_mail":            "description.AdGroup.IsAssignableToRole",
	"kaytu_account_id":                 "metadata.SourceID",
	"mail":                             "description.AdGroup.Mail",
	"mail_enabled":                     "description.AdGroup.MailEnabled",
	"mail_nickname":                    "description.AdGroup.MailNickname",
	"member_ids":                       "description.AdGroup.Members",
	"membership_rule":                  "description.AdGroup.MembershipRule",
	"membership_rule_processing_state": "description.AdGroup.MembershipRuleProcessingState",
	"on_premises_domain_name":          "description.AdGroup.OnPremisesDomainName",
	"on_premises_last_sync_date_time":  "description.AdGroup.OnPremisesLastSyncDateTime",
	"on_premises_net_bios_name":        "description.AdGroup.OnPremisesNetBiosName",
	"on_premises_sam_account_name":     "description.AdGroup.OnPremisesSamAccountName",
	"on_premises_security_identifier":  "description.AdGroup.OnPremisesSecurityIdentifier",
	"on_premises_sync_enabled":         "description.AdGroup.OnPremisesSyncEnabled",
	"owner_ids":                        "description.AdGroup.Owners",
	"proxy_addresses":                  "description.AdGroup.ProxyAddresses",
	"renewed_date_time":                "description.AdGroup.RenewedDateTime",
	"resource_behavior_options":        "description.AdGroup.ResourceBehaviorOptions",
	"resource_provisioning_options":    "description.AdGroup.ResourceProvisioningOptions",
	"security_enabled":                 "description.AdGroup.SecurityEnabled",
	"security_identifier":              "description.AdGroup.SecurityIdentifier",
	"tenant_id":                        "description.TenantID",
	"visibility":                       "description.AdGroup.Visibility",
}

func GetAdGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAdGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAdGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAdGroupFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AdGroup =============================

// ==========================  START: AdServicePrincipal =============================

type AdServicePrincipal struct {
	Description   azure.AdServicePrincipalDescription `json:"description"`
	Metadata      azure.Metadata                      `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type AdServicePrincipalHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  AdServicePrincipal `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type AdServicePrincipalHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []AdServicePrincipalHit `json:"hits"`
}

type AdServicePrincipalSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  AdServicePrincipalHits `json:"hits"`
}

type AdServicePrincipalPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAdServicePrincipalPaginator(filters []essdk.BoolFilter, limit *int64) (AdServicePrincipalPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_serviceprincipals", filters, limit)
	if err != nil {
		return AdServicePrincipalPaginator{}, err
	}

	p := AdServicePrincipalPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AdServicePrincipalPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AdServicePrincipalPaginator) NextPage(ctx context.Context) ([]AdServicePrincipal, error) {
	var response AdServicePrincipalSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AdServicePrincipal
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAdServicePrincipalFilters = map[string]string{
	"account_enabled":              "description.AdServicePrincipal.AccountEnabled",
	"add_ins":                      "description.AdServicePrincipal.AddIns",
	"alternative_names":            "description.AdServicePrincipal.AlternativeNames",
	"app_description":              "description.AdServicePrincipal.Description",
	"app_display_name":             "description.AdServicePrincipal.AppDisplayName",
	"app_id":                       "description.AdServicePrincipal.AppId",
	"app_owner_organization_id":    "description.AdServicePrincipal.AppOwnerOrganizationId",
	"app_role_assignment_required": "description.AdServicePrincipal.AppRoleAssignmentRequired",
	"app_roles":                    "description.AdServicePrincipal.AppRoles",
	"description":                  "description.AdServicePrincipal.Description",
	"display_name":                 "description.AdServicePrincipal.DisplayName",
	"id":                           "description.AdServicePrincipal.DirectoryObject.ID",
	"info":                         "description.AdServicePrincipal.Info",
	"kaytu_account_id":             "metadata.SourceID",
	"key_credentials":              "description.AdServicePrincipal.KeyCredentials",
	"login_url":                    "description.AdServicePrincipal.LoginUrl",
	"logout_url":                   "description.AdServicePrincipal.LogoutUrl",
	"notification_email_addresses": "description.AdServicePrincipal.NotificationEmailAddresses",
	"oauth2_permission_scopes":     "description.AdServicePrincipal.PublishedPermissionScopes",
	"owner_ids":                    "description.AdServicePrincipal.Owners",
	"password_credentials":         "description.AdServicePrincipal.PasswordCredentials",
	"reply_urls":                   "description.AdServicePrincipal.ReplyUrls",
	"service_principal_names":      "description.AdServicePrincipal.ServicePrincipalNames",
	"service_principal_type":       "description.AdServicePrincipal.ServicePrincipalType",
	"sign_in_audience":             "description.AdServicePrincipal.SignInAudience",
	"tags_src":                     "description.AdServicePrincipal.Tags",
	"tenant_id":                    "description.TenantID",
}

func ListAdServicePrincipal(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAdServicePrincipal")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAdServicePrincipalPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAdServicePrincipalFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAdServicePrincipalFilters = map[string]string{
	"account_enabled":              "description.AdServicePrincipal.AccountEnabled",
	"add_ins":                      "description.AdServicePrincipal.AddIns",
	"alternative_names":            "description.AdServicePrincipal.AlternativeNames",
	"app_description":              "description.AdServicePrincipal.Description",
	"app_display_name":             "description.AdServicePrincipal.AppDisplayName",
	"app_id":                       "description.AdServicePrincipal.AppId",
	"app_owner_organization_id":    "description.AdServicePrincipal.AppOwnerOrganizationId",
	"app_role_assignment_required": "description.AdServicePrincipal.AppRoleAssignmentRequired",
	"app_roles":                    "description.AdServicePrincipal.AppRoles",
	"description":                  "description.AdServicePrincipal.Description",
	"display_name":                 "description.AdServicePrincipal.DisplayName",
	"id":                           "description.AdServicePrincipal.DirectoryObject.ID",
	"info":                         "description.AdServicePrincipal.Info",
	"kaytu_account_id":             "metadata.SourceID",
	"key_credentials":              "description.AdServicePrincipal.KeyCredentials",
	"login_url":                    "description.AdServicePrincipal.LoginUrl",
	"logout_url":                   "description.AdServicePrincipal.LogoutUrl",
	"notification_email_addresses": "description.AdServicePrincipal.NotificationEmailAddresses",
	"oauth2_permission_scopes":     "description.AdServicePrincipal.PublishedPermissionScopes",
	"owner_ids":                    "description.AdServicePrincipal.Owners",
	"password_credentials":         "description.AdServicePrincipal.PasswordCredentials",
	"reply_urls":                   "description.AdServicePrincipal.ReplyUrls",
	"service_principal_names":      "description.AdServicePrincipal.ServicePrincipalNames",
	"service_principal_type":       "description.AdServicePrincipal.ServicePrincipalType",
	"sign_in_audience":             "description.AdServicePrincipal.SignInAudience",
	"tags_src":                     "description.AdServicePrincipal.Tags",
	"tenant_id":                    "description.TenantID",
}

func GetAdServicePrincipal(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAdServicePrincipal")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAdServicePrincipalPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAdServicePrincipalFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AdServicePrincipal =============================

// ==========================  START: AnalysisServiceServer =============================

type AnalysisServiceServer struct {
	Description   azure.AnalysisServiceServerDescription `json:"description"`
	Metadata      azure.Metadata                         `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type AnalysisServiceServerHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  AnalysisServiceServer `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type AnalysisServiceServerHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []AnalysisServiceServerHit `json:"hits"`
}

type AnalysisServiceServerSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  AnalysisServiceServerHits `json:"hits"`
}

type AnalysisServiceServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAnalysisServiceServerPaginator(filters []essdk.BoolFilter, limit *int64) (AnalysisServiceServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_analysisservices_servers", filters, limit)
	if err != nil {
		return AnalysisServiceServerPaginator{}, err
	}

	p := AnalysisServiceServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AnalysisServiceServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AnalysisServiceServerPaginator) NextPage(ctx context.Context) ([]AnalysisServiceServer, error) {
	var response AnalysisServiceServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AnalysisServiceServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAnalysisServiceServerFilters = map[string]string{
	"akas":             "description.Servers.ID",
	"id":               "description.Servers.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Servers.Name",
	"tags":             "description.Servers.Tags",
	"title":            "description.Servers.Name",
}

func ListAnalysisServiceServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAnalysisServiceServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewAnalysisServiceServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listAnalysisServiceServerFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getAnalysisServiceServerFilters = map[string]string{
	"akas":             "description.Servers.ID",
	"id":               "description.Servers.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Server.name",
	"resource_group":   "description.ResourceGroup",
	"tags":             "description.Servers.Tags",
	"title":            "description.Servers.Name",
}

func GetAnalysisServiceServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAnalysisServiceServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewAnalysisServiceServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getAnalysisServiceServerFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: AnalysisServiceServer =============================

// ==========================  START: PostgresqlServer =============================

type PostgresqlServer struct {
	Description   azure.PostgresqlServerDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type PostgresqlServerHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  PostgresqlServer `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type PostgresqlServerHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []PostgresqlServerHit `json:"hits"`
}

type PostgresqlServerSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  PostgresqlServerHits `json:"hits"`
}

type PostgresqlServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPostgresqlServerPaginator(filters []essdk.BoolFilter, limit *int64) (PostgresqlServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dbforpostgresql_servers", filters, limit)
	if err != nil {
		return PostgresqlServerPaginator{}, err
	}

	p := PostgresqlServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PostgresqlServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PostgresqlServerPaginator) NextPage(ctx context.Context) ([]PostgresqlServer, error) {
	var response PostgresqlServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PostgresqlServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPostgresqlServerFilters = map[string]string{
	"administrator_login":         "description.Server.ServerProperties.AdministratorLogin",
	"akas":                        "description.Server.ID",
	"backup_retention_days":       "description.Server.ServerProperties.StorageProfile.BackupRetentionDays",
	"byok_enforcement":            "description.Server.ServerProperties.ByokEnforcement",
	"earliest_restore_date":       "description.Server.ServerProperties.EarliestRestoreDate",
	"firewall_rules":              "description.FirewallRules",
	"fully_qualified_domain_name": "description.Server.ServerProperties.FullyQualifiedDomainName",
	"geo_redundant_backup":        "description.Server.ServerProperties.StorageProfile.GeoRedundantBackup",
	"id":                          "description.Server.ID",
	"infrastructure_encryption":   "description.Server.ServerProperties.InfrastructureEncryption",
	"kaytu_account_id":            "metadata.SourceID",
	"location":                    "description.Server.Location",
	"master_server_id":            "description.Server.ServerProperties.MasterServerID",
	"minimal_tls_version":         "description.Server.ServerProperties.MinimalTLSVersion",
	"name":                        "description.Server.Name",
	"public_network_access":       "description.Server.ServerProperties.PublicNetworkAccess",
	"region":                      "description.Server.Location",
	"replica_capacity":            "description.Server.ServerProperties.ReplicaCapacity",
	"replication_role":            "description.Server.ServerProperties.ReplicationRole",
	"resource_group":              "description.ResourceGroup",
	"server_administrators":       "description.ServerAdministratorResources",
	"server_configurations":       "description.Configurations",
	"server_keys":                 "description.ServerKeys",
	"sku_capacity":                "description.Server.Sku.Capacity",
	"sku_family":                  "description.Server.Sku.Family",
	"sku_name":                    "description.Server.Sku.Name",
	"sku_size":                    "description.Server.Sku.Size",
	"sku_tier":                    "description.Server.Sku.Tier",
	"ssl_enforcement":             "description.Server.ServerProperties.SslEnforcement",
	"storage_auto_grow":           "description.Server.ServerProperties.StorageProfile.StorageAutogrow",
	"storage_mb":                  "description.Server.ServerProperties.StorageProfile.StorageMB",
	"tags":                        "description.Server.Tags",
	"title":                       "description.Server.Name",
	"type":                        "description.Server.Type",
	"user_visible_state":          "description.Server.ServerProperties.UserVisibleState",
	"version":                     "description.Server.ServerProperties.Version",
}

func ListPostgresqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPostgresqlServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewPostgresqlServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listPostgresqlServerFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getPostgresqlServerFilters = map[string]string{
	"administrator_login":         "description.Server.ServerProperties.AdministratorLogin",
	"akas":                        "description.Server.ID",
	"backup_retention_days":       "description.Server.ServerProperties.StorageProfile.BackupRetentionDays",
	"byok_enforcement":            "description.Server.ServerProperties.ByokEnforcement",
	"earliest_restore_date":       "description.Server.ServerProperties.EarliestRestoreDate",
	"firewall_rules":              "description.FirewallRules",
	"fully_qualified_domain_name": "description.Server.ServerProperties.FullyQualifiedDomainName",
	"geo_redundant_backup":        "description.Server.ServerProperties.StorageProfile.GeoRedundantBackup",
	"id":                          "description.Server.ID",
	"infrastructure_encryption":   "description.Server.ServerProperties.InfrastructureEncryption",
	"kaytu_account_id":            "metadata.SourceID",
	"location":                    "description.Server.Location",
	"master_server_id":            "description.Server.ServerProperties.MasterServerID",
	"minimal_tls_version":         "description.Server.ServerProperties.MinimalTLSVersion",
	"name":                        "description.Server.name",
	"public_network_access":       "description.Server.ServerProperties.PublicNetworkAccess",
	"region":                      "description.Server.Location",
	"replica_capacity":            "description.Server.ServerProperties.ReplicaCapacity",
	"replication_role":            "description.Server.ServerProperties.ReplicationRole",
	"resource_group":              "description.ResourceGroup",
	"server_administrators":       "description.ServerAdministratorResources",
	"server_configurations":       "description.Configurations",
	"server_keys":                 "description.ServerKeys",
	"sku_capacity":                "description.Server.Sku.Capacity",
	"sku_family":                  "description.Server.Sku.Family",
	"sku_name":                    "description.Server.Sku.Name",
	"sku_size":                    "description.Server.Sku.Size",
	"sku_tier":                    "description.Server.Sku.Tier",
	"ssl_enforcement":             "description.Server.ServerProperties.SslEnforcement",
	"storage_auto_grow":           "description.Server.ServerProperties.StorageProfile.StorageAutogrow",
	"storage_mb":                  "description.Server.ServerProperties.StorageProfile.StorageMB",
	"tags":                        "description.Server.Tags",
	"title":                       "description.Server.Name",
	"type":                        "description.Server.Type",
	"user_visible_state":          "description.Server.ServerProperties.UserVisibleState",
	"version":                     "description.Server.ServerProperties.Version",
}

func GetPostgresqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPostgresqlServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewPostgresqlServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getPostgresqlServerFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: PostgresqlServer =============================

// ==========================  START: PostgresqlFlexibleServer =============================

type PostgresqlFlexibleServer struct {
	Description   azure.PostgresqlFlexibleServerDescription `json:"description"`
	Metadata      azure.Metadata                            `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type PostgresqlFlexibleServerHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  PostgresqlFlexibleServer `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type PostgresqlFlexibleServerHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []PostgresqlFlexibleServerHit `json:"hits"`
}

type PostgresqlFlexibleServerSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  PostgresqlFlexibleServerHits `json:"hits"`
}

type PostgresqlFlexibleServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPostgresqlFlexibleServerPaginator(filters []essdk.BoolFilter, limit *int64) (PostgresqlFlexibleServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_dbforpostgresql_flexibleservers", filters, limit)
	if err != nil {
		return PostgresqlFlexibleServerPaginator{}, err
	}

	p := PostgresqlFlexibleServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PostgresqlFlexibleServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PostgresqlFlexibleServerPaginator) NextPage(ctx context.Context) ([]PostgresqlFlexibleServer, error) {
	var response PostgresqlFlexibleServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PostgresqlFlexibleServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPostgresqlFlexibleServerFilters = map[string]string{
	"akas":             "description.FlexibleServers.ID",
	"id":               "description.FlexibleServers.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.FlexibleServers.Name",
	"tags":             "description.FlexibleServers.Tags",
	"title":            "description.FlexibleServers.Name",
}

func ListPostgresqlFlexibleServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPostgresqlFlexibleServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewPostgresqlFlexibleServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listPostgresqlFlexibleServerFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getPostgresqlFlexibleServerFilters = map[string]string{
	"akas":             "description.FlexibleServers.ID",
	"id":               "description.FlexibleServers.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.FlexibleServers.Name",
	"tags":             "description.FlexibleServers.Tags",
	"title":            "description.FlexibleServers.Name",
}

func GetPostgresqlFlexibleServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPostgresqlFlexibleServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewPostgresqlFlexibleServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getPostgresqlFlexibleServerFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: PostgresqlFlexibleServer =============================

// ==========================  START: StorageSync =============================

type StorageSync struct {
	Description   azure.StorageSyncDescription `json:"description"`
	Metadata      azure.Metadata               `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type StorageSyncHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  StorageSync   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type StorageSyncHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []StorageSyncHit  `json:"hits"`
}

type StorageSyncSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  StorageSyncHits `json:"hits"`
}

type StorageSyncPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageSyncPaginator(filters []essdk.BoolFilter, limit *int64) (StorageSyncPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storagesync_storagesyncservices", filters, limit)
	if err != nil {
		return StorageSyncPaginator{}, err
	}

	p := StorageSyncPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageSyncPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageSyncPaginator) NextPage(ctx context.Context) ([]StorageSync, error) {
	var response StorageSyncSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageSync
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageSyncFilters = map[string]string{
	"akas":                        "description.Service.ID",
	"id":                          "description.Service.ID",
	"incoming_traffic_policy":     "description.Service.ServiceProperties.IncomingTrafficPolicy",
	"kaytu_account_id":            "metadata.SourceID",
	"last_operation_name":         "description.Service.ServiceProperties.LastOperationName",
	"last_workflow_id":            "description.Service.ServiceProperties.LastWorkflowID",
	"name":                        "description.Service.Name",
	"provisioning_state":          "description.Service.ServiceProperties.ProvisioningState",
	"region":                      "description.Service.Location",
	"resource_group":              "description.ResourceGroup",
	"storage_sync_service_status": "description.Service.ServiceProperties.StorageSyncServiceStatus",
	"storage_sync_service_uid":    "description.Service.ServiceProperties.StorageSyncServiceUID",
	"tags":                        "description.Service.Tags",
	"title":                       "description.Service.Name",
	"type":                        "description.Service.Type",
}

func ListStorageSync(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageSync")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStorageSyncPaginator(essdk.BuildFilter(d.KeyColumnQuals, listStorageSyncFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStorageSyncFilters = map[string]string{
	"akas":                        "description.Service.ID",
	"id":                          "description.Service.ID",
	"incoming_traffic_policy":     "description.Service.ServiceProperties.IncomingTrafficPolicy",
	"kaytu_account_id":            "metadata.SourceID",
	"last_operation_name":         "description.Service.ServiceProperties.LastOperationName",
	"last_workflow_id":            "description.Service.ServiceProperties.LastWorkflowID",
	"name":                        "description.Service.name",
	"provisioning_state":          "description.Service.ServiceProperties.ProvisioningState",
	"region":                      "description.Service.Location",
	"resource_group":              "description.ResourceGroup",
	"storage_sync_service_status": "description.Service.ServiceProperties.StorageSyncServiceStatus",
	"storage_sync_service_uid":    "description.Service.ServiceProperties.StorageSyncServiceUID",
	"tags":                        "description.Service.Tags",
	"title":                       "description.Service.Name",
	"type":                        "description.Service.Type",
}

func GetStorageSync(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageSync")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStorageSyncPaginator(essdk.BuildFilter(d.KeyColumnQuals, getStorageSyncFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StorageSync =============================

// ==========================  START: MssqlManagedInstance =============================

type MssqlManagedInstance struct {
	Description   azure.MssqlManagedInstanceDescription `json:"description"`
	Metadata      azure.Metadata                        `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type MssqlManagedInstanceHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  MssqlManagedInstance `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type MssqlManagedInstanceHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []MssqlManagedInstanceHit `json:"hits"`
}

type MssqlManagedInstanceSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  MssqlManagedInstanceHits `json:"hits"`
}

type MssqlManagedInstancePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMssqlManagedInstancePaginator(filters []essdk.BoolFilter, limit *int64) (MssqlManagedInstancePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_managedinstances", filters, limit)
	if err != nil {
		return MssqlManagedInstancePaginator{}, err
	}

	p := MssqlManagedInstancePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MssqlManagedInstancePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MssqlManagedInstancePaginator) NextPage(ctx context.Context) ([]MssqlManagedInstance, error) {
	var response MssqlManagedInstanceSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MssqlManagedInstance
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMssqlManagedInstanceFilters = map[string]string{
	"administrator_login":          "description.ManagedInstance.ManagedInstanceProperties.AdministratorLogin",
	"administrator_login_password": "description.ManagedInstance.ManagedInstanceProperties.AdministratorLoginPassword",
	"akas":                         "description.ManagedInstance.ID",
	"collation":                    "description.ManagedInstance.ManagedInstanceProperties.Collation",
	"dns_zone":                     "description.ManagedInstance.ManagedInstanceProperties.DNSZone",
	"dns_zone_partner":             "description.ManagedInstance.ManagedInstanceProperties.DNSZonePartner",
	"encryption_protectors":        "description.ManagedInstanceEncryptionProtectors",
	"fully_qualified_domain_name":  "description.ManagedInstance.ManagedInstanceProperties.FullyQualifiedDomainName",
	"id":                           "description.ManagedInstance.ID",
	"identity":                     "description.ManagedInstance.Identity",
	"instance_pool_id":             "description.ManagedInstance.ManagedInstanceProperties.InstancePoolID",
	"kaytu_account_id":             "metadata.SourceID",
	"license_type":                 "description.ManagedInstance.ManagedInstanceProperties.LicenseType",
	"maintenance_configuration_id": "description.ManagedInstance.ManagedInstanceProperties.MaintenanceConfigurationID",
	"managed_instance_create_mode": "description.ManagedInstance.ManagedInstanceProperties.ManagedInstanceCreateMode",
	"minimal_tls_version":          "description.ManagedInstance.ManagedInstanceProperties.MinimalTLSVersion",
	"name":                         "description.ManagedInstance.Name",
	"proxy_override":               "description.ManagedInstance.ManagedInstanceProperties.ProxyOverride",
	"public_data_endpoint_enabled": "description.ManagedInstance.ManagedInstanceProperties.PublicDataEndpointEnabled",
	"region":                       "description.ManagedInstance.Location",
	"resource_group":               "description.ResourceGroup",
	"restore_point_in_time":        "description.ManagedInstance.ManagedInstanceProperties.RestorePointInTime",
	"security_alert_policies":      "description.ManagedDatabaseSecurityAlertPolicies",
	"sku":                          "description.ManagedInstance.Sku",
	"source_managed_instance_id":   "description.ManagedInstance.ManagedInstanceProperties.SourceManagedInstanceID",
	"state":                        "description.ManagedInstance.ManagedInstanceProperties.State",
	"storage_size_in_gb":           "description.ManagedInstance.ManagedInstanceProperties.StorageSizeInGB",
	"subnet_id":                    "description.ManagedInstance.ManagedInstanceProperties.SubnetID",
	"tags":                         "description.ManagedInstance.Tags",
	"timezone_id":                  "description.ManagedInstance.ManagedInstanceProperties.TimezoneID",
	"title":                        "description.ManagedInstance.Name",
	"type":                         "description.ManagedInstance.Type",
	"v_cores":                      "description.ManagedInstance.ManagedInstanceProperties.VCores",
	"vulnerability_assessments":    "description.ManagedInstanceVulnerabilityAssessments",
}

func ListMssqlManagedInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMssqlManagedInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewMssqlManagedInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, listMssqlManagedInstanceFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMssqlManagedInstanceFilters = map[string]string{
	"administrator_login":          "description.ManagedInstance.ManagedInstanceProperties.AdministratorLogin",
	"administrator_login_password": "description.ManagedInstance.ManagedInstanceProperties.AdministratorLoginPassword",
	"akas":                         "description.ManagedInstance.ID",
	"collation":                    "description.ManagedInstance.ManagedInstanceProperties.Collation",
	"dns_zone":                     "description.ManagedInstance.ManagedInstanceProperties.DNSZone",
	"dns_zone_partner":             "description.ManagedInstance.ManagedInstanceProperties.DNSZonePartner",
	"encryption_protectors":        "description.ManagedInstanceEncryptionProtectors",
	"fully_qualified_domain_name":  "description.ManagedInstance.ManagedInstanceProperties.FullyQualifiedDomainName",
	"id":                           "description.ManagedInstance.ID",
	"identity":                     "description.ManagedInstance.Identity",
	"instance_pool_id":             "description.ManagedInstance.ManagedInstanceProperties.InstancePoolID",
	"kaytu_account_id":             "metadata.SourceID",
	"license_type":                 "description.ManagedInstance.ManagedInstanceProperties.LicenseType",
	"maintenance_configuration_id": "description.ManagedInstance.ManagedInstanceProperties.MaintenanceConfigurationID",
	"managed_instance_create_mode": "description.ManagedInstance.ManagedInstanceProperties.ManagedInstanceCreateMode",
	"minimal_tls_version":          "description.ManagedInstance.ManagedInstanceProperties.MinimalTLSVersion",
	"name":                         "description.ManagedInstance.name",
	"proxy_override":               "description.ManagedInstance.ManagedInstanceProperties.ProxyOverride",
	"public_data_endpoint_enabled": "description.ManagedInstance.ManagedInstanceProperties.PublicDataEndpointEnabled",
	"region":                       "description.ManagedInstance.Location",
	"resource_group":               "description.ResourceGroup",
	"restore_point_in_time":        "description.ManagedInstance.ManagedInstanceProperties.RestorePointInTime",
	"security_alert_policies":      "description.ManagedDatabaseSecurityAlertPolicies",
	"sku":                          "description.ManagedInstance.Sku",
	"source_managed_instance_id":   "description.ManagedInstance.ManagedInstanceProperties.SourceManagedInstanceID",
	"state":                        "description.ManagedInstance.ManagedInstanceProperties.State",
	"storage_size_in_gb":           "description.ManagedInstance.ManagedInstanceProperties.StorageSizeInGB",
	"subnet_id":                    "description.ManagedInstance.ManagedInstanceProperties.SubnetID",
	"tags":                         "description.ManagedInstance.Tags",
	"timezone_id":                  "description.ManagedInstance.ManagedInstanceProperties.TimezoneID",
	"title":                        "description.ManagedInstance.Name",
	"type":                         "description.ManagedInstance.Type",
	"v_cores":                      "description.ManagedInstance.ManagedInstanceProperties.VCores",
	"vulnerability_assessments":    "description.ManagedInstanceVulnerabilityAssessments",
}

func GetMssqlManagedInstance(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMssqlManagedInstance")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewMssqlManagedInstancePaginator(essdk.BuildFilter(d.KeyColumnQuals, getMssqlManagedInstanceFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MssqlManagedInstance =============================

// ==========================  START: MssqlManagedInstanceDatabases =============================

type MssqlManagedInstanceDatabases struct {
	Description   azure.MssqlManagedInstanceDatabasesDescription `json:"description"`
	Metadata      azure.Metadata                                 `json:"metadata"`
	ResourceJobID int                                            `json:"resource_job_id"`
	SourceJobID   int                                            `json:"source_job_id"`
	ResourceType  string                                         `json:"resource_type"`
	SourceType    string                                         `json:"source_type"`
	ID            string                                         `json:"id"`
	ARN           string                                         `json:"arn"`
	SourceID      string                                         `json:"source_id"`
}

type MssqlManagedInstanceDatabasesHit struct {
	ID      string                        `json:"_id"`
	Score   float64                       `json:"_score"`
	Index   string                        `json:"_index"`
	Type    string                        `json:"_type"`
	Version int64                         `json:"_version,omitempty"`
	Source  MssqlManagedInstanceDatabases `json:"_source"`
	Sort    []interface{}                 `json:"sort"`
}

type MssqlManagedInstanceDatabasesHits struct {
	Total essdk.SearchTotal                  `json:"total"`
	Hits  []MssqlManagedInstanceDatabasesHit `json:"hits"`
}

type MssqlManagedInstanceDatabasesSearchResponse struct {
	PitID string                            `json:"pit_id"`
	Hits  MssqlManagedInstanceDatabasesHits `json:"hits"`
}

type MssqlManagedInstanceDatabasesPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewMssqlManagedInstanceDatabasesPaginator(filters []essdk.BoolFilter, limit *int64) (MssqlManagedInstanceDatabasesPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_managedinstances_databases", filters, limit)
	if err != nil {
		return MssqlManagedInstanceDatabasesPaginator{}, err
	}

	p := MssqlManagedInstanceDatabasesPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p MssqlManagedInstanceDatabasesPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p MssqlManagedInstanceDatabasesPaginator) NextPage(ctx context.Context) ([]MssqlManagedInstanceDatabases, error) {
	var response MssqlManagedInstanceDatabasesSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []MssqlManagedInstanceDatabases
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listMssqlManagedInstanceDatabasesFilters = map[string]string{
	"akas":             "description.ManagedInstancesDatabases.ID",
	"id":               "description.ManagedInstancesDatabases.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ManagedInstancesDatabases.Name",
	"tags":             "description.ManagedInstancesDatabases.Tags",
	"title":            "description.ManagedInstancesDatabases.Name",
}

func ListMssqlManagedInstanceDatabases(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListMssqlManagedInstanceDatabases")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewMssqlManagedInstanceDatabasesPaginator(essdk.BuildFilter(d.KeyColumnQuals, listMssqlManagedInstanceDatabasesFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getMssqlManagedInstanceDatabasesFilters = map[string]string{
	"akas":             "description.ManagedInstancesDatabases.ID",
	"id":               "description.ManagedInstancesDatabases.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ManagedInstancesDatabases.Name",
	"tags":             "description.ManagedInstancesDatabases.Tags",
	"title":            "description.ManagedInstancesDatabases.Name",
}

func GetMssqlManagedInstanceDatabases(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetMssqlManagedInstanceDatabases")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewMssqlManagedInstanceDatabasesPaginator(essdk.BuildFilter(d.KeyColumnQuals, getMssqlManagedInstanceDatabasesFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: MssqlManagedInstanceDatabases =============================

// ==========================  START: SqlDatabase =============================

type SqlDatabase struct {
	Description   azure.SqlDatabaseDescription `json:"description"`
	Metadata      azure.Metadata               `json:"metadata"`
	ResourceJobID int                          `json:"resource_job_id"`
	SourceJobID   int                          `json:"source_job_id"`
	ResourceType  string                       `json:"resource_type"`
	SourceType    string                       `json:"source_type"`
	ID            string                       `json:"id"`
	ARN           string                       `json:"arn"`
	SourceID      string                       `json:"source_id"`
}

type SqlDatabaseHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SqlDatabase   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SqlDatabaseHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SqlDatabaseHit  `json:"hits"`
}

type SqlDatabaseSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  SqlDatabaseHits `json:"hits"`
}

type SqlDatabasePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlDatabasePaginator(filters []essdk.BoolFilter, limit *int64) (SqlDatabasePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_servers_databases", filters, limit)
	if err != nil {
		return SqlDatabasePaginator{}, err
	}

	p := SqlDatabasePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlDatabasePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlDatabasePaginator) NextPage(ctx context.Context) ([]SqlDatabase, error) {
	var response SqlDatabaseSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlDatabase
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlDatabaseFilters = map[string]string{
	"akas":                         "description.Database.ID",
	"collation":                    "description.Database.DatabaseProperties.Collation",
	"containment_state":            "description.Database.DatabaseProperties.ContainmentState",
	"create_mode":                  "description.Database.DatabaseProperties.CreateMode",
	"creation_date":                "description.Database.DatabaseProperties.CreationDate",
	"current_service_objective_id": "description.Database.DatabaseProperties.CurrentServiceObjectiveID",
	"database_id":                  "description.Database.DatabaseProperties.DatabaseID",
	"default_secondary_location":   "description.Database.DatabaseProperties.DefaultSecondaryLocation",
	"earliest_restore_date":        "description.Database.DatabaseProperties.EarliestRestoreDate",
	"edition":                      "description.Database.DatabaseProperties.Edition",
	"elastic_pool_name":            "description.Database.DatabaseProperties.ElasticPoolName",
	"failover_group_id":            "description.Database.DatabaseProperties.FailoverGroupID",
	"id":                           "description.Database.ID",
	"kaytu_account_id":             "metadata.SourceID",
	"kind":                         "description.Database.Kind",
	"location":                     "description.Database.Location",
	"max_size_bytes":               "description.Database.DatabaseProperties.MaxSizeBytes",
	"name":                         "description.Database.Name",
	"read_scale":                   "description.Database.DatabaseProperties.ReadScale",
	"recommended_index":            "description.Database.DatabaseProperties.RecommendedIndex",
	"recovery_services_recovery_point_resource_id": "description.Database.DatabaseProperties.RecoveryServicesRecoveryPointResourceID",
	"region":                                "description.Database.Location",
	"requested_service_objective_id":        "description.Database.DatabaseProperties.RequestedServiceObjectiveID",
	"requested_service_objective_name":      "description.Database.DatabaseProperties.RequestedServiceObjectiveName",
	"resource_group":                        "description.ResourceGroup",
	"restore_point_in_time":                 "description.Database.DatabaseProperties.RestorePointInTime",
	"retention_policy_id":                   "description.LongTermRetentionPolicy.ID",
	"retention_policy_name":                 "description.LongTermRetentionPolicy.Name",
	"retention_policy_property":             "description.LongTermRetentionPolicy",
	"retention_policy_type":                 "description.LongTermRetentionPolicy.Type",
	"sample_name":                           "description.Database.DatabaseProperties.SampleName",
	"service_level_objective":               "description.Database.DatabaseProperties.ServiceLevelObjective",
	"service_tier_advisors":                 "description.Database.DatabaseProperties.ServiceTierAdvisors",
	"source_database_deletion_date":         "description.Database.DatabaseProperties.SourceDatabaseDeletionDate",
	"source_database_id":                    "description.Database.DatabaseProperties.SourceDatabaseID",
	"status":                                "description.Database.DatabaseProperties.Status",
	"tags":                                  "description.Database.Tags",
	"title":                                 "description.Database.Name",
	"transparent_data_encryption":           "description.TransparentDataEncryption.TransparentDataEncryptionProperties",
	"type":                                  "description.Database.Type",
	"vulnerability_assessment_scan_records": "description.VulnerabilityAssessmentScanRecords",
	"vulnerability_assessments":             "description.DatabaseVulnerabilityAssessments",
	"zone_redundant":                        "description.Database.DatabaseProperties.ZoneRedundant",
}

func ListSqlDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlDatabase")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSqlDatabasePaginator(essdk.BuildFilter(d.KeyColumnQuals, listSqlDatabaseFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSqlDatabaseFilters = map[string]string{
	"akas":                         "description.Database.ID",
	"collation":                    "description.Database.DatabaseProperties.Collation",
	"containment_state":            "description.Database.DatabaseProperties.ContainmentState",
	"create_mode":                  "description.Database.DatabaseProperties.CreateMode",
	"creation_date":                "description.Database.DatabaseProperties.CreationDate",
	"current_service_objective_id": "description.Database.DatabaseProperties.CurrentServiceObjectiveID",
	"database_id":                  "description.Database.DatabaseProperties.DatabaseID",
	"default_secondary_location":   "description.Database.DatabaseProperties.DefaultSecondaryLocation",
	"earliest_restore_date":        "description.Database.DatabaseProperties.EarliestRestoreDate",
	"edition":                      "description.Database.DatabaseProperties.Edition",
	"elastic_pool_name":            "description.Database.DatabaseProperties.ElasticPoolName",
	"failover_group_id":            "description.Database.DatabaseProperties.FailoverGroupID",
	"id":                           "description.Database.ID",
	"kaytu_account_id":             "metadata.SourceID",
	"kind":                         "description.Database.Kind",
	"location":                     "description.Database.Location",
	"max_size_bytes":               "description.Database.DatabaseProperties.MaxSizeBytes",
	"name":                         "description.Database.name",
	"read_scale":                   "description.Database.DatabaseProperties.ReadScale",
	"recommended_index":            "description.Database.DatabaseProperties.RecommendedIndex",
	"recovery_services_recovery_point_resource_id": "description.Database.DatabaseProperties.RecoveryServicesRecoveryPointResourceID",
	"region":                                "description.Database.Location",
	"requested_service_objective_id":        "description.Database.DatabaseProperties.RequestedServiceObjectiveID",
	"requested_service_objective_name":      "description.Database.DatabaseProperties.RequestedServiceObjectiveName",
	"resource_group":                        "description.ResourceGroup",
	"restore_point_in_time":                 "description.Database.DatabaseProperties.RestorePointInTime",
	"retention_policy_id":                   "description.LongTermRetentionPolicy.ID",
	"retention_policy_name":                 "description.LongTermRetentionPolicy.Name",
	"retention_policy_property":             "description.LongTermRetentionPolicy",
	"retention_policy_type":                 "description.LongTermRetentionPolicy.Type",
	"sample_name":                           "description.Database.DatabaseProperties.SampleName",
	"service_level_objective":               "description.Database.DatabaseProperties.ServiceLevelObjective",
	"service_tier_advisors":                 "description.Database.DatabaseProperties.ServiceTierAdvisors",
	"source_database_deletion_date":         "description.Database.DatabaseProperties.SourceDatabaseDeletionDate",
	"source_database_id":                    "description.Database.DatabaseProperties.SourceDatabaseID",
	"status":                                "description.Database.DatabaseProperties.Status",
	"tags":                                  "description.Database.Tags",
	"title":                                 "description.Database.Name",
	"transparent_data_encryption":           "description.TransparentDataEncryption.TransparentDataEncryptionProperties",
	"type":                                  "description.Database.Type",
	"vulnerability_assessment_scan_records": "description.VulnerabilityAssessmentScanRecords",
	"vulnerability_assessments":             "description.DatabaseVulnerabilityAssessments",
	"zone_redundant":                        "description.Database.DatabaseProperties.ZoneRedundant",
}

func GetSqlDatabase(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlDatabase")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSqlDatabasePaginator(essdk.BuildFilter(d.KeyColumnQuals, getSqlDatabaseFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SqlDatabase =============================

// ==========================  START: SqlServer =============================

type SqlServer struct {
	Description   azure.SqlServerDescription `json:"description"`
	Metadata      azure.Metadata             `json:"metadata"`
	ResourceJobID int                        `json:"resource_job_id"`
	SourceJobID   int                        `json:"source_job_id"`
	ResourceType  string                     `json:"resource_type"`
	SourceType    string                     `json:"source_type"`
	ID            string                     `json:"id"`
	ARN           string                     `json:"arn"`
	SourceID      string                     `json:"source_id"`
}

type SqlServerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  SqlServer     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type SqlServerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []SqlServerHit    `json:"hits"`
}

type SqlServerSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  SqlServerHits `json:"hits"`
}

type SqlServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlServerPaginator(filters []essdk.BoolFilter, limit *int64) (SqlServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_servers", filters, limit)
	if err != nil {
		return SqlServerPaginator{}, err
	}

	p := SqlServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlServerPaginator) NextPage(ctx context.Context) ([]SqlServer, error) {
	var response SqlServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlServerFilters = map[string]string{
	"administrator_login":             "description.Server.ServerProperties.AdministratorLogin",
	"administrator_login_password":    "description.Server.ServerProperties.AdministratorLoginPassword",
	"akas":                            "description.Server.ID",
	"encryption_protector":            "description.EncryptionProtectors",
	"firewall_rules":                  "description.FirewallRules",
	"fully_qualified_domain_name":     "description.Server.ServerProperties.FullyQualifiedDomainName",
	"id":                              "description.Server.ID",
	"kaytu_account_id":                "metadata.SourceID",
	"kind":                            "description.Server.Kind",
	"location":                        "description.Server.Location",
	"minimal_tls_version":             "description.Server.ServerProperties.MinimalTLSVersion",
	"name":                            "description.Server.Name",
	"private_endpoint_connections":    "description.PrivateEndpointConnections",
	"public_network_access":           "description.Server.ServerProperties.PublicNetworkAccess",
	"region":                          "description.Server.Location",
	"resource_group":                  "description.ResourceGroup",
	"server_audit_policy":             "description.ServerBlobAuditingPolicies",
	"server_azure_ad_administrator":   "description.ServerAzureADAdministrators",
	"server_security_alert_policy":    "description.ServerSecurityAlertPolicies",
	"server_vulnerability_assessment": "description.ServerVulnerabilityAssessments",
	"state":                           "description.Server.ServerProperties.State",
	"tags":                            "description.Server.Tags",
	"tags_src":                        "description.Server.Tags",
	"title":                           "description.Server.Name",
	"type":                            "description.Server.Type",
	"version":                         "description.Server.ServerProperties.Version",
	"virtual_network_rules":           "description.VirtualNetworkRules",
}

func ListSqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSqlServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSqlServerFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSqlServerFilters = map[string]string{
	"administrator_login":             "description.Server.ServerProperties.AdministratorLogin",
	"administrator_login_password":    "description.Server.ServerProperties.AdministratorLoginPassword",
	"akas":                            "description.Server.ID",
	"encryption_protector":            "description.EncryptionProtectors",
	"firewall_rules":                  "description.FirewallRules",
	"fully_qualified_domain_name":     "description.Server.ServerProperties.FullyQualifiedDomainName",
	"id":                              "description.Server.ID",
	"kaytu_account_id":                "metadata.SourceID",
	"kind":                            "description.Server.Kind",
	"location":                        "description.Server.Location",
	"minimal_tls_version":             "description.Server.ServerProperties.MinimalTLSVersion",
	"name":                            "description.Server.name",
	"private_endpoint_connections":    "description.PrivateEndpointConnections",
	"public_network_access":           "description.Server.ServerProperties.PublicNetworkAccess",
	"region":                          "description.Server.Location",
	"resource_group":                  "description.ResourceGroup",
	"server_audit_policy":             "description.ServerBlobAuditingPolicies",
	"server_azure_ad_administrator":   "description.ServerAzureADAdministrators",
	"server_security_alert_policy":    "description.ServerSecurityAlertPolicies",
	"server_vulnerability_assessment": "description.ServerVulnerabilityAssessments",
	"state":                           "description.Server.ServerProperties.State",
	"tags":                            "description.Server.Tags",
	"tags_src":                        "description.Server.Tags",
	"title":                           "description.Server.Name",
	"type":                            "description.Server.Type",
	"version":                         "description.Server.ServerProperties.Version",
	"virtual_network_rules":           "description.VirtualNetworkRules",
}

func GetSqlServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSqlServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSqlServerFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SqlServer =============================

// ==========================  START: SqlServerJobAgent =============================

type SqlServerJobAgent struct {
	Description   azure.SqlServerJobAgentDescription `json:"description"`
	Metadata      azure.Metadata                     `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type SqlServerJobAgentHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  SqlServerJobAgent `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type SqlServerJobAgentHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []SqlServerJobAgentHit `json:"hits"`
}

type SqlServerJobAgentSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  SqlServerJobAgentHits `json:"hits"`
}

type SqlServerJobAgentPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlServerJobAgentPaginator(filters []essdk.BoolFilter, limit *int64) (SqlServerJobAgentPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_servers_jobagents", filters, limit)
	if err != nil {
		return SqlServerJobAgentPaginator{}, err
	}

	p := SqlServerJobAgentPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlServerJobAgentPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlServerJobAgentPaginator) NextPage(ctx context.Context) ([]SqlServerJobAgent, error) {
	var response SqlServerJobAgentSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlServerJobAgent
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlServerJobAgentFilters = map[string]string{
	"akas":             "description.ServersJobAgents.ID",
	"id":               "description.ServersJobAgents.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ServersJobAgents.Name",
	"tags":             "description.ServersJobAgents.Tags",
	"title":            "description.ServersJobAgents.Name",
}

func ListSqlServerJobAgent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlServerJobAgent")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSqlServerJobAgentPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSqlServerJobAgentFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSqlServerJobAgentFilters = map[string]string{
	"akas":             "description.ServersJobAgents.ID",
	"id":               "description.ServersJobAgents.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.ServersJobAgents.Name",
	"tags":             "description.ServersJobAgents.Tags",
	"title":            "description.ServersJobAgents.Name",
}

func GetSqlServerJobAgent(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlServerJobAgent")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSqlServerJobAgentPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSqlServerJobAgentFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SqlServerJobAgent =============================

// ==========================  START: SqlVirtualClusters =============================

type SqlVirtualClusters struct {
	Description   azure.SqlVirtualClustersDescription `json:"description"`
	Metadata      azure.Metadata                      `json:"metadata"`
	ResourceJobID int                                 `json:"resource_job_id"`
	SourceJobID   int                                 `json:"source_job_id"`
	ResourceType  string                              `json:"resource_type"`
	SourceType    string                              `json:"source_type"`
	ID            string                              `json:"id"`
	ARN           string                              `json:"arn"`
	SourceID      string                              `json:"source_id"`
}

type SqlVirtualClustersHit struct {
	ID      string             `json:"_id"`
	Score   float64            `json:"_score"`
	Index   string             `json:"_index"`
	Type    string             `json:"_type"`
	Version int64              `json:"_version,omitempty"`
	Source  SqlVirtualClusters `json:"_source"`
	Sort    []interface{}      `json:"sort"`
}

type SqlVirtualClustersHits struct {
	Total essdk.SearchTotal       `json:"total"`
	Hits  []SqlVirtualClustersHit `json:"hits"`
}

type SqlVirtualClustersSearchResponse struct {
	PitID string                 `json:"pit_id"`
	Hits  SqlVirtualClustersHits `json:"hits"`
}

type SqlVirtualClustersPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlVirtualClustersPaginator(filters []essdk.BoolFilter, limit *int64) (SqlVirtualClustersPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_virtualclusters", filters, limit)
	if err != nil {
		return SqlVirtualClustersPaginator{}, err
	}

	p := SqlVirtualClustersPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlVirtualClustersPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlVirtualClustersPaginator) NextPage(ctx context.Context) ([]SqlVirtualClusters, error) {
	var response SqlVirtualClustersSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlVirtualClusters
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlVirtualClustersFilters = map[string]string{
	"akas":             "description.VirtualClusters.ID",
	"id":               "description.VirtualClusters.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VirtualClusters.Name",
	"tags":             "description.VirtualClusters.Tags",
	"title":            "description.VirtualClusters.Name",
}

func ListSqlVirtualClusters(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlVirtualClusters")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSqlVirtualClustersPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSqlVirtualClustersFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSqlVirtualClustersFilters = map[string]string{
	"akas":             "description.VirtualClusters.ID",
	"id":               "description.VirtualClusters.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VirtualClusters.Name",
	"tags":             "description.VirtualClusters.Tags",
	"title":            "description.VirtualClusters.Name",
}

func GetSqlVirtualClusters(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlVirtualClusters")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSqlVirtualClustersPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSqlVirtualClustersFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SqlVirtualClusters =============================

// ==========================  START: SqlServerElasticPool =============================

type SqlServerElasticPool struct {
	Description   azure.SqlServerElasticPoolDescription `json:"description"`
	Metadata      azure.Metadata                        `json:"metadata"`
	ResourceJobID int                                   `json:"resource_job_id"`
	SourceJobID   int                                   `json:"source_job_id"`
	ResourceType  string                                `json:"resource_type"`
	SourceType    string                                `json:"source_type"`
	ID            string                                `json:"id"`
	ARN           string                                `json:"arn"`
	SourceID      string                                `json:"source_id"`
}

type SqlServerElasticPoolHit struct {
	ID      string               `json:"_id"`
	Score   float64              `json:"_score"`
	Index   string               `json:"_index"`
	Type    string               `json:"_type"`
	Version int64                `json:"_version,omitempty"`
	Source  SqlServerElasticPool `json:"_source"`
	Sort    []interface{}        `json:"sort"`
}

type SqlServerElasticPoolHits struct {
	Total essdk.SearchTotal         `json:"total"`
	Hits  []SqlServerElasticPoolHit `json:"hits"`
}

type SqlServerElasticPoolSearchResponse struct {
	PitID string                   `json:"pit_id"`
	Hits  SqlServerElasticPoolHits `json:"hits"`
}

type SqlServerElasticPoolPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlServerElasticPoolPaginator(filters []essdk.BoolFilter, limit *int64) (SqlServerElasticPoolPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_elasticpools", filters, limit)
	if err != nil {
		return SqlServerElasticPoolPaginator{}, err
	}

	p := SqlServerElasticPoolPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlServerElasticPoolPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlServerElasticPoolPaginator) NextPage(ctx context.Context) ([]SqlServerElasticPool, error) {
	var response SqlServerElasticPoolSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlServerElasticPool
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlServerElasticPoolFilters = map[string]string{
	"akas":             "description.Pool.ID",
	"creation_date":    "description.Pool.ElasticPoolProperties.CreationDate",
	"database_dtu_max": "description.Pool.ElasticPoolProperties.DatabaseDtuMax",
	"database_dtu_min": "description.Pool.ElasticPoolProperties.DatabaseDtuMin",
	"dtu":              "elasticPoolProperties.Dtu",
	"edition":          "description.Pool.ElasticPoolProperties.Edition",
	"id":               "description.Pool.ID",
	"kaytu_account_id": "metadata.SourceID",
	"kind":             "description.Pool.Kind",
	"name":             "description.Pool.Name",
	"region":           "description.Pool.Location",
	"resource_group":   "description.ResourceGroup",
	"server_name":      "description.ServerName",
	"state":            "description.Pool.ElasticPoolProperties.State",
	"storage_mb":       "description.Pool.ElasticPoolProperties.StorageMB",
	"tags":             "description.Pool.Tags",
	"title":            "description.Pool.Name",
	"type":             "description.Pool.Type",
	"zone_redundant":   "description.Pool.ElasticPoolProperties.ZoneRedundant",
}

func ListSqlServerElasticPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlServerElasticPool")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSqlServerElasticPoolPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSqlServerElasticPoolFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSqlServerElasticPoolFilters = map[string]string{
	"akas":             "description.Pool.ID",
	"creation_date":    "description.Pool.ElasticPoolProperties.CreationDate",
	"database_dtu_max": "description.Pool.ElasticPoolProperties.DatabaseDtuMax",
	"database_dtu_min": "description.Pool.ElasticPoolProperties.DatabaseDtuMin",
	"dtu":              "elasticPoolProperties.Dtu",
	"edition":          "description.Pool.ElasticPoolProperties.Edition",
	"id":               "description.Pool.ID",
	"kaytu_account_id": "metadata.SourceID",
	"kind":             "description.Pool.Kind",
	"name":             "description.Pool.Name",
	"region":           "description.Pool.Location",
	"resource_group":   "description.ResourceGroup",
	"server_name":      "description.ServerName",
	"state":            "description.Pool.ElasticPoolProperties.State",
	"storage_mb":       "description.Pool.ElasticPoolProperties.StorageMB",
	"tags":             "description.Pool.Tags",
	"title":            "description.Pool.Name",
	"type":             "description.Pool.Type",
	"zone_redundant":   "description.Pool.ElasticPoolProperties.ZoneRedundant",
}

func GetSqlServerElasticPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlServerElasticPool")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSqlServerElasticPoolPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSqlServerElasticPoolFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SqlServerElasticPool =============================

// ==========================  START: SqlServerVirtualMachine =============================

type SqlServerVirtualMachine struct {
	Description   azure.SqlServerVirtualMachineDescription `json:"description"`
	Metadata      azure.Metadata                           `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type SqlServerVirtualMachineHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  SqlServerVirtualMachine `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type SqlServerVirtualMachineHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []SqlServerVirtualMachineHit `json:"hits"`
}

type SqlServerVirtualMachineSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  SqlServerVirtualMachineHits `json:"hits"`
}

type SqlServerVirtualMachinePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlServerVirtualMachinePaginator(filters []essdk.BoolFilter, limit *int64) (SqlServerVirtualMachinePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_virtualmachines", filters, limit)
	if err != nil {
		return SqlServerVirtualMachinePaginator{}, err
	}

	p := SqlServerVirtualMachinePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlServerVirtualMachinePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlServerVirtualMachinePaginator) NextPage(ctx context.Context) ([]SqlServerVirtualMachine, error) {
	var response SqlServerVirtualMachineSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlServerVirtualMachine
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlServerVirtualMachineFilters = map[string]string{
	"akas":                          "description.VirtualMachine.ID",
	"auto_backup_settings":          "description.VirtualMachine.Properties.AutoBackupSettings",
	"auto_patching_settings":        "description.VirtualMachine.Properties.AutoPatchingSettings",
	"id":                            "description.VirtualMachine.ID",
	"identity":                      "description.VirtualMachine.Identity",
	"kaytu_account_id":              "metadata.SourceID",
	"key_vault_credential_settings": "description.VirtualMachine.Properties.KeyVaultCredentialSettings",
	"name":                          "description.VirtualMachine.Name",
	"provisioning_state":            "description.VirtualMachine.Properties.ProvisioningState",
	"region":                        "description.VirtualMachine.Location",
	"resource_group":                "description.ResourceGroup",
	"server_configurations_management_settings": "description.VirtualMachine.Properties.ServerConfigurationsManagementSettings",
	"sql_image_offer":                       "description.VirtualMachine.Properties.SQLImageOffer",
	"sql_image_sku":                         "description.VirtualMachine.Properties.SQLImageSku",
	"sql_management":                        "description.VirtualMachine.Properties.SQLManagement",
	"sql_server_license_type":               "description.VirtualMachine.Properties.SQLServerLicenseType",
	"sql_virtual_machine_group_resource_id": "description.VirtualMachine.Properties.SQLVirtualMachineGroupResourceID",
	"storage_configuration_settings":        "description.VirtualMachine.Properties.StorageConfigurationSettings",
	"tags":                                  "description.VirtualMachine.Tags",
	"title":                                 "description.VirtualMachine.Name",
	"type":                                  "description.VirtualMachine.Type",
	"virtual_machine_resource_id":           "description.VirtualMachine.Properties.VirtualMachineResourceID",
	"wsfc_domain_credentials":               "description.VirtualMachine.Properties.WsfcDomainCredentials",
}

func ListSqlServerVirtualMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlServerVirtualMachine")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSqlServerVirtualMachinePaginator(essdk.BuildFilter(d.KeyColumnQuals, listSqlServerVirtualMachineFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSqlServerVirtualMachineFilters = map[string]string{
	"akas":                          "description.VirtualMachine.ID",
	"auto_backup_settings":          "description.VirtualMachine.Properties.AutoBackupSettings",
	"auto_patching_settings":        "description.VirtualMachine.Properties.AutoPatchingSettings",
	"id":                            "description.VirtualMachine.ID",
	"identity":                      "description.VirtualMachine.Identity",
	"kaytu_account_id":              "metadata.SourceID",
	"key_vault_credential_settings": "description.VirtualMachine.Properties.KeyVaultCredentialSettings",
	"name":                          "description.VirtualMachine.Name",
	"provisioning_state":            "description.VirtualMachine.Properties.ProvisioningState",
	"region":                        "description.VirtualMachine.Location",
	"resource_group":                "description.ResourceGroup",
	"server_configurations_management_settings": "description.VirtualMachine.Properties.ServerConfigurationsManagementSettings",
	"sql_image_offer":                       "description.VirtualMachine.Properties.SQLImageOffer",
	"sql_image_sku":                         "description.VirtualMachine.Properties.SQLImageSku",
	"sql_management":                        "description.VirtualMachine.Properties.SQLManagement",
	"sql_server_license_type":               "description.VirtualMachine.Properties.SQLServerLicenseType",
	"sql_virtual_machine_group_resource_id": "description.VirtualMachine.Properties.SQLVirtualMachineGroupResourceID",
	"storage_configuration_settings":        "description.VirtualMachine.Properties.StorageConfigurationSettings",
	"tags":                                  "description.VirtualMachine.Tags",
	"title":                                 "description.VirtualMachine.Name",
	"type":                                  "description.VirtualMachine.Type",
	"virtual_machine_resource_id":           "description.VirtualMachine.Properties.VirtualMachineResourceID",
	"wsfc_domain_credentials":               "description.VirtualMachine.Properties.WsfcDomainCredentials",
}

func GetSqlServerVirtualMachine(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlServerVirtualMachine")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSqlServerVirtualMachinePaginator(essdk.BuildFilter(d.KeyColumnQuals, getSqlServerVirtualMachineFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SqlServerVirtualMachine =============================

// ==========================  START: SqlServerVirtualMachineGroup =============================

type SqlServerVirtualMachineGroup struct {
	Description   azure.SqlServerVirtualMachineGroupDescription `json:"description"`
	Metadata      azure.Metadata                                `json:"metadata"`
	ResourceJobID int                                           `json:"resource_job_id"`
	SourceJobID   int                                           `json:"source_job_id"`
	ResourceType  string                                        `json:"resource_type"`
	SourceType    string                                        `json:"source_type"`
	ID            string                                        `json:"id"`
	ARN           string                                        `json:"arn"`
	SourceID      string                                        `json:"source_id"`
}

type SqlServerVirtualMachineGroupHit struct {
	ID      string                       `json:"_id"`
	Score   float64                      `json:"_score"`
	Index   string                       `json:"_index"`
	Type    string                       `json:"_type"`
	Version int64                        `json:"_version,omitempty"`
	Source  SqlServerVirtualMachineGroup `json:"_source"`
	Sort    []interface{}                `json:"sort"`
}

type SqlServerVirtualMachineGroupHits struct {
	Total essdk.SearchTotal                 `json:"total"`
	Hits  []SqlServerVirtualMachineGroupHit `json:"hits"`
}

type SqlServerVirtualMachineGroupSearchResponse struct {
	PitID string                           `json:"pit_id"`
	Hits  SqlServerVirtualMachineGroupHits `json:"hits"`
}

type SqlServerVirtualMachineGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlServerVirtualMachineGroupPaginator(filters []essdk.BoolFilter, limit *int64) (SqlServerVirtualMachineGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_virtualmachinegroups", filters, limit)
	if err != nil {
		return SqlServerVirtualMachineGroupPaginator{}, err
	}

	p := SqlServerVirtualMachineGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlServerVirtualMachineGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlServerVirtualMachineGroupPaginator) NextPage(ctx context.Context) ([]SqlServerVirtualMachineGroup, error) {
	var response SqlServerVirtualMachineGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlServerVirtualMachineGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlServerVirtualMachineGroupFilters = map[string]string{
	"akas":             "description.VirtualMachineGroups.ID",
	"id":               "description.VirtualMachineGroups.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VirtualMachineGroups.Name",
	"tags":             "description.VirtualMachineGroups.Tags",
	"title":            "description.VirtualMachineGroups.Name",
}

func ListSqlServerVirtualMachineGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlServerVirtualMachineGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSqlServerVirtualMachineGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSqlServerVirtualMachineGroupFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSqlServerVirtualMachineGroupFilters = map[string]string{
	"akas":             "description.VirtualMachineGroups.ID",
	"id":               "description.VirtualMachineGroups.Id",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.VirtualMachineGroups.Name",
	"tags":             "description.VirtualMachineGroups.Tags",
	"title":            "description.VirtualMachineGroups.Name",
}

func GetSqlServerVirtualMachineGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlServerVirtualMachineGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSqlServerVirtualMachineGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSqlServerVirtualMachineGroupFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SqlServerVirtualMachineGroup =============================

// ==========================  START: SqlServerFlexibleServer =============================

type SqlServerFlexibleServer struct {
	Description   azure.SqlServerFlexibleServerDescription `json:"description"`
	Metadata      azure.Metadata                           `json:"metadata"`
	ResourceJobID int                                      `json:"resource_job_id"`
	SourceJobID   int                                      `json:"source_job_id"`
	ResourceType  string                                   `json:"resource_type"`
	SourceType    string                                   `json:"source_type"`
	ID            string                                   `json:"id"`
	ARN           string                                   `json:"arn"`
	SourceID      string                                   `json:"source_id"`
}

type SqlServerFlexibleServerHit struct {
	ID      string                  `json:"_id"`
	Score   float64                 `json:"_score"`
	Index   string                  `json:"_index"`
	Type    string                  `json:"_type"`
	Version int64                   `json:"_version,omitempty"`
	Source  SqlServerFlexibleServer `json:"_source"`
	Sort    []interface{}           `json:"sort"`
}

type SqlServerFlexibleServerHits struct {
	Total essdk.SearchTotal            `json:"total"`
	Hits  []SqlServerFlexibleServerHit `json:"hits"`
}

type SqlServerFlexibleServerSearchResponse struct {
	PitID string                      `json:"pit_id"`
	Hits  SqlServerFlexibleServerHits `json:"hits"`
}

type SqlServerFlexibleServerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewSqlServerFlexibleServerPaginator(filters []essdk.BoolFilter, limit *int64) (SqlServerFlexibleServerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_sql_flexibleservers", filters, limit)
	if err != nil {
		return SqlServerFlexibleServerPaginator{}, err
	}

	p := SqlServerFlexibleServerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p SqlServerFlexibleServerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p SqlServerFlexibleServerPaginator) NextPage(ctx context.Context) ([]SqlServerFlexibleServer, error) {
	var response SqlServerFlexibleServerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []SqlServerFlexibleServer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listSqlServerFlexibleServerFilters = map[string]string{
	"administrator_login":            "description.FlexibleServer.ServerProperties.AdministratorLogin",
	"akas":                           "description.FlexibleServer.ID",
	"availability_zone":              "description.FlexibleServer.ServerProperties.AvailabilityZone",
	"backup_retention_days":          "description.FlexibleServer.ServerProperties.Backup.BackupRetentionDays",
	"create_mode":                    "description.FlexibleServer.ServerProperties.CreateMode",
	"earliest_restore_date":          "description.FlexibleServer.ServerProperties.Backup.EarliestRestoreDate",
	"flexible_server_configurations": "description.FlexibleServer.Location",
	"fully_qualified_domain_name":    "description.FlexibleServer.ServerProperties.FullyQualifiedDomainName",
	"geo_redundant_backup":           "description.FlexibleServer.ServerProperties.Backup.GeoRedundantBackup",
	"high_availability":              "description.FlexibleServer.ServerProperties.HighAvailability",
	"id":                             "description.FlexibleServer.ID",
	"kaytu_account_id":               "metadata.SourceID",
	"location":                       "description.FlexibleServer.Location",
	"maintenance_window":             "description.FlexibleServer.ServerProperties.MaintenanceWindow",
	"name":                           "description.FlexibleServer.Name",
	"network":                        "description.FlexibleServer.ServerProperties.Network",
	"public_network_access":          "description.FlexibleServer.ServerProperties.Network.PublicNetworkAccess",
	"region":                         "description.FlexibleServer.Location",
	"replica_capacity":               "description.FlexibleServer.ServerProperties.ReplicaCapacity",
	"replication_role":               "description.FlexibleServer.ServerProperties.ReplicationRole",
	"resource_group":                 "description.ResourceGroup",
	"restore_point_in_time":          "description.FlexibleServer.ServerProperties.RestorePointInTime",
	"sku_name":                       "description.FlexibleServer.Sku.Name",
	"sku_tier":                       "description.FlexibleServer.Sku.Tier",
	"source_server_resource_id":      "description.FlexibleServer.ServerProperties.SourceServerResourceID",
	"state":                          "description.FlexibleServer.ServerProperties.State",
	"storage_auto_grow":              "description.FlexibleServer.ServerProperties.Storage.AutoGrow",
	"storage_iops":                   "description.FlexibleServer.ServerProperties.Storage.Iops",
	"storage_size_gb":                "description.FlexibleServer.ServerProperties.Storage.StorageSizeGB",
	"storage_sku":                    "description.FlexibleServer.ServerProperties.Storage.StorageSku",
	"system_data":                    "description.FlexibleServer.SystemData",
	"tags":                           "description.FlexibleServer.Tags",
	"title":                          "description.FlexibleServer.Name",
	"type":                           "description.FlexibleServer.Type",
	"version":                        "description.FlexibleServer.ServerProperties.Version",
}

func ListSqlServerFlexibleServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListSqlServerFlexibleServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewSqlServerFlexibleServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listSqlServerFlexibleServerFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getSqlServerFlexibleServerFilters = map[string]string{
	"administrator_login":            "description.FlexibleServer.ServerProperties.AdministratorLogin",
	"akas":                           "description.FlexibleServer.ID",
	"availability_zone":              "description.FlexibleServer.ServerProperties.AvailabilityZone",
	"backup_retention_days":          "description.FlexibleServer.ServerProperties.Backup.BackupRetentionDays",
	"create_mode":                    "description.FlexibleServer.ServerProperties.CreateMode",
	"earliest_restore_date":          "description.FlexibleServer.ServerProperties.Backup.EarliestRestoreDate",
	"flexible_server_configurations": "description.FlexibleServer.Location",
	"fully_qualified_domain_name":    "description.FlexibleServer.ServerProperties.FullyQualifiedDomainName",
	"geo_redundant_backup":           "description.FlexibleServer.ServerProperties.Backup.GeoRedundantBackup",
	"high_availability":              "description.FlexibleServer.ServerProperties.HighAvailability",
	"id":                             "description.FlexibleServer.ID",
	"kaytu_account_id":               "metadata.SourceID",
	"location":                       "description.FlexibleServer.Location",
	"maintenance_window":             "description.FlexibleServer.ServerProperties.MaintenanceWindow",
	"name":                           "description.FlexibleServer.Name",
	"network":                        "description.FlexibleServer.ServerProperties.Network",
	"public_network_access":          "description.FlexibleServer.ServerProperties.Network.PublicNetworkAccess",
	"region":                         "description.FlexibleServer.Location",
	"replica_capacity":               "description.FlexibleServer.ServerProperties.ReplicaCapacity",
	"replication_role":               "description.FlexibleServer.ServerProperties.ReplicationRole",
	"resource_group":                 "description.ResourceGroup",
	"restore_point_in_time":          "description.FlexibleServer.ServerProperties.RestorePointInTime",
	"sku_name":                       "description.FlexibleServer.Sku.Name",
	"sku_tier":                       "description.FlexibleServer.Sku.Tier",
	"source_server_resource_id":      "description.FlexibleServer.ServerProperties.SourceServerResourceID",
	"state":                          "description.FlexibleServer.ServerProperties.State",
	"storage_auto_grow":              "description.FlexibleServer.ServerProperties.Storage.AutoGrow",
	"storage_iops":                   "description.FlexibleServer.ServerProperties.Storage.Iops",
	"storage_size_gb":                "description.FlexibleServer.ServerProperties.Storage.StorageSizeGB",
	"storage_sku":                    "description.FlexibleServer.ServerProperties.Storage.StorageSku",
	"system_data":                    "description.FlexibleServer.SystemData",
	"tags":                           "description.FlexibleServer.Tags",
	"title":                          "description.FlexibleServer.Name",
	"type":                           "description.FlexibleServer.Type",
	"version":                        "description.FlexibleServer.ServerProperties.Version",
}

func GetSqlServerFlexibleServer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetSqlServerFlexibleServer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewSqlServerFlexibleServerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getSqlServerFlexibleServerFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: SqlServerFlexibleServer =============================

// ==========================  START: StorageAccount =============================

type StorageAccount struct {
	Description   azure.StorageAccountDescription `json:"description"`
	Metadata      azure.Metadata                  `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type StorageAccountHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  StorageAccount `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type StorageAccountHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []StorageAccountHit `json:"hits"`
}

type StorageAccountSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  StorageAccountHits `json:"hits"`
}

type StorageAccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewStorageAccountPaginator(filters []essdk.BoolFilter, limit *int64) (StorageAccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_storage_storageaccounts", filters, limit)
	if err != nil {
		return StorageAccountPaginator{}, err
	}

	p := StorageAccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p StorageAccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p StorageAccountPaginator) NextPage(ctx context.Context) ([]StorageAccount, error) {
	var response StorageAccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []StorageAccount
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listStorageAccountFilters = map[string]string{
	"access_tier":                                            "description.Account.AccountProperties.AccessTier",
	"akas":                                                   "description.Account.ID",
	"allow_blob_public_access":                               "description.Account.AccountProperties.AllowBlobPublicAccess",
	"blob_change_feed_enabled":                               "description.BlobServiceProperties.BlobServicePropertiesProperties.ChangeFeed.Enabled",
	"blob_container_soft_delete_enabled":                     "description.BlobServiceProperties.BlobServicePropertiesProperties.ContainerDeleteRetentionPolicy.Enabled",
	"blob_container_soft_delete_retention_days":              "description.BlobServiceProperties.BlobServicePropertiesProperties.ContainerDeleteRetentionPolicy.Days",
	"blob_restore_policy_days":                               "description.BlobServiceProperties.BlobServicePropertiesProperties.RestorePolicy.Days",
	"blob_restore_policy_enabled":                            "description.BlobServiceProperties.BlobServicePropertiesProperties.RestorePolicy.Enabled",
	"blob_service_logging":                                   "description.Logging",
	"blob_soft_delete_enabled":                               "description.BlobServiceProperties.BlobServicePropertiesProperties.DeleteRetentionPolicy.Enabled",
	"blob_soft_delete_retention_days":                        "description.BlobServiceProperties.BlobServicePropertiesProperties.DeleteRetentionPolicy.Days",
	"blob_versioning_enabled":                                "description.BlobServiceProperties.BlobServicePropertiesProperties.IsVersioningEnabled",
	"creation_time":                                          "description.Account.AccountProperties.CreationTime",
	"enable_https_traffic_only":                              "description.Account.AccountProperties.EnableHTTPSTrafficOnly",
	"encryption_key_source":                                  "description.Account.AccountProperties.Encryption.KeySource",
	"encryption_key_vault_properties_key_current_version_id": "description.Account.AccountProperties.Encryption.KeyVaultProperties.CurrentVersionedKeyIdentifier",
	"encryption_key_vault_properties_key_name":               "description.Account.AccountProperties.Encryption.KeyVaultProperties.KeyName",
	"encryption_key_vault_properties_key_vault_uri":          "description.Account.AccountProperties.Encryption.KeyVaultProperties.KeyVaultURI",
	"encryption_key_vault_properties_key_version":            "description.Account.AccountProperties.Encryption.KeyVaultProperties.KeyVersion",
	"encryption_key_vault_properties_last_rotation_time":     "description.Account.AccountProperties.Encryption.KeyVaultProperties.LastKeyRotationTimestamp",
	"encryption_services":                                    "description.Account.AccountProperties.Encryption.Services",
	"failover_in_progress":                                   "description.Account.AccountProperties.FailoverInProgress",
	"file_soft_delete_enabled":                               "description.FileServiceProperties.FileServicePropertiesProperties.ShareDeleteRetentionPolicy.Enabled",
	"file_soft_delete_retention_days":                        "description.FileServiceProperties.FileServicePropertiesProperties.ShareDeleteRetentionPolicy.Days",
	"id":                                                     "description.Account.ID",
	"is_hns_enabled":                                         "description.Account.AccountProperties.IsHnsEnabled",
	"kaytu_account_id":                                       "metadata.SourceID",
	"kind":                                                   "description.Account.Kind",
	"minimum_tls_version":                                    "description.Account.AccountProperties.MinimumTLSVersion",
	"name":                                                   "description.Account.Name",
	"network_ip_rules":                                       "description.Account.AccountProperties.NetworkRuleSet.IPRules",
	"network_rule_bypass":                                    "description.Account.AccountProperties.NetworkRuleSet.Bypass",
	"network_rule_default_action":                            "description.Account.AccountProperties.NetworkRuleSet.DefaultAction",
	"primary_blob_endpoint":                                  "description.Account.AccountProperties.PrimaryEndpoints.Blob",
	"primary_dfs_endpoint":                                   "description.Account.AccountProperties.PrimaryEndpoints.Dfs",
	"primary_file_endpoint":                                  "description.Account.AccountProperties.PrimaryEndpoints.File",
	"primary_location":                                       "description.Account.AccountProperties.PrimaryLocation",
	"primary_queue_endpoint":                                 "description.Account.AccountProperties.PrimaryEndpoints.Queue",
	"primary_table_endpoint":                                 "description.Account.AccountProperties.PrimaryEndpoints.Table",
	"primary_web_endpoint":                                   "description.Account.AccountProperties.PrimaryEndpoints.Web",
	"private_endpoint_connections":                           "description.Account.AccountProperties.PrivateEndpointConnections",
	"provisioning_state":                                     "description.Account.AccountProperties.ProvisioningState",
	"queue_logging_delete":                                   "description.Logging.Delete",
	"queue_logging_read":                                     "description.Logging.Read",
	"queue_logging_retention_days":                           "description.Logging.RetentionPolicy.Days",
	"queue_logging_retention_enabled":                        "description.Logging.RetentionPolicy.Enabled",
	"queue_logging_version":                                  "description.Logging.Version",
	"queue_logging_write":                                    "description.Logging.Write",
	"region":                                                 "description.Account.Location",
	"require_infrastructure_encryption":                      "description.Account.AccountProperties.Encryption.RequireInfrastructureEncryption",
	"resource_group":                                         "description.ResourceGroup",
	"secondary_location":                                     "description.Account.AccountProperties.SecondaryLocation",
	"sku_name":                                               "description.Account.Sku.Name",
	"sku_tier":                                               "description.Account.Sku.Tier",
	"tags":                                                   "description.Account.Tags",
	"title":                                                  "description.Account.Name",
	"type":                                                   "description.Account.Type",
	"virtual_network_rules":                                  "description.Account.AccountProperties.NetworkRuleSet.VirtualNetworkRules",
}

func ListStorageAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListStorageAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewStorageAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, listStorageAccountFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getStorageAccountFilters = map[string]string{
	"access_tier":                                            "description.Account.AccountProperties.AccessTier",
	"akas":                                                   "description.Account.ID",
	"allow_blob_public_access":                               "description.Account.AccountProperties.AllowBlobPublicAccess",
	"blob_change_feed_enabled":                               "description.BlobServiceProperties.BlobServicePropertiesProperties.ChangeFeed.Enabled",
	"blob_container_soft_delete_enabled":                     "description.BlobServiceProperties.BlobServicePropertiesProperties.ContainerDeleteRetentionPolicy.Enabled",
	"blob_container_soft_delete_retention_days":              "description.BlobServiceProperties.BlobServicePropertiesProperties.ContainerDeleteRetentionPolicy.Days",
	"blob_restore_policy_days":                               "description.BlobServiceProperties.BlobServicePropertiesProperties.RestorePolicy.Days",
	"blob_restore_policy_enabled":                            "description.BlobServiceProperties.BlobServicePropertiesProperties.RestorePolicy.Enabled",
	"blob_service_logging":                                   "description.Logging",
	"blob_soft_delete_enabled":                               "description.BlobServiceProperties.BlobServicePropertiesProperties.DeleteRetentionPolicy.Enabled",
	"blob_soft_delete_retention_days":                        "description.BlobServiceProperties.BlobServicePropertiesProperties.DeleteRetentionPolicy.Days",
	"blob_versioning_enabled":                                "description.BlobServiceProperties.BlobServicePropertiesProperties.IsVersioningEnabled",
	"creation_time":                                          "description.Account.AccountProperties.CreationTime",
	"enable_https_traffic_only":                              "description.Account.AccountProperties.EnableHTTPSTrafficOnly",
	"encryption_key_source":                                  "description.Account.AccountProperties.Encryption.KeySource",
	"encryption_key_vault_properties_key_current_version_id": "description.Account.AccountProperties.Encryption.KeyVaultProperties.CurrentVersionedKeyIdentifier",
	"encryption_key_vault_properties_key_name":               "description.Account.AccountProperties.Encryption.KeyVaultProperties.KeyName",
	"encryption_key_vault_properties_key_vault_uri":          "description.Account.AccountProperties.Encryption.KeyVaultProperties.KeyVaultURI",
	"encryption_key_vault_properties_key_version":            "description.Account.AccountProperties.Encryption.KeyVaultProperties.KeyVersion",
	"encryption_key_vault_properties_last_rotation_time":     "description.Account.AccountProperties.Encryption.KeyVaultProperties.LastKeyRotationTimestamp",
	"encryption_services":                                    "description.Account.AccountProperties.Encryption.Services",
	"failover_in_progress":                                   "description.Account.AccountProperties.FailoverInProgress",
	"file_soft_delete_enabled":                               "description.FileServiceProperties.FileServicePropertiesProperties.ShareDeleteRetentionPolicy.Enabled",
	"file_soft_delete_retention_days":                        "description.FileServiceProperties.FileServicePropertiesProperties.ShareDeleteRetentionPolicy.Days",
	"id":                                                     "description.Account.ID",
	"is_hns_enabled":                                         "description.Account.AccountProperties.IsHnsEnabled",
	"kaytu_account_id":                                       "metadata.SourceID",
	"kind":                                                   "description.Account.Kind",
	"minimum_tls_version":                                    "description.Account.AccountProperties.MinimumTLSVersion",
	"name":                                                   "description.Account.name",
	"network_ip_rules":                                       "description.Account.AccountProperties.NetworkRuleSet.IPRules",
	"network_rule_bypass":                                    "description.Account.AccountProperties.NetworkRuleSet.Bypass",
	"network_rule_default_action":                            "description.Account.AccountProperties.NetworkRuleSet.DefaultAction",
	"primary_blob_endpoint":                                  "description.Account.AccountProperties.PrimaryEndpoints.Blob",
	"primary_dfs_endpoint":                                   "description.Account.AccountProperties.PrimaryEndpoints.Dfs",
	"primary_file_endpoint":                                  "description.Account.AccountProperties.PrimaryEndpoints.File",
	"primary_location":                                       "description.Account.AccountProperties.PrimaryLocation",
	"primary_queue_endpoint":                                 "description.Account.AccountProperties.PrimaryEndpoints.Queue",
	"primary_table_endpoint":                                 "description.Account.AccountProperties.PrimaryEndpoints.Table",
	"primary_web_endpoint":                                   "description.Account.AccountProperties.PrimaryEndpoints.Web",
	"private_endpoint_connections":                           "description.Account.AccountProperties.PrivateEndpointConnections",
	"provisioning_state":                                     "description.Account.AccountProperties.ProvisioningState",
	"queue_logging_delete":                                   "description.Logging.Delete",
	"queue_logging_read":                                     "description.Logging.Read",
	"queue_logging_retention_days":                           "description.Logging.RetentionPolicy.Days",
	"queue_logging_retention_enabled":                        "description.Logging.RetentionPolicy.Enabled",
	"queue_logging_version":                                  "description.Logging.Version",
	"queue_logging_write":                                    "description.Logging.Write",
	"region":                                                 "description.Account.Location",
	"require_infrastructure_encryption":                      "description.Account.AccountProperties.Encryption.RequireInfrastructureEncryption",
	"resource_group":                                         "description.ResourceGroup",
	"secondary_location":                                     "description.Account.AccountProperties.SecondaryLocation",
	"sku_name":                                               "description.Account.Sku.Name",
	"sku_tier":                                               "description.Account.Sku.Tier",
	"tags":                                                   "description.Account.Tags",
	"title":                                                  "description.Account.Name",
	"type":                                                   "description.Account.Type",
	"virtual_network_rules":                                  "description.Account.AccountProperties.NetworkRuleSet.VirtualNetworkRules",
}

func GetStorageAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetStorageAccount")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewStorageAccountPaginator(essdk.BuildFilter(d.KeyColumnQuals, getStorageAccountFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: StorageAccount =============================

// ==========================  START: RecoveryServicesVault =============================

type RecoveryServicesVault struct {
	Description   azure.RecoveryServicesVaultDescription `json:"description"`
	Metadata      azure.Metadata                         `json:"metadata"`
	ResourceJobID int                                    `json:"resource_job_id"`
	SourceJobID   int                                    `json:"source_job_id"`
	ResourceType  string                                 `json:"resource_type"`
	SourceType    string                                 `json:"source_type"`
	ID            string                                 `json:"id"`
	ARN           string                                 `json:"arn"`
	SourceID      string                                 `json:"source_id"`
}

type RecoveryServicesVaultHit struct {
	ID      string                `json:"_id"`
	Score   float64               `json:"_score"`
	Index   string                `json:"_index"`
	Type    string                `json:"_type"`
	Version int64                 `json:"_version,omitempty"`
	Source  RecoveryServicesVault `json:"_source"`
	Sort    []interface{}         `json:"sort"`
}

type RecoveryServicesVaultHits struct {
	Total essdk.SearchTotal          `json:"total"`
	Hits  []RecoveryServicesVaultHit `json:"hits"`
}

type RecoveryServicesVaultSearchResponse struct {
	PitID string                    `json:"pit_id"`
	Hits  RecoveryServicesVaultHits `json:"hits"`
}

type RecoveryServicesVaultPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewRecoveryServicesVaultPaginator(filters []essdk.BoolFilter, limit *int64) (RecoveryServicesVaultPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_recoveryservices_vaults", filters, limit)
	if err != nil {
		return RecoveryServicesVaultPaginator{}, err
	}

	p := RecoveryServicesVaultPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p RecoveryServicesVaultPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p RecoveryServicesVaultPaginator) NextPage(ctx context.Context) ([]RecoveryServicesVault, error) {
	var response RecoveryServicesVaultSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []RecoveryServicesVault
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listRecoveryServicesVaultFilters = map[string]string{
	"akas":                              "description.Vault.ID",
	"diagnostic_settings":               "description.Vault.Identity",
	"etag":                              "description.Vault.Etag",
	"identity":                          "description.Vault.Identity",
	"kaytu_account_id":                  "metadata.SourceID",
	"name":                              "description.Vault.Name",
	"private_endpoint_connections":      "description.Vault.Properties.PrivateEndpointConnections",
	"private_endpoint_state_for_backup": "description.Vault.Properties.PrivateEndpointStateForBackup",
	"private_endpoint_state_for_site_recovery": "description.Vault.Properties.PrivateEndpointStateForSiteRecovery",
	"provisioning_state":                       "description.Vault.Properties.ProvisioningState",
	"region":                                   "description.Vault.Location",
	"resource_group":                           "description.ResourceGroup",
	"sku_name":                                 "description.Vault.Sku.Name",
	"tags":                                     "description.Vault.Tags",
	"title":                                    "description.Vault.Name",
	"type":                                     "description.Vault.Type",
	"upgrade_details":                          "description.Vault.Properties.UpgradeDetails",
}

func ListRecoveryServicesVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListRecoveryServicesVault")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewRecoveryServicesVaultPaginator(essdk.BuildFilter(d.KeyColumnQuals, listRecoveryServicesVaultFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getRecoveryServicesVaultFilters = map[string]string{
	"akas":                              "description.Vault.ID",
	"diagnostic_settings":               "description.Vault.Identity",
	"etag":                              "description.Vault.Etag",
	"identity":                          "description.Vault.Identity",
	"kaytu_account_id":                  "metadata.SourceID",
	"name":                              "description.Vault.Name",
	"private_endpoint_connections":      "description.Vault.Properties.PrivateEndpointConnections",
	"private_endpoint_state_for_backup": "description.Vault.Properties.PrivateEndpointStateForBackup",
	"private_endpoint_state_for_site_recovery": "description.Vault.Properties.PrivateEndpointStateForSiteRecovery",
	"provisioning_state":                       "description.Vault.Properties.ProvisioningState",
	"region":                                   "description.Vault.Location",
	"resource_group":                           "description.ResourceGroup",
	"sku_name":                                 "description.Vault.Sku.Name",
	"tags":                                     "description.Vault.Tags",
	"title":                                    "description.Vault.Name",
	"type":                                     "description.Vault.Type",
	"upgrade_details":                          "description.Vault.Properties.UpgradeDetails",
}

func GetRecoveryServicesVault(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetRecoveryServicesVault")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewRecoveryServicesVaultPaginator(essdk.BuildFilter(d.KeyColumnQuals, getRecoveryServicesVaultFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: RecoveryServicesVault =============================

// ==========================  START: HybridKubernetesConnectedCluster =============================

type HybridKubernetesConnectedCluster struct {
	Description   azure.HybridKubernetesConnectedClusterDescription `json:"description"`
	Metadata      azure.Metadata                                    `json:"metadata"`
	ResourceJobID int                                               `json:"resource_job_id"`
	SourceJobID   int                                               `json:"source_job_id"`
	ResourceType  string                                            `json:"resource_type"`
	SourceType    string                                            `json:"source_type"`
	ID            string                                            `json:"id"`
	ARN           string                                            `json:"arn"`
	SourceID      string                                            `json:"source_id"`
}

type HybridKubernetesConnectedClusterHit struct {
	ID      string                           `json:"_id"`
	Score   float64                          `json:"_score"`
	Index   string                           `json:"_index"`
	Type    string                           `json:"_type"`
	Version int64                            `json:"_version,omitempty"`
	Source  HybridKubernetesConnectedCluster `json:"_source"`
	Sort    []interface{}                    `json:"sort"`
}

type HybridKubernetesConnectedClusterHits struct {
	Total essdk.SearchTotal                     `json:"total"`
	Hits  []HybridKubernetesConnectedClusterHit `json:"hits"`
}

type HybridKubernetesConnectedClusterSearchResponse struct {
	PitID string                               `json:"pit_id"`
	Hits  HybridKubernetesConnectedClusterHits `json:"hits"`
}

type HybridKubernetesConnectedClusterPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewHybridKubernetesConnectedClusterPaginator(filters []essdk.BoolFilter, limit *int64) (HybridKubernetesConnectedClusterPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_kubernetes_connectedclusters", filters, limit)
	if err != nil {
		return HybridKubernetesConnectedClusterPaginator{}, err
	}

	p := HybridKubernetesConnectedClusterPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p HybridKubernetesConnectedClusterPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p HybridKubernetesConnectedClusterPaginator) NextPage(ctx context.Context) ([]HybridKubernetesConnectedCluster, error) {
	var response HybridKubernetesConnectedClusterSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []HybridKubernetesConnectedCluster
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listHybridKubernetesConnectedClusterFilters = map[string]string{
	"agent_public_key_certificate": "description.ConnectedCluster.ConnectedClusterProperties.AgentPublicKeyCertificate",
	"agent_version":                "description.ConnectedCluster.ConnectedClusterProperties.AgentVersion",
	"akas":                         "description.ConnectedCluster.ID",
	"connectivity_status":          "description.ConnectedCluster.ConnectedClusterProperties.ConnectivityStatus",
	"created_at":                   "description.ConnectedCluster.SystemData.CreatedAt",
	"created_by":                   "description.ConnectedCluster.SystemData.CreatedBy",
	"created_by_type":              "description.ConnectedCluster.SystemData.CreatedByType",
	"distribution":                 "description.ConnectedCluster.ConnectedClusterProperties.Distribution",
	"extensions":                   "description.ConnectedCluster.Identity",
	"identity":                     "description.ConnectedCluster.Identity",
	"infrastructure":               "description.ConnectedCluster.ConnectedClusterProperties.Infrastructure",
	"kaytu_account_id":             "metadata.SourceID",
	"kubernetes_version":           "description.ConnectedCluster.ConnectedClusterProperties.KubernetesVersion",
	"last_connectivity_time":       "description.ConnectedCluster.ConnectedClusterProperties.LastConnectivityTime",
	"last_modified_at":             "description.ConnectedCluster.SystemData.LastModifiedAt",
	"last_modified_by":             "description.ConnectedCluster.SystemData.LastModifiedBy",
	"last_modified_by_type":        "description.ConnectedCluster.SystemData.LastModifiedByType",
	"location":                     "description.ConnectedCluster.Location",
	"managed_identity_certificate_expiration_time": "description.ConnectedCluster.ConnectedClusterProperties.ManagedIdentityCertificateExpirationTime",
	"name":               "description.ConnectedCluster.Name",
	"offering":           "description.ConnectedCluster.ConnectedClusterProperties.Offering",
	"provisioning_state": "description.ConnectedCluster.ConnectedClusterProperties.ProvisioningState",
	"region":             "description.ConnectedCluster.Location",
	"resource_group":     "description.ResourceGroup",
	"tags":               "description.ConnectedCluster.Tags",
	"title":              "description.ConnectedCluster.Name",
	"total_core_count":   "description.ConnectedCluster.ConnectedClusterProperties.TotalCoreCount",
	"total_node_count":   "description.ConnectedCluster.ConnectedClusterProperties.TotalNodeCount",
	"type":               "description.ConnectedCluster.Type",
}

func ListHybridKubernetesConnectedCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListHybridKubernetesConnectedCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewHybridKubernetesConnectedClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, listHybridKubernetesConnectedClusterFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getHybridKubernetesConnectedClusterFilters = map[string]string{
	"agent_public_key_certificate": "description.ConnectedCluster.ConnectedClusterProperties.AgentPublicKeyCertificate",
	"agent_version":                "description.ConnectedCluster.ConnectedClusterProperties.AgentVersion",
	"akas":                         "description.ConnectedCluster.ID",
	"connectivity_status":          "description.ConnectedCluster.ConnectedClusterProperties.ConnectivityStatus",
	"created_at":                   "description.ConnectedCluster.SystemData.CreatedAt",
	"created_by":                   "description.ConnectedCluster.SystemData.CreatedBy",
	"created_by_type":              "description.ConnectedCluster.SystemData.CreatedByType",
	"distribution":                 "description.ConnectedCluster.ConnectedClusterProperties.Distribution",
	"extensions":                   "description.ConnectedCluster.Identity",
	"identity":                     "description.ConnectedCluster.Identity",
	"infrastructure":               "description.ConnectedCluster.ConnectedClusterProperties.Infrastructure",
	"kaytu_account_id":             "metadata.SourceID",
	"kubernetes_version":           "description.ConnectedCluster.ConnectedClusterProperties.KubernetesVersion",
	"last_connectivity_time":       "description.ConnectedCluster.ConnectedClusterProperties.LastConnectivityTime",
	"last_modified_at":             "description.ConnectedCluster.SystemData.LastModifiedAt",
	"last_modified_by":             "description.ConnectedCluster.SystemData.LastModifiedBy",
	"last_modified_by_type":        "description.ConnectedCluster.SystemData.LastModifiedByType",
	"location":                     "description.ConnectedCluster.Location",
	"managed_identity_certificate_expiration_time": "description.ConnectedCluster.ConnectedClusterProperties.ManagedIdentityCertificateExpirationTime",
	"name":               "description.ConnectedCluster.Name",
	"offering":           "description.ConnectedCluster.ConnectedClusterProperties.Offering",
	"provisioning_state": "description.ConnectedCluster.ConnectedClusterProperties.ProvisioningState",
	"region":             "description.ConnectedCluster.Location",
	"resource_group":     "description.ResourceGroup",
	"tags":               "description.ConnectedCluster.Tags",
	"title":              "description.ConnectedCluster.Name",
	"total_core_count":   "description.ConnectedCluster.ConnectedClusterProperties.TotalCoreCount",
	"total_node_count":   "description.ConnectedCluster.ConnectedClusterProperties.TotalNodeCount",
	"type":               "description.ConnectedCluster.Type",
}

func GetHybridKubernetesConnectedCluster(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetHybridKubernetesConnectedCluster")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewHybridKubernetesConnectedClusterPaginator(essdk.BuildFilter(d.KeyColumnQuals, getHybridKubernetesConnectedClusterFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: HybridKubernetesConnectedCluster =============================

// ==========================  START: CostManagementCostByResourceType =============================

type CostManagementCostByResourceType struct {
	Description   azure.CostManagementCostByResourceTypeDescription `json:"description"`
	Metadata      azure.Metadata                                    `json:"metadata"`
	ResourceJobID int                                               `json:"resource_job_id"`
	SourceJobID   int                                               `json:"source_job_id"`
	ResourceType  string                                            `json:"resource_type"`
	SourceType    string                                            `json:"source_type"`
	ID            string                                            `json:"id"`
	ARN           string                                            `json:"arn"`
	SourceID      string                                            `json:"source_id"`
}

type CostManagementCostByResourceTypeHit struct {
	ID      string                           `json:"_id"`
	Score   float64                          `json:"_score"`
	Index   string                           `json:"_index"`
	Type    string                           `json:"_type"`
	Version int64                            `json:"_version,omitempty"`
	Source  CostManagementCostByResourceType `json:"_source"`
	Sort    []interface{}                    `json:"sort"`
}

type CostManagementCostByResourceTypeHits struct {
	Total essdk.SearchTotal                     `json:"total"`
	Hits  []CostManagementCostByResourceTypeHit `json:"hits"`
}

type CostManagementCostByResourceTypeSearchResponse struct {
	PitID string                               `json:"pit_id"`
	Hits  CostManagementCostByResourceTypeHits `json:"hits"`
}

type CostManagementCostByResourceTypePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostManagementCostByResourceTypePaginator(filters []essdk.BoolFilter, limit *int64) (CostManagementCostByResourceTypePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_costmanagement_costbyresourcetype", filters, limit)
	if err != nil {
		return CostManagementCostByResourceTypePaginator{}, err
	}

	p := CostManagementCostByResourceTypePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostManagementCostByResourceTypePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostManagementCostByResourceTypePaginator) NextPage(ctx context.Context) ([]CostManagementCostByResourceType, error) {
	var response CostManagementCostByResourceTypeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostManagementCostByResourceType
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostManagementCostByResourceTypeFilters = map[string]string{
	"akas":             "iD",
	"id":               "iD",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "iD",
}

func ListCostManagementCostByResourceType(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostManagementCostByResourceType")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCostManagementCostByResourceTypePaginator(essdk.BuildFilter(d.KeyColumnQuals, listCostManagementCostByResourceTypeFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCostManagementCostByResourceTypeFilters = map[string]string{
	"akas":             "iD",
	"id":               "iD",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "iD",
}

func GetCostManagementCostByResourceType(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostManagementCostByResourceType")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCostManagementCostByResourceTypePaginator(essdk.BuildFilter(d.KeyColumnQuals, getCostManagementCostByResourceTypeFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CostManagementCostByResourceType =============================

// ==========================  START: CostManagementCostBySubscription =============================

type CostManagementCostBySubscription struct {
	Description   azure.CostManagementCostBySubscriptionDescription `json:"description"`
	Metadata      azure.Metadata                                    `json:"metadata"`
	ResourceJobID int                                               `json:"resource_job_id"`
	SourceJobID   int                                               `json:"source_job_id"`
	ResourceType  string                                            `json:"resource_type"`
	SourceType    string                                            `json:"source_type"`
	ID            string                                            `json:"id"`
	ARN           string                                            `json:"arn"`
	SourceID      string                                            `json:"source_id"`
}

type CostManagementCostBySubscriptionHit struct {
	ID      string                           `json:"_id"`
	Score   float64                          `json:"_score"`
	Index   string                           `json:"_index"`
	Type    string                           `json:"_type"`
	Version int64                            `json:"_version,omitempty"`
	Source  CostManagementCostBySubscription `json:"_source"`
	Sort    []interface{}                    `json:"sort"`
}

type CostManagementCostBySubscriptionHits struct {
	Total essdk.SearchTotal                     `json:"total"`
	Hits  []CostManagementCostBySubscriptionHit `json:"hits"`
}

type CostManagementCostBySubscriptionSearchResponse struct {
	PitID string                               `json:"pit_id"`
	Hits  CostManagementCostBySubscriptionHits `json:"hits"`
}

type CostManagementCostBySubscriptionPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewCostManagementCostBySubscriptionPaginator(filters []essdk.BoolFilter, limit *int64) (CostManagementCostBySubscriptionPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_costmanagement_costbysubscription", filters, limit)
	if err != nil {
		return CostManagementCostBySubscriptionPaginator{}, err
	}

	p := CostManagementCostBySubscriptionPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p CostManagementCostBySubscriptionPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p CostManagementCostBySubscriptionPaginator) NextPage(ctx context.Context) ([]CostManagementCostBySubscription, error) {
	var response CostManagementCostBySubscriptionSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []CostManagementCostBySubscription
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listCostManagementCostBySubscriptionFilters = map[string]string{
	"akas":             "iD",
	"id":               "iD",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "iD",
}

func ListCostManagementCostBySubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListCostManagementCostBySubscription")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewCostManagementCostBySubscriptionPaginator(essdk.BuildFilter(d.KeyColumnQuals, listCostManagementCostBySubscriptionFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getCostManagementCostBySubscriptionFilters = map[string]string{
	"akas":             "iD",
	"id":               "iD",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "iD",
}

func GetCostManagementCostBySubscription(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetCostManagementCostBySubscription")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewCostManagementCostBySubscriptionPaginator(essdk.BuildFilter(d.KeyColumnQuals, getCostManagementCostBySubscriptionFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: CostManagementCostBySubscription =============================

// ==========================  START: LoadBalancer =============================

type LoadBalancer struct {
	Description   azure.LoadBalancerDescription `json:"description"`
	Metadata      azure.Metadata                `json:"metadata"`
	ResourceJobID int                           `json:"resource_job_id"`
	SourceJobID   int                           `json:"source_job_id"`
	ResourceType  string                        `json:"resource_type"`
	SourceType    string                        `json:"source_type"`
	ID            string                        `json:"id"`
	ARN           string                        `json:"arn"`
	SourceID      string                        `json:"source_id"`
}

type LoadBalancerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  LoadBalancer  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LoadBalancerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LoadBalancerHit `json:"hits"`
}

type LoadBalancerSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  LoadBalancerHits `json:"hits"`
}

type LoadBalancerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerPaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_network_loadbalancers", filters, limit)
	if err != nil {
		return LoadBalancerPaginator{}, err
	}

	p := LoadBalancerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerPaginator) NextPage(ctx context.Context) ([]LoadBalancer, error) {
	var response LoadBalancerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerFilters = map[string]string{
	"akas":                       "description.LoadBalancer.ID",
	"backend_address_pools":      "description.LoadBalancer.LoadBalancerPropertiesFormat.BackendAddressPools",
	"diagnostic_settings":        "description.DiagnosticSetting",
	"etag":                       "description.LoadBalancer.Etag",
	"extended_location_name":     "description.LoadBalancer.ExtendedLocation.Name",
	"extended_location_type":     "description.LoadBalancer.ExtendedLocation.Type",
	"frontend_ip_configurations": "description.LoadBalancer.LoadBalancerPropertiesFormat.FrontendIPConfigurations",
	"id":                         "description.LoadBalancer.ID",
	"inbound_nat_pools":          "description.LoadBalancer.LoadBalancerPropertiesFormat.InboundNatPools",
	"inbound_nat_rules":          "description.LoadBalancer.LoadBalancerPropertiesFormat.InboundNatRules",
	"kaytu_account_id":           "metadata.SourceID",
	"load_balancing_rules":       "description.LoadBalancer.LoadBalancerPropertiesFormat.LoadBalancingRules",
	"name":                       "description.LoadBalancer.Name",
	"outbound_rules":             "description.LoadBalancer.LoadBalancerPropertiesFormat.OutboundRules",
	"probes":                     "description.LoadBalancer.LoadBalancerPropertiesFormat.Probes",
	"provisioning_state":         "description.LoadBalancer.LoadBalancerPropertiesFormat.ProvisioningState",
	"region":                     "description.LoadBalancer.Location",
	"resource_group":             "description.ResourceGroup",
	"resource_guid":              "description.LoadBalancer.LoadBalancerPropertiesFormat.ResourceGUID",
	"sku_name":                   "description.LoadBalancer.Sku.Name",
	"sku_tier":                   "description.LoadBalancer.Sku.Tier",
	"tags":                       "description.LoadBalancer.Tags",
	"title":                      "description.LoadBalancer.Name",
	"type":                       "description.LoadBalancer.Type",
}

func ListLoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLoadBalancerPaginator(essdk.BuildFilter(d.KeyColumnQuals, listLoadBalancerFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLoadBalancerFilters = map[string]string{
	"akas":                       "description.LoadBalancer.ID",
	"backend_address_pools":      "description.LoadBalancer.LoadBalancerPropertiesFormat.BackendAddressPools",
	"diagnostic_settings":        "description.DiagnosticSetting",
	"etag":                       "description.LoadBalancer.Etag",
	"extended_location_name":     "description.LoadBalancer.ExtendedLocation.Name",
	"extended_location_type":     "description.LoadBalancer.ExtendedLocation.Type",
	"frontend_ip_configurations": "description.LoadBalancer.LoadBalancerPropertiesFormat.FrontendIPConfigurations",
	"id":                         "description.LoadBalancer.ID",
	"inbound_nat_pools":          "description.LoadBalancer.LoadBalancerPropertiesFormat.InboundNatPools",
	"inbound_nat_rules":          "description.LoadBalancer.LoadBalancerPropertiesFormat.InboundNatRules",
	"kaytu_account_id":           "metadata.SourceID",
	"load_balancing_rules":       "description.LoadBalancer.LoadBalancerPropertiesFormat.LoadBalancingRules",
	"name":                       "description.LoadBalancer.Name",
	"outbound_rules":             "description.LoadBalancer.LoadBalancerPropertiesFormat.OutboundRules",
	"probes":                     "description.LoadBalancer.LoadBalancerPropertiesFormat.Probes",
	"provisioning_state":         "description.LoadBalancer.LoadBalancerPropertiesFormat.ProvisioningState",
	"region":                     "description.LoadBalancer.Location",
	"resource_group":             "description.ResourceGroup",
	"resource_guid":              "description.LoadBalancer.LoadBalancerPropertiesFormat.ResourceGUID",
	"sku_name":                   "description.LoadBalancer.Sku.Name",
	"sku_tier":                   "description.LoadBalancer.Sku.Tier",
	"tags":                       "description.LoadBalancer.Tags",
	"title":                      "description.LoadBalancer.Name",
	"type":                       "description.LoadBalancer.Type",
}

func GetLoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancer")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerPaginator(essdk.BuildFilter(d.KeyColumnQuals, getLoadBalancerFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LoadBalancer =============================

// ==========================  START: LoadBalancerBackendAddressPool =============================

type LoadBalancerBackendAddressPool struct {
	Description   azure.LoadBalancerBackendAddressPoolDescription `json:"description"`
	Metadata      azure.Metadata                                  `json:"metadata"`
	ResourceJobID int                                             `json:"resource_job_id"`
	SourceJobID   int                                             `json:"source_job_id"`
	ResourceType  string                                          `json:"resource_type"`
	SourceType    string                                          `json:"source_type"`
	ID            string                                          `json:"id"`
	ARN           string                                          `json:"arn"`
	SourceID      string                                          `json:"source_id"`
}

type LoadBalancerBackendAddressPoolHit struct {
	ID      string                         `json:"_id"`
	Score   float64                        `json:"_score"`
	Index   string                         `json:"_index"`
	Type    string                         `json:"_type"`
	Version int64                          `json:"_version,omitempty"`
	Source  LoadBalancerBackendAddressPool `json:"_source"`
	Sort    []interface{}                  `json:"sort"`
}

type LoadBalancerBackendAddressPoolHits struct {
	Total essdk.SearchTotal                   `json:"total"`
	Hits  []LoadBalancerBackendAddressPoolHit `json:"hits"`
}

type LoadBalancerBackendAddressPoolSearchResponse struct {
	PitID string                             `json:"pit_id"`
	Hits  LoadBalancerBackendAddressPoolHits `json:"hits"`
}

type LoadBalancerBackendAddressPoolPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerBackendAddressPoolPaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerBackendAddressPoolPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_loadbalancer_backendaddresspools", filters, limit)
	if err != nil {
		return LoadBalancerBackendAddressPoolPaginator{}, err
	}

	p := LoadBalancerBackendAddressPoolPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerBackendAddressPoolPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerBackendAddressPoolPaginator) NextPage(ctx context.Context) ([]LoadBalancerBackendAddressPool, error) {
	var response LoadBalancerBackendAddressPoolSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancerBackendAddressPool
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerBackendAddressPoolFilters = map[string]string{
	"akas":                                   "description.Pool.ID",
	"backend_ip_configurations":              "description.Pool.BackendAddressPoolPropertiesFormat.BackendIPConfigurations",
	"etag":                                   "description.Pool.Etag",
	"gateway_load_balancer_tunnel_interface": "description.Pool.BackendAddressPoolPropertiesFormat.TunnelInterfaces",
	"id":                                     "description.Pool.ID",
	"kaytu_account_id":                       "metadata.SourceID",
	"load_balancer_backend_addresses":        "description.Pool.BackendAddressPoolPropertiesFormat.LoadBalancerBackendAddresses",
	"load_balancer_name":                     "description.LoadBalancerName",
	"load_balancing_rules":                   "description.Pool.BackendAddressPoolPropertiesFormat.LoadBalancingRules",
	"name":                                   "description.Pool.Name",
	"outbound_rule_id":                       "description.Pool.BackendAddressPoolPropertiesFormat.OutboundRule.ID",
	"outbound_rules":                         "description.Pool.BackendAddressPoolPropertiesFormat.OutboundRules",
	"provisioning_state":                     "description.Pool.BackendAddressPoolPropertiesFormat.ProvisioningState",
	"resource_group":                         "description.ResourceGroup",
	"title":                                  "description.Pool.Name",
	"type":                                   "description.Pool.Type",
}

func ListLoadBalancerBackendAddressPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancerBackendAddressPool")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLoadBalancerBackendAddressPoolPaginator(essdk.BuildFilter(d.KeyColumnQuals, listLoadBalancerBackendAddressPoolFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLoadBalancerBackendAddressPoolFilters = map[string]string{
	"akas":                                   "description.Pool.ID",
	"backend_ip_configurations":              "description.Pool.BackendAddressPoolPropertiesFormat.BackendIPConfigurations",
	"etag":                                   "description.Pool.Etag",
	"gateway_load_balancer_tunnel_interface": "description.Pool.BackendAddressPoolPropertiesFormat.TunnelInterfaces",
	"id":                                     "description.Pool.ID",
	"kaytu_account_id":                       "metadata.SourceID",
	"load_balancer_backend_addresses":        "description.Pool.BackendAddressPoolPropertiesFormat.LoadBalancerBackendAddresses",
	"load_balancer_name":                     "description.LoadBalancer.Name",
	"load_balancing_rules":                   "description.Pool.BackendAddressPoolPropertiesFormat.LoadBalancingRules",
	"name":                                   "description.Pool.Name",
	"outbound_rule_id":                       "description.Pool.BackendAddressPoolPropertiesFormat.OutboundRule.ID",
	"outbound_rules":                         "description.Pool.BackendAddressPoolPropertiesFormat.OutboundRules",
	"provisioning_state":                     "description.Pool.BackendAddressPoolPropertiesFormat.ProvisioningState",
	"resource_group":                         "description.ResourceGroup",
	"title":                                  "description.Pool.Name",
	"type":                                   "description.Pool.Type",
}

func GetLoadBalancerBackendAddressPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancerBackendAddressPool")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerBackendAddressPoolPaginator(essdk.BuildFilter(d.KeyColumnQuals, getLoadBalancerBackendAddressPoolFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LoadBalancerBackendAddressPool =============================

// ==========================  START: LoadBalancerNatRule =============================

type LoadBalancerNatRule struct {
	Description   azure.LoadBalancerNatRuleDescription `json:"description"`
	Metadata      azure.Metadata                       `json:"metadata"`
	ResourceJobID int                                  `json:"resource_job_id"`
	SourceJobID   int                                  `json:"source_job_id"`
	ResourceType  string                               `json:"resource_type"`
	SourceType    string                               `json:"source_type"`
	ID            string                               `json:"id"`
	ARN           string                               `json:"arn"`
	SourceID      string                               `json:"source_id"`
}

type LoadBalancerNatRuleHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  LoadBalancerNatRule `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type LoadBalancerNatRuleHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []LoadBalancerNatRuleHit `json:"hits"`
}

type LoadBalancerNatRuleSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  LoadBalancerNatRuleHits `json:"hits"`
}

type LoadBalancerNatRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerNatRulePaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerNatRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_loadbalancer_natrules", filters, limit)
	if err != nil {
		return LoadBalancerNatRulePaginator{}, err
	}

	p := LoadBalancerNatRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerNatRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerNatRulePaginator) NextPage(ctx context.Context) ([]LoadBalancerNatRule, error) {
	var response LoadBalancerNatRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancerNatRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerNatRuleFilters = map[string]string{
	"akas":                      "description.Rule.ID",
	"backend_ip_configuration":  "description.Rule.InboundNatRulePropertiesFormat.BackendIPConfiguration",
	"backend_port":              "description.Rule.InboundNatRulePropertiesFormat.BackendPort",
	"enable_floating_ip":        "description.Rule.InboundNatRulePropertiesFormat.EnableFloatingIP",
	"enable_tcp_reset":          "description.Rule.InboundNatRulePropertiesFormat.EnableTCPReset",
	"etag":                      "description.Rule.Etag",
	"frontend_ip_configuration": "description.Rule.InboundNatRulePropertiesFormat.FrontendIPConfiguration",
	"frontend_port":             "description.Rule.InboundNatRulePropertiesFormat.FrontendPort",
	"id":                        "description.Rule.ID",
	"idle_timeout_in_minutes":   "description.Rule.InboundNatRulePropertiesFormat.IdleTimeoutInMinutes",
	"kaytu_account_id":          "metadata.SourceID",
	"load_balancer_name":        "description.LoadBalancerName",
	"name":                      "description.Rule.Name",
	"protocol":                  "description.Rule.InboundNatRulePropertiesFormat.Protocol",
	"provisioning_state":        "description.Rule.InboundNatRulePropertiesFormat.ProvisioningState",
	"resource_group":            "description.ResourceGroup",
	"title":                     "description.Rule.Name",
	"type":                      "description.Rule.Type",
}

func ListLoadBalancerNatRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancerNatRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLoadBalancerNatRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, listLoadBalancerNatRuleFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLoadBalancerNatRuleFilters = map[string]string{
	"akas":                      "description.Rule.ID",
	"backend_ip_configuration":  "description.Rule.InboundNatRulePropertiesFormat.BackendIPConfiguration",
	"backend_port":              "description.Rule.InboundNatRulePropertiesFormat.BackendPort",
	"enable_floating_ip":        "description.Rule.InboundNatRulePropertiesFormat.EnableFloatingIP",
	"enable_tcp_reset":          "description.Rule.InboundNatRulePropertiesFormat.EnableTCPReset",
	"etag":                      "description.Rule.Etag",
	"frontend_ip_configuration": "description.Rule.InboundNatRulePropertiesFormat.FrontendIPConfiguration",
	"frontend_port":             "description.Rule.InboundNatRulePropertiesFormat.FrontendPort",
	"id":                        "description.Rule.ID",
	"idle_timeout_in_minutes":   "description.Rule.InboundNatRulePropertiesFormat.IdleTimeoutInMinutes",
	"kaytu_account_id":          "metadata.SourceID",
	"load_balancer_name":        "description.LoadBalancerName",
	"name":                      "description.Rule.Name",
	"protocol":                  "description.Rule.InboundNatRulePropertiesFormat.Protocol",
	"provisioning_state":        "description.Rule.InboundNatRulePropertiesFormat.ProvisioningState",
	"resource_group":            "description.ResourceGroup",
	"title":                     "description.Rule.Name",
	"type":                      "description.Rule.Type",
}

func GetLoadBalancerNatRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancerNatRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerNatRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, getLoadBalancerNatRuleFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LoadBalancerNatRule =============================

// ==========================  START: LoadBalancerOutboundRule =============================

type LoadBalancerOutboundRule struct {
	Description   azure.LoadBalancerOutboundRuleDescription `json:"description"`
	Metadata      azure.Metadata                            `json:"metadata"`
	ResourceJobID int                                       `json:"resource_job_id"`
	SourceJobID   int                                       `json:"source_job_id"`
	ResourceType  string                                    `json:"resource_type"`
	SourceType    string                                    `json:"source_type"`
	ID            string                                    `json:"id"`
	ARN           string                                    `json:"arn"`
	SourceID      string                                    `json:"source_id"`
}

type LoadBalancerOutboundRuleHit struct {
	ID      string                   `json:"_id"`
	Score   float64                  `json:"_score"`
	Index   string                   `json:"_index"`
	Type    string                   `json:"_type"`
	Version int64                    `json:"_version,omitempty"`
	Source  LoadBalancerOutboundRule `json:"_source"`
	Sort    []interface{}            `json:"sort"`
}

type LoadBalancerOutboundRuleHits struct {
	Total essdk.SearchTotal             `json:"total"`
	Hits  []LoadBalancerOutboundRuleHit `json:"hits"`
}

type LoadBalancerOutboundRuleSearchResponse struct {
	PitID string                       `json:"pit_id"`
	Hits  LoadBalancerOutboundRuleHits `json:"hits"`
}

type LoadBalancerOutboundRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerOutboundRulePaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerOutboundRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_loadbalancer_outboundrules", filters, limit)
	if err != nil {
		return LoadBalancerOutboundRulePaginator{}, err
	}

	p := LoadBalancerOutboundRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerOutboundRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerOutboundRulePaginator) NextPage(ctx context.Context) ([]LoadBalancerOutboundRule, error) {
	var response LoadBalancerOutboundRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancerOutboundRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerOutboundRuleFilters = map[string]string{
	"akas":                       "description.Rule.ID",
	"allocated_outbound_ports":   "description.Rule.OutboundRulePropertiesFormat.AllocatedOutboundPorts",
	"backend_address_pools":      "description.Rule.OutboundRulePropertiesFormat.BackendAddressPool",
	"enable_tcp_reset":           "description.Rule.OutboundRulePropertiesFormat.EnableTCPReset",
	"etag":                       "description.Rule.Etag",
	"frontend_ip_configurations": "description.Rule.OutboundRulePropertiesFormat.FrontendIPConfigurations",
	"id":                         "description.Rule.ID",
	"idle_timeout_in_minutes":    "description.Rule.OutboundRulePropertiesFormat.IdleTimeoutInMinutes",
	"kaytu_account_id":           "metadata.SourceID",
	"load_balancer_name":         "description.LoadBalancerName",
	"name":                       "description.Rule.Name",
	"protocol":                   "description.Rule.OutboundRulePropertiesFormat.Protocol",
	"provisioning_state":         "description.Rule.OutboundRulePropertiesFormat.ProvisioningState",
	"resource_group":             "description.ResourceGroup",
	"title":                      "description.Rule.Name",
	"type":                       "description.Rule.Type",
}

func ListLoadBalancerOutboundRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancerOutboundRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLoadBalancerOutboundRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, listLoadBalancerOutboundRuleFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLoadBalancerOutboundRuleFilters = map[string]string{
	"akas":                       "description.Rule.ID",
	"allocated_outbound_ports":   "description.Rule.OutboundRulePropertiesFormat.AllocatedOutboundPorts",
	"backend_address_pools":      "description.Rule.OutboundRulePropertiesFormat.BackendAddressPool",
	"enable_tcp_reset":           "description.Rule.OutboundRulePropertiesFormat.EnableTCPReset",
	"etag":                       "description.Rule.Etag",
	"frontend_ip_configurations": "description.Rule.OutboundRulePropertiesFormat.FrontendIPConfigurations",
	"id":                         "description.Rule.ID",
	"idle_timeout_in_minutes":    "description.Rule.OutboundRulePropertiesFormat.IdleTimeoutInMinutes",
	"kaytu_account_id":           "metadata.SourceID",
	"load_balancer_name":         "description.LoadBalancerName",
	"name":                       "description.Rule.Name",
	"protocol":                   "description.Rule.OutboundRulePropertiesFormat.Protocol",
	"provisioning_state":         "description.Rule.OutboundRulePropertiesFormat.ProvisioningState",
	"resource_group":             "description.ResourceGroup",
	"title":                      "description.Rule.Name",
	"type":                       "description.Rule.Type",
}

func GetLoadBalancerOutboundRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancerOutboundRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerOutboundRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, getLoadBalancerOutboundRuleFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LoadBalancerOutboundRule =============================

// ==========================  START: LoadBalancerProbe =============================

type LoadBalancerProbe struct {
	Description   azure.LoadBalancerProbeDescription `json:"description"`
	Metadata      azure.Metadata                     `json:"metadata"`
	ResourceJobID int                                `json:"resource_job_id"`
	SourceJobID   int                                `json:"source_job_id"`
	ResourceType  string                             `json:"resource_type"`
	SourceType    string                             `json:"source_type"`
	ID            string                             `json:"id"`
	ARN           string                             `json:"arn"`
	SourceID      string                             `json:"source_id"`
}

type LoadBalancerProbeHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  LoadBalancerProbe `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type LoadBalancerProbeHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []LoadBalancerProbeHit `json:"hits"`
}

type LoadBalancerProbeSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  LoadBalancerProbeHits `json:"hits"`
}

type LoadBalancerProbePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerProbePaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerProbePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_loadbalancer_probes", filters, limit)
	if err != nil {
		return LoadBalancerProbePaginator{}, err
	}

	p := LoadBalancerProbePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerProbePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerProbePaginator) NextPage(ctx context.Context) ([]LoadBalancerProbe, error) {
	var response LoadBalancerProbeSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancerProbe
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerProbeFilters = map[string]string{
	"akas":                 "description.Probe.ID",
	"etag":                 "description.Probe.Etag",
	"id":                   "description.Probe.ID",
	"interval_in_seconds":  "description.Probe.ProbePropertiesFormat.IntervalInSeconds",
	"kaytu_account_id":     "metadata.SourceID",
	"load_balancer_name":   "description.LoadBalancerName",
	"load_balancing_rules": "description.Probe.ProbePropertiesFormat.LoadBalancingRules",
	"name":                 "description.Probe.Name",
	"number_of_probes":     "description.Probe.ProbePropertiesFormat.NumberOfProbes",
	"port":                 "description.Probe.ProbePropertiesFormat.Port",
	"protocol":             "description.Probe.ProbePropertiesFormat.Protocol",
	"provisioning_state":   "description.Probe.ProbePropertiesFormat.ProvisioningState",
	"request_path":         "description.Probe.ProbePropertiesFormat.RequestPath",
	"resource_group":       "description.ResourceGroup",
	"title":                "description.Probe.Name",
	"type":                 "description.Probe.Type",
}

func ListLoadBalancerProbe(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancerProbe")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLoadBalancerProbePaginator(essdk.BuildFilter(d.KeyColumnQuals, listLoadBalancerProbeFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLoadBalancerProbeFilters = map[string]string{
	"akas":                 "description.Probe.ID",
	"etag":                 "description.Probe.Etag",
	"id":                   "description.Probe.ID",
	"interval_in_seconds":  "description.Probe.ProbePropertiesFormat.IntervalInSeconds",
	"kaytu_account_id":     "metadata.SourceID",
	"load_balancer_name":   "description.LoadBalancerName",
	"load_balancing_rules": "description.Probe.ProbePropertiesFormat.LoadBalancingRules",
	"name":                 "description.Probe.Name",
	"number_of_probes":     "description.Probe.ProbePropertiesFormat.NumberOfProbes",
	"port":                 "description.Probe.ProbePropertiesFormat.Port",
	"protocol":             "description.Probe.ProbePropertiesFormat.Protocol",
	"provisioning_state":   "description.Probe.ProbePropertiesFormat.ProvisioningState",
	"request_path":         "description.Probe.ProbePropertiesFormat.RequestPath",
	"resource_group":       "description.ResourceGroup",
	"title":                "description.Probe.Name",
	"type":                 "description.Probe.Type",
}

func GetLoadBalancerProbe(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancerProbe")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerProbePaginator(essdk.BuildFilter(d.KeyColumnQuals, getLoadBalancerProbeFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LoadBalancerProbe =============================

// ==========================  START: LoadBalancerRule =============================

type LoadBalancerRule struct {
	Description   azure.LoadBalancerRuleDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type LoadBalancerRuleHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  LoadBalancerRule `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type LoadBalancerRuleHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []LoadBalancerRuleHit `json:"hits"`
}

type LoadBalancerRuleSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  LoadBalancerRuleHits `json:"hits"`
}

type LoadBalancerRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerRulePaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_loadbalancer_rules", filters, limit)
	if err != nil {
		return LoadBalancerRulePaginator{}, err
	}

	p := LoadBalancerRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerRulePaginator) NextPage(ctx context.Context) ([]LoadBalancerRule, error) {
	var response LoadBalancerRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancerRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerRuleFilters = map[string]string{
	"akas":                         "description.Rule.ID",
	"backend_address_pool_id":      "description.Rule.LoadBalancingRulePropertiesFormat.BackendAddressPool.ID",
	"backend_address_pools":        "description.Rule.LoadBalancingRulePropertiesFormat.BackendAddressPools",
	"backend_port":                 "description.Rule.LoadBalancingRulePropertiesFormat.BackendPort",
	"disable_outbound_snat":        "description.Rule.LoadBalancingRulePropertiesFormat.DisableOutboundSnat",
	"enable_floating_ip":           "description.Rule.LoadBalancingRulePropertiesFormat.EnableFloatingIP",
	"enable_tcp_reset":             "description.Rule.LoadBalancingRulePropertiesFormat.EnableTCPReset",
	"etag":                         "description.Rule.Etag",
	"frontend_ip_configuration_id": "description.Rule.LoadBalancingRulePropertiesFormat.FrontendIPConfiguration.ID",
	"frontend_port":                "description.Rule.LoadBalancingRulePropertiesFormat.FrontendPort",
	"id":                           "description.Rule.ID",
	"idle_timeout_in_minutes":      "description.Rule.LoadBalancingRulePropertiesFormat.IdleTimeoutInMinutes",
	"kaytu_account_id":             "metadata.SourceID",
	"load_balancer_name":           "description.LoadBalancerName",
	"load_distribution":            "description.Rule.LoadBalancingRulePropertiesFormat.LoadDistribution",
	"name":                         "description.Rule.Name",
	"probe_id":                     "description.Rule.LoadBalancingRulePropertiesFormat.Probe.ID",
	"protocol":                     "description.Rule.LoadBalancingRulePropertiesFormat.Protocol",
	"provisioning_state":           "description.Rule.LoadBalancingRulePropertiesFormat.ProvisioningState",
	"resource_group":               "description.ResourceGroup",
	"title":                        "description.Rule.Name",
	"type":                         "description.Rule.Type",
}

func ListLoadBalancerRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancerRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewLoadBalancerRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, listLoadBalancerRuleFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getLoadBalancerRuleFilters = map[string]string{
	"akas":                         "description.Rule.ID",
	"backend_address_pool_id":      "description.Rule.LoadBalancingRulePropertiesFormat.BackendAddressPool.ID",
	"backend_address_pools":        "description.Rule.LoadBalancingRulePropertiesFormat.BackendAddressPools",
	"backend_port":                 "description.Rule.LoadBalancingRulePropertiesFormat.BackendPort",
	"disable_outbound_snat":        "description.Rule.LoadBalancingRulePropertiesFormat.DisableOutboundSnat",
	"enable_floating_ip":           "description.Rule.LoadBalancingRulePropertiesFormat.EnableFloatingIP",
	"enable_tcp_reset":             "description.Rule.LoadBalancingRulePropertiesFormat.EnableTCPReset",
	"etag":                         "description.Rule.Etag",
	"frontend_ip_configuration_id": "description.Rule.LoadBalancingRulePropertiesFormat.FrontendIPConfiguration.ID",
	"frontend_port":                "description.Rule.LoadBalancingRulePropertiesFormat.FrontendPort",
	"id":                           "description.Rule.ID",
	"idle_timeout_in_minutes":      "description.Rule.LoadBalancingRulePropertiesFormat.IdleTimeoutInMinutes",
	"kaytu_account_id":             "metadata.SourceID",
	"load_balancer_name":           "description.LoadBalancerName",
	"load_distribution":            "description.Rule.LoadBalancingRulePropertiesFormat.LoadDistribution",
	"name":                         "description.Rule.Name",
	"probe_id":                     "description.Rule.LoadBalancingRulePropertiesFormat.Probe.ID",
	"protocol":                     "description.Rule.LoadBalancingRulePropertiesFormat.Protocol",
	"provisioning_state":           "description.Rule.LoadBalancingRulePropertiesFormat.ProvisioningState",
	"resource_group":               "description.ResourceGroup",
	"title":                        "description.Rule.Name",
	"type":                         "description.Rule.Type",
}

func GetLoadBalancerRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancerRule")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerRulePaginator(essdk.BuildFilter(d.KeyColumnQuals, getLoadBalancerRuleFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: LoadBalancerRule =============================

// ==========================  START: ManagementGroup =============================

type ManagementGroup struct {
	Description   azure.ManagementGroupDescription `json:"description"`
	Metadata      azure.Metadata                   `json:"metadata"`
	ResourceJobID int                              `json:"resource_job_id"`
	SourceJobID   int                              `json:"source_job_id"`
	ResourceType  string                           `json:"resource_type"`
	SourceType    string                           `json:"source_type"`
	ID            string                           `json:"id"`
	ARN           string                           `json:"arn"`
	SourceID      string                           `json:"source_id"`
}

type ManagementGroupHit struct {
	ID      string          `json:"_id"`
	Score   float64         `json:"_score"`
	Index   string          `json:"_index"`
	Type    string          `json:"_type"`
	Version int64           `json:"_version,omitempty"`
	Source  ManagementGroup `json:"_source"`
	Sort    []interface{}   `json:"sort"`
}

type ManagementGroupHits struct {
	Total essdk.SearchTotal    `json:"total"`
	Hits  []ManagementGroupHit `json:"hits"`
}

type ManagementGroupSearchResponse struct {
	PitID string              `json:"pit_id"`
	Hits  ManagementGroupHits `json:"hits"`
}

type ManagementGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewManagementGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ManagementGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_management_groups", filters, limit)
	if err != nil {
		return ManagementGroupPaginator{}, err
	}

	p := ManagementGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ManagementGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ManagementGroupPaginator) NextPage(ctx context.Context) ([]ManagementGroup, error) {
	var response ManagementGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ManagementGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listManagementGroupFilters = map[string]string{
	"akas":             "description.Group.ID",
	"children":         "description.Group.Properties.Children",
	"display_name":     "description.Group.Properties.DisplayName",
	"id":               "description.Group.ID",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Group.Name",
	"parent":           "description.Group.Properties.Details.Parent",
	"tenant_id":        "description.Group.Properties.TenantID",
	"title":            "description.Group.Name",
	"type":             "description.Group.Type",
	"updated_by":       "description.Group.Properties.Details.UpdatedBy",
	"updated_time":     "description.Group.Properties.Details.UpdatedTime.Time",
	"version":          "description.Group.Properties.Details.Version",
}

func ListManagementGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListManagementGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewManagementGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listManagementGroupFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getManagementGroupFilters = map[string]string{
	"akas":             "description.Group.ID",
	"children":         "description.Group.Properties.Children",
	"display_name":     "description.Group.Properties.DisplayName",
	"id":               "description.Group.ID",
	"kaytu_account_id": "metadata.SourceID",
	"name":             "description.Group.Name",
	"parent":           "description.Group.Properties.Details.Parent",
	"tenant_id":        "description.Group.Properties.TenantID",
	"title":            "description.Group.Name",
	"type":             "description.Group.Type",
	"updated_by":       "description.Group.Properties.Details.UpdatedBy",
	"updated_time":     "description.Group.Properties.Details.UpdatedTime.Time",
	"version":          "description.Group.Properties.Details.Version",
}

func GetManagementGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetManagementGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewManagementGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getManagementGroupFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ManagementGroup =============================

// ==========================  START: ManagementLock =============================

type ManagementLock struct {
	Description   azure.ManagementLockDescription `json:"description"`
	Metadata      azure.Metadata                  `json:"metadata"`
	ResourceJobID int                             `json:"resource_job_id"`
	SourceJobID   int                             `json:"source_job_id"`
	ResourceType  string                          `json:"resource_type"`
	SourceType    string                          `json:"source_type"`
	ID            string                          `json:"id"`
	ARN           string                          `json:"arn"`
	SourceID      string                          `json:"source_id"`
}

type ManagementLockHit struct {
	ID      string         `json:"_id"`
	Score   float64        `json:"_score"`
	Index   string         `json:"_index"`
	Type    string         `json:"_type"`
	Version int64          `json:"_version,omitempty"`
	Source  ManagementLock `json:"_source"`
	Sort    []interface{}  `json:"sort"`
}

type ManagementLockHits struct {
	Total essdk.SearchTotal   `json:"total"`
	Hits  []ManagementLockHit `json:"hits"`
}

type ManagementLockSearchResponse struct {
	PitID string             `json:"pit_id"`
	Hits  ManagementLockHits `json:"hits"`
}

type ManagementLockPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewManagementLockPaginator(filters []essdk.BoolFilter, limit *int64) (ManagementLockPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_management_locks", filters, limit)
	if err != nil {
		return ManagementLockPaginator{}, err
	}

	p := ManagementLockPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ManagementLockPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ManagementLockPaginator) NextPage(ctx context.Context) ([]ManagementLock, error) {
	var response ManagementLockSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ManagementLock
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listManagementLockFilters = map[string]string{
	"akas":             "description.Lock.ID",
	"id":               "description.Lock.ID",
	"kaytu_account_id": "metadata.SourceID",
	"lock_level":       "description.Lock.ManagementLockProperties.Level",
	"name":             "description.Lock.Name",
	"notes":            "description.Lock.ManagementLockProperties.Notes",
	"owners":           "description.Lock.ManagementLockProperties.Owners",
	"resource_group":   "description.ResourceGroup",
	"title":            "description.Lock.Name",
	"type":             "description.Lock.ManagementLockProperties.Level",
}

func ListManagementLock(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListManagementLock")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewManagementLockPaginator(essdk.BuildFilter(d.KeyColumnQuals, listManagementLockFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getManagementLockFilters = map[string]string{
	"akas":             "description.Lock.ID",
	"id":               "description.Lock.ID",
	"kaytu_account_id": "metadata.SourceID",
	"lock_level":       "description.Lock.ManagementLockProperties.Level",
	"name":             "description.Lock.Name",
	"notes":            "description.Lock.ManagementLockProperties.Notes",
	"owners":           "description.Lock.ManagementLockProperties.Owners",
	"resource_group":   "description.ResourceGroup",
	"title":            "description.Lock.Name",
	"type":             "description.Lock.ManagementLockProperties.Level",
}

func GetManagementLock(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetManagementLock")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewManagementLockPaginator(essdk.BuildFilter(d.KeyColumnQuals, getManagementLockFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ManagementLock =============================

// ==========================  START: ResourceProvider =============================

type ResourceProvider struct {
	Description   azure.ResourceProviderDescription `json:"description"`
	Metadata      azure.Metadata                    `json:"metadata"`
	ResourceJobID int                               `json:"resource_job_id"`
	SourceJobID   int                               `json:"source_job_id"`
	ResourceType  string                            `json:"resource_type"`
	SourceType    string                            `json:"source_type"`
	ID            string                            `json:"id"`
	ARN           string                            `json:"arn"`
	SourceID      string                            `json:"source_id"`
}

type ResourceProviderHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  ResourceProvider `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type ResourceProviderHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []ResourceProviderHit `json:"hits"`
}

type ResourceProviderSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  ResourceProviderHits `json:"hits"`
}

type ResourceProviderPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewResourceProviderPaginator(filters []essdk.BoolFilter, limit *int64) (ResourceProviderPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_providers", filters, limit)
	if err != nil {
		return ResourceProviderPaginator{}, err
	}

	p := ResourceProviderPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ResourceProviderPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ResourceProviderPaginator) NextPage(ctx context.Context) ([]ResourceProvider, error) {
	var response ResourceProviderSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ResourceProvider
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listResourceProviderFilters = map[string]string{
	"akas":               "description.Provider.ID",
	"id":                 "description.Provider.ID",
	"kaytu_account_id":   "metadata.SourceID",
	"namespace":          "description.Provider.Namespace",
	"registration_state": "description.Provider.RegistrationState",
	"resource_types":     "description.Provider.ResourceTypes",
	"title":              "description.Provider.Namespace",
}

func ListResourceProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListResourceProvider")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewResourceProviderPaginator(essdk.BuildFilter(d.KeyColumnQuals, listResourceProviderFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getResourceProviderFilters = map[string]string{
	"akas":               "description.Provider.ID",
	"id":                 "description.Provider.ID",
	"kaytu_account_id":   "metadata.SourceID",
	"namespace":          "description.Provider.Namespace",
	"registration_state": "description.Provider.RegistrationState",
	"resource_types":     "description.Provider.ResourceTypes",
	"title":              "description.Provider.Namespace",
}

func GetResourceProvider(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetResourceProvider")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewResourceProviderPaginator(essdk.BuildFilter(d.KeyColumnQuals, getResourceProviderFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ResourceProvider =============================

// ==========================  START: ResourceGroup =============================

type ResourceGroup struct {
	Description   azure.ResourceGroupDescription `json:"description"`
	Metadata      azure.Metadata                 `json:"metadata"`
	ResourceJobID int                            `json:"resource_job_id"`
	SourceJobID   int                            `json:"source_job_id"`
	ResourceType  string                         `json:"resource_type"`
	SourceType    string                         `json:"source_type"`
	ID            string                         `json:"id"`
	ARN           string                         `json:"arn"`
	SourceID      string                         `json:"source_id"`
}

type ResourceGroupHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ResourceGroup `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ResourceGroupHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []ResourceGroupHit `json:"hits"`
}

type ResourceGroupSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  ResourceGroupHits `json:"hits"`
}

type ResourceGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewResourceGroupPaginator(filters []essdk.BoolFilter, limit *int64) (ResourceGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "microsoft_resources_subscriptions_resourcegroups", filters, limit)
	if err != nil {
		return ResourceGroupPaginator{}, err
	}

	p := ResourceGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ResourceGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ResourceGroupPaginator) NextPage(ctx context.Context) ([]ResourceGroup, error) {
	var response ResourceGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ResourceGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listResourceGroupFilters = map[string]string{
	"akas":               "description.Group.ID",
	"id":                 "description.Group.ID",
	"kaytu_account_id":   "metadata.SourceID",
	"managed_by":         "description.Group.ManagedBy",
	"name":               "description.Group.Name",
	"provisioning_state": "description.Group.Properties.ProvisioningState",
	"region":             "description.Group.Location",
	"tags":               "description.Group.Tags",
	"title":              "description.Group.Name",
	"type":               "description.Group.Type",
}

func ListResourceGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListResourceGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	paginator, err := k.NewResourceGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, listResourceGroupFilters, "azure", *cfg.AccountID), d.QueryContext.Limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	return nil, nil
}

var getResourceGroupFilters = map[string]string{
	"akas":               "description.Group.ID",
	"id":                 "description.Group.ID",
	"kaytu_account_id":   "metadata.SourceID",
	"managed_by":         "description.Group.ManagedBy",
	"name":               "description.Group.Name",
	"provisioning_state": "description.Group.Properties.ProvisioningState",
	"region":             "description.Group.Location",
	"tags":               "description.Group.Tags",
	"title":              "description.Group.Name",
	"type":               "description.Group.Type",
}

func GetResourceGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetResourceGroup")

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionManager.Cache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	limit := int64(1)
	paginator, err := k.NewResourceGroupPaginator(essdk.BuildFilter(d.KeyColumnQuals, getResourceGroupFilters, "azure", *cfg.AccountID), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	return nil, nil
}

// ==========================  END: ResourceGroup =============================
